export declare enum RenNetwork {
    Mainnet = "mainnet",
    Chaosnet = "chaosnet",
    Testnet = "testnet",
    Devnet = "devnet",
    Localnet = "localnet"
}
export declare const RenNetworks: RenNetwork[];
export declare const isRenNetwork: (maybeRenNetwork: any) => maybeRenNetwork is RenNetwork;
export declare enum Chain {
    Bitcoin = "Btc",
    Ethereum = "Eth",
    Zcash = "Zec",
    BitcoinCash = "Bch"
}
export declare const Chains: Chain[];
export declare const isChain: (maybeChain: any) => maybeChain is Chain;
export declare enum Asset {
    BTC = "BTC",
    ZEC = "ZEC",
    ETH = "ETH",
    BCH = "BCH"
}
export declare const Assets: Asset[];
export declare const isAsset: (maybeAsset: any) => maybeAsset is Asset;
export declare enum RenContract {
    Btc2Eth = "BTC0Btc2Eth",
    Eth2Btc = "BTC0Eth2Btc",
    Zec2Eth = "ZEC0Zec2Eth",
    Eth2Zec = "ZEC0Eth2Zec",
    Bch2Eth = "BCH0Bch2Eth",
    Eth2Bch = "BCH0Eth2Bch"
}
export declare const RenContracts: RenContract[];
export declare const isRenContract: (maybeRenContract: any) => maybeRenContract is RenContract;
export declare const Tokens: {
    BTC: {
        Mint: RenContract;
        Btc2Eth: RenContract;
        Burn: RenContract;
        Eth2Btc: RenContract;
    };
    ZEC: {
        Mint: RenContract;
        Zec2Eth: RenContract;
        Burn: RenContract;
        Eth2Zec: RenContract;
    };
    BCH: {
        Mint: RenContract;
        Bch2Eth: RenContract;
        Burn: RenContract;
        Eth2Bch: RenContract;
    };
};
export declare enum RenVMType {
    TypeAddress = "address",
    TypeStr = "str",
    TypeB32 = "b32",
    TypeB = "b",
    TypeI8 = "i8",
    TypeI16 = "i16",
    TypeI32 = "i32",
    TypeI64 = "i64",
    TypeI128 = "i128",
    TypeI256 = "i256",
    TypeU8 = "u8",
    TypeU16 = "u16",
    TypeU32 = "u32",
    TypeU64 = "u64",
    TypeU128 = "u128",
    TypeU256 = "u256",
    TypeRecord = "record",
    TypeList = "list",
    ExtTypeEthCompatAddress = "ext_ethCompatAddress",
    ExtTypeBtcCompatUTXO = "ext_btcCompatUTXO",
    ExtTypeBtcCompatUTXOs = "ext_btcCompatUTXOs",
    ExtTypeEthCompatTx = "ext_ethCompatTx",
    ExtEthCompatPayload = "ext_ethCompatPayload"
}
export interface RenVMOutputUTXO {
    txHash: RenVMValue<RenVMType.TypeB32>;
    vOut: RenVMValue<RenVMType.TypeU32>;
    scriptPubKey: RenVMValue<RenVMType.TypeB>;
    amount: RenVMValue<RenVMType.TypeU64>;
}
export interface RenVMInputUTXO {
    txHash: RenVMValue<RenVMType.TypeB32>;
    vOut: RenVMValue<RenVMType.TypeU32>;
    scriptPubKey?: RenVMValue<RenVMType.TypeB>;
    amount?: RenVMValue<RenVMType.TypeU64>;
}
export declare type RenVMUTXO = RenVMOutputUTXO | RenVMInputUTXO;
export declare type Base64String = string;
export declare type HexString = string;
export declare type DecimalString = string;
export interface ExtEthCompatPayload {
    abi: RenVMValue<RenVMType.TypeB>;
    value: RenVMValue<RenVMType.TypeB>;
    fn: RenVMValue<RenVMType.TypeB>;
}
export declare type RenVMValue<Type extends RenVMType> = Type extends RenVMType.TypeAddress ? string : Type extends RenVMType.TypeStr ? Base64String : Type extends RenVMType.TypeB32 ? Base64String : Type extends RenVMType.TypeB ? Base64String : Type extends RenVMType.TypeI8 ? DecimalString : Type extends RenVMType.TypeI16 ? DecimalString : Type extends RenVMType.TypeI32 ? DecimalString : Type extends RenVMType.TypeI64 ? DecimalString : Type extends RenVMType.TypeI128 ? DecimalString : Type extends RenVMType.TypeI256 ? DecimalString : Type extends RenVMType.TypeU8 ? DecimalString : Type extends RenVMType.TypeU16 ? DecimalString : Type extends RenVMType.TypeU32 ? DecimalString : Type extends RenVMType.TypeU64 ? DecimalString : Type extends RenVMType.TypeU128 ? DecimalString : Type extends RenVMType.TypeU256 ? DecimalString : Type extends RenVMType.TypeRecord ? any : Type extends RenVMType.TypeList ? any[] : Type extends RenVMType.ExtTypeEthCompatAddress ? HexString : Type extends RenVMType.ExtTypeBtcCompatUTXO ? RenVMUTXO : Type extends RenVMType.ExtTypeBtcCompatUTXOs ? RenVMUTXO[] : Type extends RenVMType.ExtTypeEthCompatTx ? any : Type extends RenVMType.ExtEthCompatPayload ? ExtEthCompatPayload : any;
export interface RenVMArg<Name extends string, Type extends RenVMType, Value extends RenVMValue<Type> = RenVMValue<Type>> {
    name: Name;
    type: Type;
    value: Value;
}
export declare type RenVMArgs = Array<RenVMArg<string, RenVMType>>;
export interface MintAndBurnFees {
    mint: RenVMValue<RenVMType.TypeU64>;
    burn: RenVMValue<RenVMType.TypeU64>;
}
export interface Fees {
    lock: RenVMValue<RenVMType.TypeU64>;
    release: RenVMValue<RenVMType.TypeU64>;
    ethereum: MintAndBurnFees;
}
