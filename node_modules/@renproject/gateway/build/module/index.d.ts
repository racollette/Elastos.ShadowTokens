import { RenNetworkDetails } from "@renproject/contracts";
import { Asset, BurnAndReleaseEvent, BurnAndReleaseParams, BurnAndReleaseParamsSimple, BurnAndReleaseStatus, Chain, HistoryEvent, LockAndMintEvent, LockAndMintParams, LockAndMintParamsSimple, LockAndMintStatus, Logger, LogLevelString, RenContract, RenNetwork, RenTokens, SendParams, UnmarshalledTx } from "@renproject/interfaces";
import { PromiEvent, utils } from "@renproject/utils";
import Web3 from "web3";
import { provider as Web3Provider } from "web3-providers";
import { useBrowserWeb3 } from "./web3";
export interface GatewayJSConfig {
    endpoint?: string;
    logLevel?: LogLevelString;
    logger?: Logger;
}
export declare type GatewayResult = PromiEvent<UnmarshalledTx | {}, {
    status: [LockAndMintStatus | BurnAndReleaseStatus, any];
    transferUpdated: [HistoryEvent];
}>;
export declare class Gateway {
    isPaused: boolean;
    isOpen: boolean;
    currentProvider: string | import("web3-providers").HttpProvider | import("web3-providers").IpcProvider | import("web3-providers").WebsocketProvider | import("web3-providers").Web3EthereumProvider | import("web3-providers").CustomProvider | null | undefined;
    private web3;
    private isCancelling;
    private blocknative;
    private readonly promiEvent;
    private readonly id;
    private readonly network;
    private readonly endpoint;
    private readonly logger;
    constructor(network: RenNetworkDetails, config: GatewayJSConfig, uniqueID?: string);
    readonly close: () => void;
    readonly pause: () => this;
    readonly resume: () => this;
    readonly cancel: () => Promise<this>;
    readonly getStatus: () => Promise<any>;
    readonly _getGateways: () => Promise<Map<string, HistoryEvent>>;
    readonly result: () => GatewayResult;
    readonly _open: (transferParams: LockAndMintParams | BurnAndReleaseParams | SendParams | LockAndMintEvent | BurnAndReleaseEvent, web3Provider?: string | import("web3-providers").HttpProvider | import("web3-providers").IpcProvider | import("web3-providers").WebsocketProvider | import("web3-providers").Web3EthereumProvider | import("web3-providers").CustomProvider | null | undefined) => Gateway;
    private readonly _eventListener;
    private readonly _sendMessage;
    private readonly _acknowledgeMessage;
    private readonly _addListener;
    private readonly _removeListener;
    private readonly _toggleSettings;
    private readonly _pause;
    private readonly _resume;
    private readonly _getSettingsButton;
    private readonly _getNotificationButton;
    private readonly _getOverlay;
    private readonly _getPopup;
    private readonly _getIFrame;
    private readonly _getOrCreateGatewayContainer;
}
export default class GatewayJS {
    static readonly Tokens: {
        BTC: {
            Mint: RenContract;
            Btc2Eth: RenContract;
            Burn: RenContract;
            Eth2Btc: RenContract;
        };
        ZEC: {
            Mint: RenContract;
            Zec2Eth: RenContract;
            Burn: RenContract;
            Eth2Zec: RenContract;
        };
        BCH: {
            Mint: RenContract;
            Bch2Eth: RenContract;
            Burn: RenContract;
            Eth2Bch: RenContract;
        };
    };
    static readonly Networks: typeof RenNetwork;
    static readonly Chains: typeof Chain;
    static readonly LockAndMintStatus: typeof LockAndMintStatus;
    static readonly BurnAndReleaseStatus: typeof BurnAndReleaseStatus;
    static readonly utils: typeof utils & {
        useBrowserWeb3: typeof useBrowserWeb3;
    };
    private readonly network;
    private readonly config;
    constructor(network?: RenNetwork | string, config?: GatewayJSConfig);
    /**
     * Returns a map containing previously opened gateways.
     */
    readonly getGateways: (options?: {
        all: boolean;
    } | undefined) => Promise<Map<string, HistoryEvent>>;
    /**
     * Start a cross-chain transfer onto Ethereum.
     *
     * @param {(LockAndMintParams | LockAndMintParamsSimple | SendParams)} params An object specifying the details
     *        required for the transfer.
     * @returns {Gateway}
     */
    readonly lockAndMint: (params: LockAndMintParams | LockAndMintParamsSimple | SendParams, uniqueID?: string | undefined) => Gateway;
    /**
     * Start a cross-chain transfer away from Ethereum.
     *
     * @param {(BurnAndReleaseParams | BurnAndReleaseParamsSimple | SendParams)} params An object specifying the details
     *        required for the transfer.
     * @returns {Gateway}
     */
    readonly burnAndRelease: (params: BurnAndReleaseParams | BurnAndReleaseParamsSimple | SendParams, uniqueID?: string | undefined) => Gateway;
    readonly open: (params: LockAndMintParams | LockAndMintParamsSimple | BurnAndReleaseParams | BurnAndReleaseParamsSimple | SendParams | LockAndMintEvent | BurnAndReleaseEvent, uniqueID?: string | undefined) => Gateway;
    readonly send: (params: SendParams, uniqueID?: string | undefined) => Gateway;
    readonly recoverTransfer: (web3Provider: Web3Provider, params: HistoryEvent, uniqueID?: string | undefined) => Gateway;
    readonly getTokenAddress: (web3: Web3, token: Asset | RenContract | "BTC" | "ZEC" | "BCH" | RenTokens) => Promise<string>;
    readonly getGatewayAddress: (web3: Web3, token: Asset | RenContract | "BTC" | "ZEC" | "BCH" | RenTokens) => Promise<any>;
}
