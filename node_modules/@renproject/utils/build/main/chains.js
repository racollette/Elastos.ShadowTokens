"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chains_1 = require("@renproject/chains");
const interfaces_1 = require("@renproject/interfaces");
const ethereumjs_util_1 = require("ethereumjs-util");
const common_1 = require("./common");
const renVMUtils_1 = require("./renVMUtils");
// const hexOrBase64ToBuffer = (value: string | Buffer): Buffer =>
//     typeof value === "string" ?
//         value.slice(0, 2) === "0x" ?
//             Buffer.from(strip0x(value), "hex") :
//             Buffer.from(value, "base64") :
//         Buffer.from(value);
exports.hash160 = (publicKey) => ethereumjs_util_1.ripemd160(ethereumjs_util_1.sha256(publicKey), false);
/**
 * Generate Gateway address for a cross-chain transfer's origin chain.
 */
exports.generateAddress = (renContract, gHash, mpkh, isTestnet) => {
    const chain = renVMUtils_1.parseRenContract(renContract).from;
    switch (chain) {
        case interfaces_1.Chain.Bitcoin:
            return chains_1.createBTCAddress(isTestnet, common_1.Ox(mpkh), gHash);
        case interfaces_1.Chain.Zcash:
            return chains_1.createZECAddress(isTestnet, common_1.Ox(mpkh), gHash);
        case interfaces_1.Chain.BitcoinCash:
            return chains_1.createBCHAddress(isTestnet, common_1.Ox(mpkh), gHash);
        default:
            throw new Error(`Unable to generate deposit address for chain ${chain}`);
    }
};
/**
 * Retrieves unspent deposits at the provided address.
 * An optional `confirmations` parameter limits UTXOs to ones with at least that
 * amount of confirmations.
 */
exports.retrieveDeposits = async (_network, renContract, address, confirmations = 0) => {
    const chain = renVMUtils_1.parseRenContract(renContract).from;
    switch (chain) {
        case interfaces_1.Chain.Bitcoin:
            return (await chains_1.getBitcoinUTXOs(_network)(address, confirmations)).map((utxo) => ({
                chain: interfaces_1.Chain.Bitcoin,
                utxo,
            }));
        case interfaces_1.Chain.Zcash:
            return (await chains_1.getZcashUTXOs(_network)(address, confirmations)).map((utxo) => ({
                chain: interfaces_1.Chain.Zcash,
                utxo,
            }));
        case interfaces_1.Chain.BitcoinCash:
            // tslint:disable-next-line: no-unnecessary-type-assertion
            return (await chains_1.getBitcoinCashUTXOs(_network)(address, confirmations)).map((utxo) => ({
                chain: interfaces_1.Chain.BitcoinCash,
                utxo,
            }));
        default:
            throw new Error(`Unable to retrieve deposits for chain ${chain}`);
    }
};
/**
 * Returns the number of confirmations for the specified UTXO.
 */
exports.retrieveUTXO = async (_network, chain, transaction) => {
    // tslint:disable-next-line: no-any
    const { txHash, vOut } = transaction;
    switch (chain) {
        case interfaces_1.Chain.Bitcoin:
            return await chains_1.getBitcoinUTXO(_network)(txHash, vOut);
        case interfaces_1.Chain.Zcash:
            return await chains_1.getZcashUTXO(_network)(txHash, vOut);
        case interfaces_1.Chain.BitcoinCash:
            // tslint:disable-next-line: no-unnecessary-type-assertion
            return await chains_1.getBitcoinCashUTXO(_network)(txHash, vOut);
        default:
            throw new Error(`Unable to retrieve deposits for chain ${chain}`);
    }
};
exports.btcUtils = {
    getUTXOs: chains_1.getBitcoinUTXOs,
    addressToHex: chains_1.btcAddressToHex,
    addressFrom: chains_1.btcAddressFrom,
};
exports.zecUtils = {
    getUTXOs: chains_1.getZcashUTXOs,
    addressToHex: chains_1.zecAddressToHex,
    addressFrom: chains_1.zecAddressFrom,
};
exports.bchUtils = {
    getUTXOs: chains_1.getBitcoinCashUTXOs,
    addressToHex: chains_1.bchAddressToHex,
    addressFrom: chains_1.bchAddressFrom,
};
exports.Tokens = {
    // Bitcoin
    BTC: Object.assign({}, interfaces_1.Tokens.BTC, exports.btcUtils),
    // Zcash
    ZEC: Object.assign({}, interfaces_1.Tokens.ZEC, exports.zecUtils),
    // Bitcoin Cash
    BCH: Object.assign({}, interfaces_1.Tokens.BCH, exports.bchUtils),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtDQW1CNEI7QUFFNUIsdURBUWdDO0FBQ2hDLHFEQUFvRDtBQUdwRCxxQ0FBOEI7QUFDOUIsNkNBQWdEO0FBRWhELGtFQUFrRTtBQUNsRSxrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLG1EQUFtRDtBQUNuRCw2Q0FBNkM7QUFDN0MsOEJBQThCO0FBRWpCLFFBQUEsT0FBTyxHQUFHLENBQUMsU0FBaUIsRUFBVSxFQUFFLENBQ2pELDJCQUFTLENBQUMsd0JBQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUV4Qzs7R0FFRztBQUNVLFFBQUEsZUFBZSxHQUFHLENBQzNCLFdBQXdCLEVBQ3hCLEtBQWEsRUFDYixJQUFZLEVBQ1osU0FBa0IsRUFDWixFQUFFO0lBQ1IsTUFBTSxLQUFLLEdBQUcsNkJBQWdCLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ2pELFFBQVEsS0FBSyxFQUFFO1FBQ1gsS0FBSyxrQkFBSyxDQUFDLE9BQU87WUFDZCxPQUFPLHlCQUFnQixDQUFDLFNBQVMsRUFBRSxXQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDeEQsS0FBSyxrQkFBSyxDQUFDLEtBQUs7WUFDWixPQUFPLHlCQUFnQixDQUFDLFNBQVMsRUFBRSxXQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDeEQsS0FBSyxrQkFBSyxDQUFDLFdBQVc7WUFDbEIsT0FBTyx5QkFBZ0IsQ0FBQyxTQUFTLEVBQUUsV0FBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3hEO1lBQ0ksTUFBTSxJQUFJLEtBQUssQ0FDWCxnREFBZ0QsS0FBSyxFQUFFLENBQzFELENBQUM7S0FDVDtBQUNMLENBQUMsQ0FBQztBQUVGOzs7O0dB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