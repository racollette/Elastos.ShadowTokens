/// <reference types="node" />
import { RenNetworkDetails } from "@renproject/contracts";
import { Asset, Chain, Logger, RenContract, RenTokens, UnmarshalledMintTx, UTXOIndex } from "@renproject/interfaces";
import Web3 from "web3";
/**
 * Hash the payloads associated with a RenVM cross-chain transaction.
 *
 * @param zip An array (or spread) of parameters with with types defined.
 */
export declare const generatePHash: (zip: import("@renproject/interfaces").EthArg<string, import("@renproject/interfaces").EthType, any>[], logger?: Logger | undefined) => string;
interface RenContractDetails {
    asset: Asset;
    from: Chain;
    to: Chain;
}
/**
 * parseRenContract splits a RenVM contract (e.g. `BTC0Eth2Btc`) into the asset
 * (`BTC`), the origin chain (`Eth`) and the target chain (`Btc`).
 */
export declare const parseRenContract: (renContract: RenContract) => RenContractDetails;
export declare const getTokenName: (tokenOrContract: Asset | RenContract | "BTC" | "ZEC" | "BCH" | RenTokens) => RenTokens;
export declare const syncGetTokenAddress: (renContract: RenContract, network: RenNetworkDetails) => string;
export declare const generateGHash: (payload: import("@renproject/interfaces").EthArg<string, import("@renproject/interfaces").EthType, any>[], to: string, renContract: RenContract, nonce: string, network: RenNetworkDetails, logger?: Logger | undefined) => string;
export declare const generateSighash: (pHash: string, amount: string | number, to: string, renContract: RenContract, nonceHash: string, network: RenNetworkDetails, logger?: Logger | undefined) => string;
export declare const txHashToBase64: (txHash: string | Buffer) => string;
export declare const generateMintTxHash: (renContract: RenContract, encodedID: string, utxo: UTXOIndex, logger?: Logger | undefined) => string;
export declare const generateBurnTxHash: (renContract: RenContract, encodedID: string, logger?: Logger | undefined) => string;
interface Signature {
    r: string;
    s: string;
    v: number;
}
export declare const signatureToString: <T extends Signature>(sig: T) => string;
export declare const fixSignature: (response: UnmarshalledMintTx, network: RenNetworkDetails, logger?: Logger | undefined) => Signature;
export declare const getTokenAddress: (network: RenNetworkDetails, web3: Web3, tokenOrContract: Asset | RenContract | "BTC" | "ZEC" | "BCH" | RenTokens) => Promise<string>;
export declare const getGatewayAddress: (network: RenNetworkDetails, web3: Web3, tokenOrContract: Asset | RenContract | "BTC" | "ZEC" | "BCH" | RenTokens) => Promise<any>;
export declare const findTransactionBySigHash: (network: RenNetworkDetails, web3: Web3, tokenOrContract: Asset | RenContract | "BTC" | "ZEC" | "BCH" | RenTokens, sigHash: string, logger?: Logger | undefined) => Promise<string | undefined>;
/**
 * Returns a random 32 byte hex string (prefixed with '0x').
 */
export declare const randomNonce: () => string;
export declare const resolveInToken: (sendToken: RenContract | "BTC" | "ZEC" | "BCH") => RenContract;
export declare const resolveOutToken: (sendToken: RenContract | "BTC" | "ZEC" | "BCH") => RenContract;
export declare const resolveSendTo: <T extends import("@renproject/interfaces").SerializableTransferParams>({ isMint }: {
    isMint: boolean;
}) => (params: T) => T;
export {};
