{"ast":null,"code":"var base58 = require('./crypto/base58');\n\nvar segwit = require('./crypto/segwit_addr');\n\nvar cryptoUtils = require('./crypto/utils');\n\nvar DEFAULT_NETWORK_TYPE = 'prod';\n\nfunction getDecoded(address) {\n  try {\n    return base58.decode(address);\n  } catch (e) {\n    // if decoding fails, assume invalid address\n    return null;\n  }\n}\n\nfunction getChecksum(hashFunction, payload) {\n  // Each currency may implement different hashing algorithm\n  switch (hashFunction) {\n    case 'blake256':\n      return cryptoUtils.blake256Checksum(payload);\n      break;\n\n    case 'sha256':\n    default:\n      return cryptoUtils.sha256Checksum(payload);\n  }\n}\n\nfunction getAddressType(address, currency) {\n  currency = currency || {}; // should be 25 bytes per btc address spec and 26 decred\n\n  var expectedLength = currency.expectedLength || 25;\n  var hashFunction = currency.hashFunction || 'sha256';\n  var decoded = getDecoded(address);\n\n  if (decoded) {\n    var length = decoded.length;\n\n    if (length !== expectedLength) {\n      return null;\n    }\n\n    var checksum = cryptoUtils.toHex(decoded.slice(length - 4, length)),\n        body = cryptoUtils.toHex(decoded.slice(0, length - 4)),\n        goodChecksum = getChecksum(hashFunction, body);\n    return checksum === goodChecksum ? cryptoUtils.toHex(decoded.slice(0, expectedLength - 24)) : null;\n  }\n\n  return null;\n}\n\nfunction isValidP2PKHandP2SHAddress(address, currency, networkType) {\n  networkType = networkType || DEFAULT_NETWORK_TYPE;\n  var correctAddressTypes;\n  var addressType = getAddressType(address, currency);\n\n  if (addressType) {\n    if (networkType === 'prod' || networkType === 'testnet') {\n      correctAddressTypes = currency.addressTypes[networkType];\n    } else {\n      correctAddressTypes = currency.addressTypes.prod.concat(currency.addressTypes.testnet);\n    }\n\n    return correctAddressTypes.indexOf(addressType) >= 0;\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  isValidAddress: function (address, currency, networkType) {\n    return isValidP2PKHandP2SHAddress(address, currency, networkType) || segwit.isValidAddress(address, currency.segwitHrp);\n  }\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/wallet-address-validator/src/bitcoin_validator.js"],"names":["base58","require","segwit","cryptoUtils","DEFAULT_NETWORK_TYPE","getDecoded","address","decode","e","getChecksum","hashFunction","payload","blake256Checksum","sha256Checksum","getAddressType","currency","expectedLength","decoded","length","checksum","toHex","slice","body","goodChecksum","isValidP2PKHandP2SHAddress","networkType","correctAddressTypes","addressType","addressTypes","prod","concat","testnet","indexOf","module","exports","isValidAddress","segwitHrp"],"mappings":"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","sourcesContent":["var base58 = require('./crypto/base58');\nvar segwit = require('./crypto/segwit_addr');\nvar cryptoUtils = require('./crypto/utils');\n\nvar DEFAULT_NETWORK_TYPE = 'prod';\n\nfunction getDecoded(address) {\n    try {\n        return base58.decode(address);\n    } catch (e) {\n        // if decoding fails, assume invalid address\n        return null;\n    }\n}\n\nfunction getChecksum(hashFunction, payload) {\n    // Each currency may implement different hashing algorithm\n    switch (hashFunction) {\n        case 'blake256':\n            return cryptoUtils.blake256Checksum(payload);\n            break;\n        case 'sha256':\n        default:\n            return cryptoUtils.sha256Checksum(payload);\n    }\n}\n\nfunction getAddressType(address, currency) {\n    currency = currency || {};\n    // should be 25 bytes per btc address spec and 26 decred\n    var expectedLength = currency.expectedLength || 25;\n    var hashFunction = currency.hashFunction || 'sha256';\n    var decoded = getDecoded(address);\n\n    if (decoded) {\n        var length = decoded.length;\n\n        if (length !== expectedLength) {\n            return null;\n        }\n\n        var checksum = cryptoUtils.toHex(decoded.slice(length - 4, length)),\n            body = cryptoUtils.toHex(decoded.slice(0, length - 4)),\n            goodChecksum = getChecksum(hashFunction, body);\n\n        return checksum === goodChecksum ? cryptoUtils.toHex(decoded.slice(0, expectedLength - 24)) : null;\n    }\n\n    return null;\n}\n\nfunction isValidP2PKHandP2SHAddress(address, currency, networkType) {\n    networkType = networkType || DEFAULT_NETWORK_TYPE;\n\n    var correctAddressTypes;\n    var addressType = getAddressType(address, currency);\n\n    if (addressType) {\n        if (networkType === 'prod' || networkType === 'testnet') {\n            correctAddressTypes = currency.addressTypes[networkType]\n        } else {\n            correctAddressTypes = currency.addressTypes.prod.concat(currency.addressTypes.testnet);\n        }\n\n        return correctAddressTypes.indexOf(addressType) >= 0;\n    }\n\n    return false;\n}\n\nmodule.exports = {\n    isValidAddress: function (address, currency, networkType) {\n        return isValidP2PKHandP2SHAddress(address, currency, networkType) || segwit.isValidAddress(address, currency.segwitHrp);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}