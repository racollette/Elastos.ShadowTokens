{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar Sighash = require('../sighash');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar TransactionSignature = require('../signature');\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\n\n\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\n\ninherits(PublicKeyInput, Input);\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {String} signingMethod - the signing method used to sign tx \"ecdsa\" or \"schnorr\"\n * @return {Array} of objects that can be\n */\n\nPublicKeyInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n  var publicKey = privateKey.toPublicKey();\n\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN, undefined, signingMethod),\n      sigtype: sigtype\n    })];\n  }\n\n  return [];\n};\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - the method used in signing the tx \"ecdsa\" or \"schnorr\"\n * @return {PublicKeyInput} this, for chaining\n */\n\n\nPublicKeyInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(signature.signature.toDER(signingMethod), signature.sigtype));\n  return this;\n};\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyInput.prototype.clearSignatures = function () {\n  this.setScript(Script.empty());\n  return this;\n};\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\n\n\nPublicKeyInput.prototype.isFullySigned = function () {\n  return this.script.isPublicKeyIn();\n};\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function () {\n  return PublicKeyInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyInput;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib-cash/lib/transaction/input/publickey.js"],"names":["inherits","require","$","BufferUtil","Input","Output","Sighash","Script","Signature","TransactionSignature","PublicKeyInput","apply","arguments","prototype","getSignatures","transaction","privateKey","index","sigtype","hashData","signingMethod","checkState","output","SIGHASH_ALL","SIGHASH_FORKID","publicKey","toPublicKey","toString","script","getPublicKey","prevTxId","outputIndex","inputIndex","signature","sign","satoshisBN","undefined","addSignature","isValidSignature","setScript","buildPublicKeyIn","toDER","clearSignatures","empty","isFullySigned","isPublicKeyIn","SCRIPT_MAX_SIZE","_estimateSize","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AAEA,IAAIC,CAAC,GAAGD,OAAO,CAAC,0BAAD,CAAf;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,mBAAD,CAAxB;;AAEA,IAAIG,KAAK,GAAGH,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIK,OAAO,GAAGL,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,cAAD,CAApB;;AACA,IAAIO,SAAS,GAAGP,OAAO,CAAC,wBAAD,CAAvB;;AACA,IAAIQ,oBAAoB,GAAGR,OAAO,CAAC,cAAD,CAAlC;AAEA;;;;;;AAIA,SAASS,cAAT,GAA0B;AACxBN,EAAAA,KAAK,CAACO,KAAN,CAAY,IAAZ,EAAkBC,SAAlB;AACD;;AACDZ,QAAQ,CAACU,cAAD,EAAiBN,KAAjB,CAAR;AAEA;;;;;;;;;AAQAM,cAAc,CAACG,SAAf,CAAyBC,aAAzB,GAAyC,UAASC,WAAT,EAAsBC,UAAtB,EAAkCC,KAAlC,EAAyCC,OAAzC,EAAkDC,QAAlD,EAA4DC,aAA5D,EAA2E;AAClHlB,EAAAA,CAAC,CAACmB,UAAF,CAAa,KAAKC,MAAL,YAAuBjB,MAApC;AACAa,EAAAA,OAAO,GAAGA,OAAO,IAAKV,SAAS,CAACe,WAAV,GAAyBf,SAAS,CAACgB,cAAzD;AACA,MAAIC,SAAS,GAAGT,UAAU,CAACU,WAAX,EAAhB;;AACA,MAAID,SAAS,CAACE,QAAV,OAAyB,KAAKL,MAAL,CAAYM,MAAZ,CAAmBC,YAAnB,GAAkCF,QAAlC,CAA2C,KAA3C,CAA7B,EAAgF;AAC9E,WAAO,CAAC,IAAIlB,oBAAJ,CAAyB;AAC/BgB,MAAAA,SAAS,EAAEA,SADoB;AAE/BK,MAAAA,QAAQ,EAAE,KAAKA,QAFgB;AAG/BC,MAAAA,WAAW,EAAE,KAAKA,WAHa;AAI/BC,MAAAA,UAAU,EAAEf,KAJmB;AAK/BgB,MAAAA,SAAS,EAAE3B,OAAO,CAAC4B,IAAR,CAAanB,WAAb,EAA0BC,UAA1B,EAAsCE,OAAtC,EAA+CD,KAA/C,EAAsD,KAAKK,MAAL,CAAYM,MAAlE,EAA0E,KAAKN,MAAL,CAAYa,UAAtF,EAAkGC,SAAlG,EAA6GhB,aAA7G,CALoB;AAM/BF,MAAAA,OAAO,EAAEA;AANsB,KAAzB,CAAD,CAAP;AAQD;;AACD,SAAO,EAAP;AACD,CAfD;AAiBA;;;;;;;;;;;;AAUAR,cAAc,CAACG,SAAf,CAAyBwB,YAAzB,GAAwC,UAAStB,WAAT,EAAsBkB,SAAtB,EAAiCb,aAAjC,EAAgD;AACtFlB,EAAAA,CAAC,CAACmB,UAAF,CAAa,KAAKiB,gBAAL,CAAsBvB,WAAtB,EAAmCkB,SAAnC,EAA8Cb,aAA9C,CAAb,EAA2E,sBAA3E;AACA,OAAKmB,SAAL,CAAehC,MAAM,CAACiC,gBAAP,CACbP,SAAS,CAACA,SAAV,CAAoBQ,KAApB,CAA0BrB,aAA1B,CADa,EAEba,SAAS,CAACf,OAFG,CAAf;AAIA,SAAO,IAAP;AACD,CAPD;AASA;;;;;;AAIAR,cAAc,CAACG,SAAf,CAAyB6B,eAAzB,GAA2C,YAAW;AACpD,OAAKH,SAAL,CAAehC,MAAM,CAACoC,KAAP,EAAf;AACA,SAAO,IAAP;AACD,CAHD;AAKA;;;;;;AAIAjC,cAAc,CAACG,SAAf,CAAyB+B,aAAzB,GAAyC,YAAW;AAClD,SAAO,KAAKhB,MAAL,CAAYiB,aAAZ,EAAP;AACD,CAFD;;AAIAnC,cAAc,CAACoC,eAAf,GAAiC,EAAjC,C,CAAqC;;AAErCpC,cAAc,CAACG,SAAf,CAAyBkC,aAAzB,GAAyC,YAAW;AAClD,SAAOrC,cAAc,CAACoC,eAAtB;AACD,CAFD;;AAIAE,MAAM,CAACC,OAAP,GAAiBvC,cAAjB","sourcesContent":["'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyInput, Input);\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {String} signingMethod - the signing method used to sign tx \"ecdsa\" or \"schnorr\"\n * @return {Array} of objects that can be\n */\nPublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || (Signature.SIGHASH_ALL |  Signature.SIGHASH_FORKID);\n  var publicKey = privateKey.toPublicKey();\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN, undefined, signingMethod),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - the method used in signing the tx \"ecdsa\" or \"schnorr\"\n * @return {PublicKeyInput} this, for chaining\n */\nPublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(\n    signature.signature.toDER(signingMethod),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyIn();\n};\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function() {\n  return PublicKeyInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyInput;\n"]},"metadata":{},"sourceType":"script"}