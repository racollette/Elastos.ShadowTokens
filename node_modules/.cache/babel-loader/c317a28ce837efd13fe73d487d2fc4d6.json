{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar btemplates = require('./templates');\n\nvar coins = require('./coins');\n\nvar networks = require('./networks');\n\nvar ops = require('bitcoin-ops');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar scriptTypes = btemplates.types;\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG];\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH]);\n\nvar ECPair = require('./ecpair');\n\nvar ECSignature = require('./ecsignature');\n\nvar Transaction = require('./transaction');\n\nvar debug = require('debug')('bitgo:utxolib:txbuilder');\n\nfunction supportedType(type) {\n  return SIGNABLE.indexOf(type) !== -1;\n}\n\nfunction supportedP2SHType(type) {\n  return P2SH.indexOf(type) !== -1;\n}\n\nfunction extractChunks(type, chunks, script) {\n  var pubKeys = [];\n  var signatures = [];\n\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1);\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined;\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script);\n        pubKeys = multisig.pubKeys;\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk;\n      });\n      break;\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  };\n}\n\nfunction expandInput(scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  var prevOutScript;\n  var prevOutType;\n  var scriptType;\n  var script;\n  var redeemScript;\n  var witnessScript;\n  var witnessScriptType;\n  var redeemScriptType;\n  var witness = false;\n  var p2wsh = false;\n  var p2sh = false;\n  var witnessProgram;\n  var chunks;\n  var scriptSigChunks = bscript.decompile(scriptSig);\n  var sigType = btemplates.classifyInput(scriptSigChunks, true);\n\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true;\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1];\n    redeemScriptType = btemplates.classifyOutput(redeemScript);\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript));\n    prevOutType = scriptTypes.P2SH;\n    script = redeemScript;\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true);\n\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1];\n    witnessScriptType = btemplates.classifyOutput(witnessScript);\n    p2wsh = true;\n    witness = true;\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n      prevOutType = scriptTypes.P2WSH;\n\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary');\n      } // bare witness\n\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty');\n      }\n\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript');\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script');\n    }\n\n    script = witnessScript;\n    scriptType = witnessScriptType;\n    chunks = witnessStack.slice(0, -1);\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true;\n    var key = witnessStack[witnessStack.length - 1];\n    var keyHash = bcrypto.hash160(key);\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash);\n      prevOutType = scriptTypes.P2WPKH;\n\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary');\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty');\n      }\n\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash);\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program');\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH;\n    chunks = witnessStack;\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!');\n    }\n\n    script = redeemScript;\n    scriptType = redeemScriptType;\n    chunks = scriptSigChunks.slice(0, -1);\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig);\n    chunks = scriptSigChunks;\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script);\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  };\n\n  if (p2sh) {\n    result.redeemScript = redeemScript;\n    result.redeemScriptType = redeemScriptType;\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript;\n    result.witnessScriptType = witnessScriptType;\n  }\n\n  return result;\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin, value, network) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return;\n  if (input.pubKeys.length === input.signatures.length) return;\n  network = network || networks.bitcoin;\n  var unmatched = input.signatures.concat();\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey);\n    var match; // check for a signature\n\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      var parsed = ECSignature.parseScriptSignature(signature);\n      var hash;\n\n      switch (network.coin) {\n        case coins.BSV:\n        case coins.BCH:\n          hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType);\n          break;\n\n        case coins.BTG:\n          hash = transaction.hashForGoldSignature(vin, input.signScript, value, parsed.hashType);\n          break;\n\n        case coins.ZEC:\n          if (value === undefined) {\n            return false;\n          }\n\n          hash = transaction.hashForZcashSignature(vin, input.signScript, value, parsed.hashType);\n          break;\n\n        default:\n          if (input.witness) {\n            hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType);\n          } else {\n            hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType);\n          }\n\n          break;\n      } // skip if signature does not match pubKey\n\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script);\n  var scriptChunks = bscript.decompile(script);\n\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script);\n  }\n\n  var pubKeys = [];\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break;\n      var pkh1 = scriptChunks[2];\n      var pkh2 = bcrypto.hash160(ourPubKey);\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey];\n      break;\n    // does our hash160(pubKey) match the output scripts?\n\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break;\n      var wpkh1 = scriptChunks[1];\n      var wpkh2 = bcrypto.hash160(ourPubKey);\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey];\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2);\n      break;\n\n    default:\n      return {\n        scriptType: scriptType\n      };\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () {\n      return undefined;\n    })\n  };\n}\n\nfunction checkP2SHInput(input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH');\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)');\n  }\n}\n\nfunction checkP2WSHInput(input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH');\n    var scriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)');\n  }\n}\n\nfunction prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded;\n  var prevOutType;\n  var prevOutScript;\n  var p2sh = false;\n  var p2shType;\n  var redeemScriptHash;\n  var witness = false;\n  var p2wsh = false;\n  var witnessType;\n  var witnessScriptHash;\n  var signType;\n  var signScript;\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2SHInput(input, redeemScriptHash);\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script');\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = witness = p2wsh = true;\n    p2shType = btemplates.types.P2WSH;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    checkP2SHInput(input, redeemScriptHash);\n    expanded = expandOutput(redeemScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = true;\n    signType = p2shType = expanded.scriptType;\n    signScript = redeemScript;\n    witness = signType === btemplates.types.P2WPKH;\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2WSHInput(input, witnessScriptHash);\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2WSH;\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash);\n    witness = p2wsh = true;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH || input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    }\n\n    prevOutType = input.prevOutType;\n    prevOutScript = input.prevOutScript;\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey);\n    if (!expanded.pubKeys) return;\n    witness = input.prevOutType === scriptTypes.P2WPKH;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey));\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey);\n    prevOutType = scriptTypes.P2PKH;\n    witness = false;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript));\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript;\n    input.redeemScriptType = p2shType;\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript;\n    input.witnessScriptType = witnessType;\n  }\n\n  input.pubKeys = expanded.pubKeys;\n  input.signatures = expanded.signatures;\n  input.signScript = signScript;\n  input.signType = signType;\n  input.prevOutScript = prevOutScript;\n  input.prevOutType = prevOutType;\n  input.witness = witness;\n}\n\nfunction buildStack(type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0]);\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0]);\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0;\n      });\n\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) {\n          return x !== ops.OP_0;\n        });\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures);\n    }\n  } else {\n    throw new Error('Not yet supported');\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided');\n  return [];\n}\n\nfunction buildInput(input, allowIncomplete) {\n  var scriptType = input.prevOutType;\n  var sig = [];\n  var witness = [];\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete);\n  }\n\n  var p2sh = false;\n\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type');\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete);\n    } // If it wasn't SIGNABLE, it's witness, defer to that\n\n\n    if (input.redeemScriptType) {\n      p2sh = true;\n      scriptType = input.redeemScriptType;\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete);\n      break;\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type');\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete);\n        witness.push(input.witnessScript);\n        scriptType = input.witnessScriptType;\n      }\n\n      break;\n  } // append redeemScript if necessary\n\n\n  if (p2sh) {\n    sig.push(input.redeemScript);\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  };\n} // By default, assume is a bitcoin transaction\n\n\nfunction TransactionBuilder(network, maximumFeeRate) {\n  this.prevTxMap = {};\n  this.network = network || networks.bitcoin; // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n\n  this.maximumFeeRate = maximumFeeRate || 2500;\n  this.inputs = [];\n  this.tx = new Transaction(this.network);\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false;\n    return input.signatures.some(function (s) {\n      return s;\n    });\n  })) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  this.tx.locktime = locktime;\n};\n\nTransactionBuilder.prototype.setVersion = function (version, overwinter = true) {\n  typeforce(types.UInt32, version);\n\n  if (coins.isZcash(this.network)) {\n    if (!this.network.consensusBranchId.hasOwnProperty(this.tx.version)) {\n      throw new Error('Unsupported Zcash transaction');\n    }\n\n    this.tx.overwintered = overwinter ? 1 : 0;\n  }\n\n  this.tx.version = version;\n};\n\nTransactionBuilder.prototype.setVersionGroupId = function (versionGroupId) {\n  if (!(coins.isZcash(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n\n  typeforce(types.UInt32, versionGroupId);\n  this.tx.versionGroupId = versionGroupId;\n};\n\nTransactionBuilder.prototype.setExpiryHeight = function (expiryHeight) {\n  if (!(coins.isZcash(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n\n  typeforce(types.UInt32, expiryHeight);\n  this.tx.expiryHeight = expiryHeight;\n};\n\nTransactionBuilder.prototype.setJoinSplits = function (transaction) {\n  if (!(coins.isZcash(this.network) && this.tx.supportsJoinSplits())) {\n    throw new Error('joinsplits can only be set for Zcash starting at version 2. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n\n  if (transaction && transaction.joinsplits) {\n    this.tx.joinsplits = transaction.joinsplits.map(function (txJoinsplit) {\n      return {\n        vpubOld: txJoinsplit.vpubOld,\n        vpubNew: txJoinsplit.vpubNew,\n        anchor: txJoinsplit.anchor,\n        nullifiers: txJoinsplit.nullifiers,\n        commitments: txJoinsplit.commitments,\n        ephemeralKey: txJoinsplit.ephemeralKey,\n        randomSeed: txJoinsplit.randomSeed,\n        macs: txJoinsplit.macs,\n        zproof: txJoinsplit.zproof,\n        ciphertexts: txJoinsplit.ciphertexts\n      };\n    });\n    this.tx.joinsplitPubkey = transaction.joinsplitPubkey;\n    this.tx.joinsplitSig = transaction.joinsplitSig;\n    return;\n  }\n\n  throw new Error('Invalid transaction with joinsplits');\n};\n\nTransactionBuilder.fromTransaction = function (transaction, network) {\n  var txbNetwork = network || networks.bitcoin;\n  var txb = new TransactionBuilder(txbNetwork);\n\n  if (txb.network.coin !== transaction.network.coin) {\n    throw new Error('This transaction is incompatible with the transaction builder');\n  } // Copy transaction fields\n\n\n  txb.setVersion(transaction.version, transaction.overwintered);\n  txb.setLockTime(transaction.locktime);\n\n  if (coins.isZcash(txbNetwork)) {\n    // Copy Zcash overwinter fields. Omitted if the transaction builder is not for Zcash.\n    if (txb.tx.isOverwinterCompatible()) {\n      txb.setVersionGroupId(transaction.versionGroupId);\n      txb.setExpiryHeight(transaction.expiryHeight);\n    } // We don't support protected transactions but we copy the joinsplits for consistency. However, the transaction\n    // builder will fail when we try to sign one of these transactions\n\n\n    if (txb.tx.supportsJoinSplits()) {\n      txb.setJoinSplits(transaction);\n    }\n  } // Copy Dash special transaction fields. Omitted if the transaction builder is not for Dash.\n\n\n  if (coins.isDash(txbNetwork)) {\n    typeforce(types.UInt16, transaction.type);\n    txb.tx.type = transaction.type;\n\n    if (txb.tx.versionSupportsDashSpecialTransactions()) {\n      typeforce(types.Buffer, transaction.extraPayload);\n      txb.tx.extraPayload = transaction.extraPayload;\n    }\n  } // Copy outputs (done first to avoid signature invalidation)\n\n\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value);\n  }); // Copy inputs\n\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    });\n  }); // fix some things not possible through the public API\n\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, txbNetwork);\n  });\n  return txb;\n};\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  var value; // is it a hex string?\n\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse(); // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout];\n    prevOutScript = txOut.script;\n    value = txOut.value;\n    txHash = txHash.getHash();\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  });\n};\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported');\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout;\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n  var input = {}; // derive what we can from the scriptSig\n\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || []);\n  } // if an input value was given, retain it\n\n\n  if (options.value !== undefined) {\n    input.value = options.value;\n  } // derive what we can from the previous transactions output script\n\n\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType;\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript);\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys;\n        input.signatures = expanded.signatures;\n      }\n\n      prevOutType = expanded.scriptType;\n    }\n\n    input.prevOutScript = options.prevOutScript;\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript);\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig);\n  this.inputs[vin] = input;\n  this.prevTxMap[prevTxOut] = vin;\n  return vin;\n};\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures');\n  } // Attempt to get a script if it's a base58 address string\n\n\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n  }\n\n  return this.tx.addOutput(scriptPubKey, value);\n};\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false);\n};\n\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true);\n};\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs');\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs');\n  }\n\n  var tx = this.tx.clone(); // Create script signatures from inputs\n\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType;\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete');\n    var result = buildInput(input, allowIncomplete); // skip if no result\n\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported');\n      }\n    }\n\n    tx.setInputScript(i, result.script);\n    tx.setWitness(i, result.witness);\n  });\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees');\n    }\n  }\n\n  return tx;\n};\n\nfunction canSign(input) {\n  return input.prevOutScript !== undefined && input.signScript !== undefined && input.pubKeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubKeys.length && input.pubKeys.length > 0 && (input.witness === false || input.witness === true && input.value !== undefined);\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n  debug('Signing transaction: (input: %d, hashType: %d, witnessVal: %s, witnessScript: %j)', vin, hashType, witnessValue, witnessScript);\n  debug('Transaction Builder network: %j', this.network); // TODO: remove keyPair.network matching in 4.0.0\n\n  if (keyPair.network && keyPair.network !== this.network) throw new TypeError('Inconsistent network');\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || Transaction.SIGHASH_ALL;\n  var input = this.inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    debug('Preparing input %d for signing', vin);\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript);\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n\n\n  var signatureHash;\n\n  if (coins.isBitcoinGold(this.network)) {\n    signatureHash = this.tx.hashForGoldSignature(vin, input.signScript, witnessValue, hashType, input.witness);\n    debug('Calculated BTG sighash (%s)', signatureHash.toString('hex'));\n  } else if (coins.isBitcoinCash(this.network) || coins.isBitcoinSV(this.network)) {\n    signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType);\n    debug('Calculated BCH sighash (%s)', signatureHash.toString('hex'));\n  } else if (coins.isZcash(this.network)) {\n    signatureHash = this.tx.hashForZcashSignature(vin, input.signScript, witnessValue, hashType);\n    debug('Calculated ZEC sighash (%s)', signatureHash.toString('hex'));\n  } else {\n    if (input.witness) {\n      signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType);\n      debug('Calculated witnessv0 sighash (%s)', signatureHash.toString('hex'));\n    } else {\n      signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType);\n      debug('Calculated sighash (%s)', signatureHash.toString('hex'));\n    }\n  } // enforce in order signing of public keys\n\n\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    if (kpPubKey.length !== 33 && input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    var signature = keyPair.sign(signatureHash);\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature);\n    debug('Produced signature (r: %s, s: %s)', signature.r, signature.s);\n    input.signatures[i] = signature.toScriptSignature(hashType);\n    return true;\n  });\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n};\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n\n      return hashType & Transaction.SIGHASH_ANYONECANPAY;\n    });\n  });\n};\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length;\n  var nOutputs = this.tx.outs.length;\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature);\n      var hashTypeMod = hashType & 0x1f;\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true;\n\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs;\n      }\n    });\n  });\n};\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) {\n    return a + (x.value >>> 0);\n  }, 0); // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n\n  var outgoing = this.tx.outs.reduce(function (a, x) {\n    return a + x.value;\n  }, 0);\n  var fee = incoming - outgoing;\n  var feeRate = fee / bytes;\n  return feeRate > this.maximumFeeRate;\n};\n\nmodule.exports = TransactionBuilder;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitgo-utxo-lib/src/transaction_builder.js"],"names":["Buffer","require","baddress","bcrypto","bscript","btemplates","coins","networks","ops","typeforce","types","scriptTypes","SIGNABLE","P2PKH","P2PK","MULTISIG","P2SH","concat","P2WPKH","P2WSH","ECPair","ECSignature","Transaction","debug","supportedType","type","indexOf","supportedP2SHType","extractChunks","chunks","script","pubKeys","signatures","slice","pubKey","output","decode","undefined","multisig","map","chunk","length","expandInput","scriptSig","witnessStack","prevOutScript","prevOutType","scriptType","redeemScript","witnessScript","witnessScriptType","redeemScriptType","witness","p2wsh","p2sh","witnessProgram","scriptSigChunks","decompile","sigType","classifyInput","classifyOutput","scriptHash","encode","hash160","classifyWitness","witnessScriptHash","sha256","Error","equals","key","keyHash","witnessPubKeyHash","expanded","result","signType","signScript","Boolean","fixMultisigOrder","input","transaction","vin","value","network","bitcoin","unmatched","keyPair","fromPublicKeyBuffer","match","some","signature","i","parsed","parseScriptSignature","hash","coin","BSV","BCH","hashForCashSignature","hashType","BTG","hashForGoldSignature","ZEC","hashForZcashSignature","hashForWitnessV0","hashForSignature","verify","expandOutput","ourPubKey","scriptChunks","pkh1","pkh2","wpkh1","wpkh2","checkP2SHInput","redeemScriptHash","prevOutScriptScriptHash","checkP2WSHInput","prepareInput","kpPubKey","witnessValue","p2shType","witnessType","toASM","pubKeyHash","buildStack","allowIncomplete","isBuffer","encodeStack","OP_0","filter","x","buildInput","sig","push","compile","TransactionBuilder","maximumFeeRate","prevTxMap","inputs","tx","prototype","setLockTime","locktime","UInt32","s","setVersion","version","overwinter","isZcash","consensusBranchId","hasOwnProperty","overwintered","setVersionGroupId","versionGroupId","isOverwinterCompatible","setExpiryHeight","expiryHeight","setJoinSplits","supportsJoinSplits","joinsplits","txJoinsplit","vpubOld","vpubNew","anchor","nullifiers","commitments","ephemeralKey","randomSeed","macs","zproof","ciphertexts","joinsplitPubkey","joinsplitSig","fromTransaction","txbNetwork","txb","isDash","UInt16","versionSupportsDashSpecialTransactions","extraPayload","outs","forEach","txOut","addOutput","ins","txIn","__addInputUnsafe","index","sequence","addInput","txHash","vout","__canModifyInputs","from","reverse","getHash","options","isCoinbaseHash","prevTxOut","toString","scriptPubKey","__canModifyOutputs","toOutputScript","build","__build","buildIncomplete","clone","setInputScript","setWitness","__overMaximumFees","virtualSize","canSign","sign","TypeError","SIGHASH_ALL","publicKey","getPublicKeyBuffer","Satoshi","signatureHash","isBitcoinGold","isBitcoinCash","isBitcoinSV","signed","fromRSBuffer","r","toScriptSignature","signatureHashType","buffer","readUInt8","every","SIGHASH_ANYONECANPAY","nInputs","nOutputs","hashTypeMod","SIGHASH_NONE","SIGHASH_SINGLE","bytes","incoming","reduce","a","outgoing","fee","feeRate","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar baddress = require('./address')\nvar bcrypto = require('./crypto')\nvar bscript = require('./script')\nvar btemplates = require('./templates')\nvar coins = require('./coins')\nvar networks = require('./networks')\nvar ops = require('bitcoin-ops')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar scriptTypes = btemplates.types\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG]\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH])\n\nvar ECPair = require('./ecpair')\nvar ECSignature = require('./ecsignature')\nvar Transaction = require('./transaction')\n\nvar debug = require('debug')('bitgo:utxolib:txbuilder')\n\nfunction supportedType (type) {\n  return SIGNABLE.indexOf(type) !== -1\n}\n\nfunction supportedP2SHType (type) {\n  return P2SH.indexOf(type) !== -1\n}\n\nfunction extractChunks (type, chunks, script) {\n  var pubKeys = []\n  var signatures = []\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1)\n      signatures = chunks.slice(0, 1)\n      break\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined\n      signatures = chunks.slice(0, 1)\n      break\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script)\n        pubKeys = multisig.pubKeys\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk\n      })\n      break\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  }\n}\nfunction expandInput (scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {}\n\n  var prevOutScript\n  var prevOutType\n  var scriptType\n  var script\n  var redeemScript\n  var witnessScript\n  var witnessScriptType\n  var redeemScriptType\n  var witness = false\n  var p2wsh = false\n  var p2sh = false\n  var witnessProgram\n  var chunks\n\n  var scriptSigChunks = bscript.decompile(scriptSig)\n  var sigType = btemplates.classifyInput(scriptSigChunks, true)\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1]\n    redeemScriptType = btemplates.classifyOutput(redeemScript)\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript))\n    prevOutType = scriptTypes.P2SH\n    script = redeemScript\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true)\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1]\n    witnessScriptType = btemplates.classifyOutput(witnessScript)\n    p2wsh = true\n    witness = true\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript))\n      prevOutType = scriptTypes.P2WSH\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary')\n      }\n      // bare witness\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty')\n      }\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript))\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript')\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script')\n    }\n\n    script = witnessScript\n    scriptType = witnessScriptType\n    chunks = witnessStack.slice(0, -1)\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true\n    var key = witnessStack[witnessStack.length - 1]\n    var keyHash = bcrypto.hash160(key)\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash)\n      prevOutType = scriptTypes.P2WPKH\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary')\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty')\n      }\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash)\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program')\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH\n    chunks = witnessStack\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!')\n    }\n\n    script = redeemScript\n    scriptType = redeemScriptType\n    chunks = scriptSigChunks.slice(0, -1)\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig)\n    chunks = scriptSigChunks\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script)\n\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  }\n\n  if (p2sh) {\n    result.redeemScript = redeemScript\n    result.redeemScriptType = redeemScriptType\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript\n    result.witnessScriptType = witnessScriptType\n  }\n\n  return result\n}\n\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder (input, transaction, vin, value, network) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return\n  if (input.pubKeys.length === input.signatures.length) return\n\n  network = network || networks.bitcoin\n  var unmatched = input.signatures.concat()\n\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey)\n    var match\n\n    // check for a signature\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false\n\n      // TODO: avoid O(n) hashForSignature\n      var parsed = ECSignature.parseScriptSignature(signature)\n      var hash\n      switch (network.coin) {\n        case coins.BSV:\n        case coins.BCH:\n          hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType)\n          break\n        case coins.BTG:\n          hash = transaction.hashForGoldSignature(vin, input.signScript, value, parsed.hashType)\n          break\n        case coins.ZEC:\n          if (value === undefined) {\n            return false\n          }\n          hash = transaction.hashForZcashSignature(vin, input.signScript, value, parsed.hashType)\n          break\n        default:\n          if (input.witness) {\n            hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType)\n          } else {\n            hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType)\n          }\n          break\n      }\n\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false\n\n      // remove matched signature from unmatched\n      unmatched[i] = undefined\n      match = signature\n\n      return true\n    })\n\n    return match\n  })\n}\n\nfunction expandOutput (script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script)\n\n  var scriptChunks = bscript.decompile(script)\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script)\n  }\n\n  var pubKeys = []\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break\n\n      var pkh1 = scriptChunks[2]\n      var pkh2 = bcrypto.hash160(ourPubKey)\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey]\n      break\n\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break\n\n      var wpkh1 = scriptChunks[1]\n      var wpkh2 = bcrypto.hash160(ourPubKey)\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey]\n      break\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1)\n      break\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2)\n      break\n\n    default: return { scriptType: scriptType }\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () { return undefined })\n  }\n}\n\nfunction checkP2SHInput (input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH')\n\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1]\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)')\n  }\n}\n\nfunction checkP2WSHInput (input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH')\n\n    var scriptHash = bscript.decompile(input.prevOutScript)[1]\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)')\n  }\n}\n\nfunction prepareInput (input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded\n  var prevOutType\n  var prevOutScript\n\n  var p2sh = false\n  var p2shType\n  var redeemScriptHash\n\n  var witness = false\n  var p2wsh = false\n  var witnessType\n  var witnessScriptHash\n\n  var signType\n  var signScript\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript)\n    witnessScriptHash = bcrypto.sha256(witnessScript)\n    checkP2SHInput(input, redeemScriptHash)\n\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script')\n\n    expanded = expandOutput(witnessScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2SH\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash)\n    p2sh = witness = p2wsh = true\n    p2shType = btemplates.types.P2WSH\n    signType = witnessType = expanded.scriptType\n    signScript = witnessScript\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript)\n    checkP2SHInput(input, redeemScriptHash)\n\n    expanded = expandOutput(redeemScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2SH\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash)\n    p2sh = true\n    signType = p2shType = expanded.scriptType\n    signScript = redeemScript\n    witness = signType === btemplates.types.P2WPKH\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript)\n    checkP2WSHInput(input, witnessScriptHash)\n\n    expanded = expandOutput(witnessScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2WSH\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash)\n    witness = p2wsh = true\n    signType = witnessType = expanded.scriptType\n    signScript = witnessScript\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH ||\n      input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript')\n    }\n\n    prevOutType = input.prevOutType\n    prevOutScript = input.prevOutScript\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey)\n    if (!expanded.pubKeys) return\n\n    witness = (input.prevOutType === scriptTypes.P2WPKH)\n    signType = prevOutType\n    signScript = prevOutScript\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey))\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey)\n\n    prevOutType = scriptTypes.P2PKH\n    witness = false\n    signType = prevOutType\n    signScript = prevOutScript\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript))\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript\n    input.redeemScriptType = p2shType\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript\n    input.witnessScriptType = witnessType\n  }\n\n  input.pubKeys = expanded.pubKeys\n  input.signatures = expanded.signatures\n  input.signScript = signScript\n  input.signType = signType\n  input.prevOutScript = prevOutScript\n  input.prevOutType = prevOutType\n  input.witness = witness\n}\n\nfunction buildStack (type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0])\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0])\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0\n      })\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) { return x !== ops.OP_0 })\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures)\n    }\n  } else {\n    throw new Error('Not yet supported')\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided')\n  return []\n}\n\nfunction buildInput (input, allowIncomplete) {\n  var scriptType = input.prevOutType\n  var sig = []\n  var witness = []\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete)\n  }\n\n  var p2sh = false\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type')\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete)\n    }\n\n    // If it wasn't SIGNABLE, it's witness, defer to that\n    if (input.redeemScriptType) {\n      p2sh = true\n      scriptType = input.redeemScriptType\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete)\n      break\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type')\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete)\n        witness.push(input.witnessScript)\n        scriptType = input.witnessScriptType\n      }\n      break\n  }\n\n  // append redeemScript if necessary\n  if (p2sh) {\n    sig.push(input.redeemScript)\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  }\n}\n\n// By default, assume is a bitcoin transaction\nfunction TransactionBuilder (network, maximumFeeRate) {\n  this.prevTxMap = {}\n  this.network = network || networks.bitcoin\n\n  // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n  this.maximumFeeRate = maximumFeeRate || 2500\n\n  this.inputs = []\n  this.tx = new Transaction(this.network)\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime)\n\n  // if any signatures exist, throw\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false\n\n    return input.signatures.some(function (s) { return s })\n  })) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  this.tx.locktime = locktime\n}\n\nTransactionBuilder.prototype.setVersion = function (version, overwinter = true) {\n  typeforce(types.UInt32, version)\n\n  if (coins.isZcash(this.network)) {\n    if (!this.network.consensusBranchId.hasOwnProperty(this.tx.version)) {\n      throw new Error('Unsupported Zcash transaction')\n    }\n    this.tx.overwintered = (overwinter ? 1 : 0)\n  }\n  this.tx.version = version\n}\n\nTransactionBuilder.prototype.setVersionGroupId = function (versionGroupId) {\n  if (!(coins.isZcash(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' +\n      this.network.coin + ', version: ' + this.tx.version)\n  }\n  typeforce(types.UInt32, versionGroupId)\n  this.tx.versionGroupId = versionGroupId\n}\n\nTransactionBuilder.prototype.setExpiryHeight = function (expiryHeight) {\n  if (!(coins.isZcash(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' +\n      this.network.coin + ', version: ' + this.tx.version)\n  }\n  typeforce(types.UInt32, expiryHeight)\n  this.tx.expiryHeight = expiryHeight\n}\n\nTransactionBuilder.prototype.setJoinSplits = function (transaction) {\n  if (!(coins.isZcash(this.network) && this.tx.supportsJoinSplits())) {\n    throw new Error('joinsplits can only be set for Zcash starting at version 2. Current network coin: ' +\n      this.network.coin + ', version: ' + this.tx.version)\n  }\n  if (transaction && transaction.joinsplits) {\n    this.tx.joinsplits = transaction.joinsplits.map(function (txJoinsplit) {\n      return {\n        vpubOld: txJoinsplit.vpubOld,\n        vpubNew: txJoinsplit.vpubNew,\n        anchor: txJoinsplit.anchor,\n        nullifiers: txJoinsplit.nullifiers,\n        commitments: txJoinsplit.commitments,\n        ephemeralKey: txJoinsplit.ephemeralKey,\n        randomSeed: txJoinsplit.randomSeed,\n        macs: txJoinsplit.macs,\n        zproof: txJoinsplit.zproof,\n        ciphertexts: txJoinsplit.ciphertexts\n      }\n    })\n\n    this.tx.joinsplitPubkey = transaction.joinsplitPubkey\n    this.tx.joinsplitSig = transaction.joinsplitSig\n    return\n  }\n  throw new Error('Invalid transaction with joinsplits')\n}\n\nTransactionBuilder.fromTransaction = function (transaction, network) {\n  var txbNetwork = network || networks.bitcoin\n  var txb = new TransactionBuilder(txbNetwork)\n\n  if (txb.network.coin !== transaction.network.coin) {\n    throw new Error('This transaction is incompatible with the transaction builder')\n  }\n\n  // Copy transaction fields\n  txb.setVersion(transaction.version, transaction.overwintered)\n  txb.setLockTime(transaction.locktime)\n\n  if (coins.isZcash(txbNetwork)) {\n    // Copy Zcash overwinter fields. Omitted if the transaction builder is not for Zcash.\n    if (txb.tx.isOverwinterCompatible()) {\n      txb.setVersionGroupId(transaction.versionGroupId)\n      txb.setExpiryHeight(transaction.expiryHeight)\n    }\n\n    // We don't support protected transactions but we copy the joinsplits for consistency. However, the transaction\n    // builder will fail when we try to sign one of these transactions\n    if (txb.tx.supportsJoinSplits()) {\n      txb.setJoinSplits(transaction)\n    }\n  }\n\n  // Copy Dash special transaction fields. Omitted if the transaction builder is not for Dash.\n  if (coins.isDash(txbNetwork)) {\n    typeforce(types.UInt16, transaction.type)\n    txb.tx.type = transaction.type\n\n    if (txb.tx.versionSupportsDashSpecialTransactions()) {\n      typeforce(types.Buffer, transaction.extraPayload)\n      txb.tx.extraPayload = transaction.extraPayload\n    }\n  }\n\n  // Copy outputs (done first to avoid signature invalidation)\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value)\n  })\n\n  // Copy inputs\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    })\n  })\n\n  // fix some things not possible through the public API\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, txbNetwork)\n  })\n\n  return txb\n}\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  var value\n\n  // is it a hex string?\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse()\n\n  // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout]\n    prevOutScript = txOut.script\n    value = txOut.value\n\n    txHash = txHash.getHash()\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  })\n}\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported')\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut)\n\n  var input = {}\n\n  // derive what we can from the scriptSig\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || [])\n  }\n\n  // if an input value was given, retain it\n  if (options.value !== undefined) {\n    input.value = options.value\n  }\n\n  // derive what we can from the previous transactions output script\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript)\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys\n        input.signatures = expanded.signatures\n      }\n\n      prevOutType = expanded.scriptType\n    }\n\n    input.prevOutScript = options.prevOutScript\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript)\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig)\n  this.inputs[vin] = input\n  this.prevTxMap[prevTxOut] = vin\n  return vin\n}\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  // Attempt to get a script if it's a base58 address string\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network)\n  }\n\n  return this.tx.addOutput(scriptPubKey, value)\n}\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false)\n}\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true)\n}\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs')\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs')\n  }\n\n  var tx = this.tx.clone()\n  // Create script signatures from inputs\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete')\n    var result = buildInput(input, allowIncomplete)\n\n    // skip if no result\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported')\n      }\n    }\n\n    tx.setInputScript(i, result.script)\n    tx.setWitness(i, result.witness)\n  })\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees')\n    }\n  }\n\n  return tx\n}\n\nfunction canSign (input) {\n  return input.prevOutScript !== undefined &&\n    input.signScript !== undefined &&\n    input.pubKeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubKeys.length &&\n    input.pubKeys.length > 0 &&\n    (\n      input.witness === false ||\n      (input.witness === true && input.value !== undefined)\n    )\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n  debug('Signing transaction: (input: %d, hashType: %d, witnessVal: %s, witnessScript: %j)', vin, hashType, witnessValue, witnessScript)\n  debug('Transaction Builder network: %j', this.network)\n\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== this.network) throw new TypeError('Inconsistent network')\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin)\n  hashType = hashType || Transaction.SIGHASH_ALL\n\n  var input = this.inputs[vin]\n\n  // if redeemScript was previously provided, enforce consistency\n  if (input.redeemScript !== undefined &&\n      redeemScript &&\n      !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript')\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer()\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue')\n      typeforce(types.Satoshi, witnessValue)\n      input.value = witnessValue\n    }\n\n    debug('Preparing input %d for signing', vin)\n\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript)\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported')\n  }\n\n  // ready to sign\n  var signatureHash\n  if (coins.isBitcoinGold(this.network)) {\n    signatureHash = this.tx.hashForGoldSignature(vin, input.signScript, witnessValue, hashType, input.witness)\n    debug('Calculated BTG sighash (%s)', signatureHash.toString('hex'))\n  } else if (coins.isBitcoinCash(this.network) || coins.isBitcoinSV(this.network)) {\n    signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n    debug('Calculated BCH sighash (%s)', signatureHash.toString('hex'))\n  } else if (coins.isZcash(this.network)) {\n    signatureHash = this.tx.hashForZcashSignature(vin, input.signScript, witnessValue, hashType)\n    debug('Calculated ZEC sighash (%s)', signatureHash.toString('hex'))\n  } else {\n    if (input.witness) {\n      signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType)\n      debug('Calculated witnessv0 sighash (%s)', signatureHash.toString('hex'))\n    } else {\n      signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType)\n      debug('Calculated sighash (%s)', signatureHash.toString('hex'))\n    }\n  }\n\n  // enforce in order signing of public keys\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false\n    if (input.signatures[i]) throw new Error('Signature already exists')\n    if (kpPubKey.length !== 33 &&\n      input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH')\n\n    var signature = keyPair.sign(signatureHash)\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature)\n\n    debug('Produced signature (r: %s, s: %s)', signature.r, signature.s)\n\n    input.signatures[i] = signature.toScriptSignature(hashType)\n    return true\n  })\n\n  if (!signed) throw new Error('Key pair cannot sign for this input')\n}\n\nfunction signatureHashType (buffer) {\n  return buffer.readUInt8(buffer.length - 1)\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      var hashType = signatureHashType(signature)\n\n      // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n      return hashType & Transaction.SIGHASH_ANYONECANPAY\n    })\n  })\n}\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length\n  var nOutputs = this.tx.outs.length\n\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      var hashType = signatureHashType(signature)\n\n      var hashTypeMod = hashType & 0x1f\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs\n      }\n    })\n  })\n}\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) { return a + (x.value >>> 0) }, 0)\n\n  // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n  var outgoing = this.tx.outs.reduce(function (a, x) { return a + x.value }, 0)\n  var fee = incoming - outgoing\n  var feeRate = fee / bytes\n\n  return feeRate > this.maximumFeeRate\n}\n\nmodule.exports = TransactionBuilder\n"]},"metadata":{},"sourceType":"script"}