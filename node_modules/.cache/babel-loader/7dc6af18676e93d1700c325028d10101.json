{"ast":null,"code":"import { Asset, RenContract, RenTokens } from \"@renproject/interfaces\";\nimport BigNumber from \"bignumber.js\";\nimport { keccak256 } from \"ethereumjs-util\";\nimport { sha3 } from \"web3-utils\";\nimport { Ox, randomBytes, strip0x, toBase64, unzip } from \"./common\";\nimport { rawEncode } from \"./ethereumUtils\"; // export const generateNHash = (tx: Tx): string => {\n//     const encoded = rawEncode(\n//         [\"bytes32\", \"bytes32\"],\n//         [Ox(tx.hash), Ox(tx.args.n)],\n//     );\n//     return Ox(keccak256(encoded));\n// };\n\n/**\n * Hash the payloads associated with a RenVM cross-chain transaction.\n *\n * @param zip An array (or spread) of parameters with with types defined.\n */\n\nexport const generatePHash = (zip, logger) => {\n  // Check if they called as hashPayload([...]) instead of hashPayload(...)\n  const args = Array.isArray(zip[0]) ? zip[0] : zip; // tslint:disable-line: no-any\n\n  const [types, values] = unzip(args);\n  const message = rawEncode(types, values);\n  const digest = Ox(keccak256(message));\n  if (logger) logger.debug(`pHash: ${digest}: keccak256(${message.toString(\"hex\")})`);\n  return digest; // sha3 can accept a Buffer\n};\nconst renContractRegex = /^(.*)0(.*)2(.*)$/;\nconst defaultMatch = [undefined, undefined, undefined, undefined];\n/**\n * parseRenContract splits a RenVM contract (e.g. `BTC0Eth2Btc`) into the asset\n * (`BTC`), the origin chain (`Eth`) and the target chain (`Btc`).\n */\n\nexport const parseRenContract = renContract => {\n  // re.exec(\"BTC0Eth2Btc\") => ['BTC0Eth2Btc', 'BTC', 'Eth', 'Btc']\n  const [, asset, from, to] = renContractRegex.exec(renContract) || defaultMatch;\n\n  if (!asset || !from || !to) {\n    throw new Error(`Invalid Ren Contract \"${renContract}\"`);\n  }\n\n  return {\n    asset: asset,\n    from: from,\n    to: to\n  };\n};\nexport const getTokenName = tokenOrContract => {\n  switch (tokenOrContract) {\n    case RenTokens.BTC:\n    case RenTokens.ZEC:\n    case RenTokens.BCH:\n      return tokenOrContract;\n\n    case Asset.BTC:\n    case \"BTC\":\n      return RenTokens.BTC;\n\n    case Asset.ZEC:\n    case \"ZEC\":\n      return RenTokens.ZEC;\n\n    case Asset.BCH:\n    case \"BCH\":\n      return RenTokens.BCH;\n\n    case Asset.ETH:\n      throw new Error(`Unexpected token ${tokenOrContract}`);\n\n    default:\n      return getTokenName(parseRenContract(tokenOrContract).asset);\n  }\n};\nexport const syncGetTokenAddress = (renContract, network) => {\n  switch (parseRenContract(renContract).asset) {\n    case Asset.BTC:\n      return network.addresses.gateways.RenBTC._address;\n\n    case Asset.ZEC:\n      return network.addresses.gateways.RenZEC._address;\n\n    case Asset.BCH:\n      return network.addresses.gateways.RenBCH._address;\n\n    default:\n      throw new Error(`Invalid Ren Contract ${renContract}`);\n  }\n};\nexport const generateGHash = (payload,\n/* amount: number | string, */\nto, renContract, nonce, network, logger) => {\n  const token = syncGetTokenAddress(renContract, network);\n  const pHash = generatePHash(payload, logger);\n  const encoded = rawEncode([\"bytes32\",\n  /*\"uint256\",*/\n  \"address\", \"address\", \"bytes32\"], [Ox(pHash),\n  /*amount,*/\n  Ox(token), Ox(to), Ox(nonce)]);\n  const digest = Ox(keccak256(encoded));\n  if (logger) logger.debug(`gHash: ${digest}: keccak256(${encoded.toString(\"hex\")})`);\n  return digest;\n};\nexport const generateSighash = (pHash, amount, to, renContract, nonceHash, network, logger) => {\n  const token = syncGetTokenAddress(renContract, network);\n  const encoded = rawEncode([\"bytes32\", \"uint256\", \"address\", \"address\", \"bytes32\"], [Ox(pHash), amount, token, to, nonceHash]);\n  const digest = Ox(keccak256(encoded));\n  if (logger) logger.debug(`sigHash: ${digest}: keccak256(${encoded.toString(\"hex\")})`);\n  return digest;\n};\nexport const txHashToBase64 = txHash => {\n  if (Buffer.isBuffer(txHash)) {\n    return txHash.toString(\"base64\");\n  } // Check if it's hex-encoded\n\n\n  if (txHash.match(/^(0x)?[0-9a-fA-Z]{64}$/)) {\n    return Buffer.from(strip0x(txHash), \"hex\").toString(\"base64\");\n  }\n\n  return txHash;\n};\nexport const generateMintTxHash = (renContract, encodedID, utxo, logger) => {\n  const message = `txHash_${renContract}_${encodedID}_${toBase64(utxo.txHash)}_${utxo.vOut}`;\n  const digest = txHashToBase64(keccak256(Buffer.from(message)));\n  if (logger) logger.debug(`Mint txHash: ${digest}: keccak256(${message})`);\n  return digest;\n};\nexport const generateBurnTxHash = (renContract, encodedID, logger) => {\n  const message = `txHash_${renContract}_${encodedID}`;\n  const digest = txHashToBase64(keccak256(Buffer.from(message)));\n  if (logger) logger.debug(`[RenJS] Burn txHash: ${digest}: keccak256(${message})`);\n  return digest;\n};\nexport const signatureToString = sig => Ox(`${strip0x(sig.r)}${sig.s}${sig.v.toString(16)}`);\n\nconst switchV = v => v === 27 ? 28 : 27; // 28 - (v - 27);\n\n\nconst secp256k1n = new BigNumber(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", 16);\nexport const fixSignature = (response, network, logger) => {\n  if (!response.out) {\n    throw new Error(`Expected transaction response to have signature`);\n  }\n\n  const expectedSighash = generateSighash(response.autogen.phash, response.autogen.amount, response.in.to, response.to, response.autogen.nhash, network, logger);\n\n  if (Ox(response.autogen.sighash) !== Ox(expectedSighash)) {\n    if (logger) logger.warn(`Warning: RenVM returned invalid signature hash. Expected ${expectedSighash} but for ${response.autogen.sighash}`);\n  }\n\n  const r = response.out.r;\n  let s = new BigNumber(strip0x(response.out.s), 16);\n  let v = new BigNumber(strip0x(response.out.v) || \"0\", 16).toNumber() + 27 || 27; // For a given key, there are two valid signatures for each signed message.\n  // We always take the one with the lower `s`.\n  // secp256k1n/2 = 57896044618658097711785492504343953926418782139537452191302581570759080747168.5\n\n  if (s.gt(secp256k1n.div(2))) {\n    // Take s = -s % secp256k1n\n    s = secp256k1n.minus(s); // Switch v\n\n    v = switchV(v);\n  } // TODO: Fix code below to check against proper mintAuthority\n  // // Currently, the wrong `v` value may be returned from RenVM. We recover the\n  // // address to see if we need to switch `v`. This can be removed once RenVM\n  // // has been updated.\n  // const recovered = {\n  //     [v]: pubToAddress(ecrecover(\n  //         Buffer.from(strip0x(response.autogen.sighash), \"hex\"),\n  //         v,\n  //         Buffer.from(strip0x(r), \"hex\"),\n  //         s.toArrayLike(Buffer, \"be\", 32),\n  //     )),\n  //     [switchV(v)]: pubToAddress(ecrecover(\n  //         Buffer.from(strip0x(response.autogen.sighash), \"hex\"),\n  //         switchV(v),\n  //         Buffer.from(strip0x(r), \"hex\"),\n  //         s.toArrayLike(Buffer, \"be\", 32),\n  //     )),\n  // };\n  // const expected = Buffer.from(strip0x(.network.renVM.mintAuthority), \"hex\");\n  // if (recovered[v].equals(expected)) {\n  //     // Do nothing\n  // } else if (recovered[switchV(v)].equals(expected)) {\n  //     // tslint:disable-next-line: no-console\n  //     console.info(\"[info][ren-js] switching v value\");\n  //     v = switchV(v);\n  // } else {\n  //     throw new Error(`Invalid signature - unable to recover mint authority from signature (Expected ${Ox(expected)}, got ${Ox(recovered[v])})`);\n  // }\n\n\n  const to32Bytes = bn => (\"0\".repeat(64) + bn.toString(16)).slice(-64);\n\n  const signature = {\n    r,\n    s: to32Bytes(s),\n    v\n  };\n  return signature;\n};\nexport const getTokenAddress = async (network, web3, tokenOrContract) => {\n  try {\n    const registry = new web3.eth.Contract(network.addresses.gateways.GatewayRegistry.abi, network.addresses.gateways.GatewayRegistry.address);\n    return await registry.methods.getTokenBySymbol(getTokenName(tokenOrContract)).call();\n  } catch (error) {\n    (error || {}).error = `Error looking up ${tokenOrContract} token address: ${error.message}`;\n    throw error;\n  }\n};\nexport const getGatewayAddress = async (network, web3, tokenOrContract) => {\n  try {\n    const registry = new web3.eth.Contract(network.addresses.gateways.GatewayRegistry.abi, network.addresses.gateways.GatewayRegistry.address);\n    return await registry.methods.getGatewayBySymbol(getTokenName(tokenOrContract)).call();\n  } catch (error) {\n    (error || {}).error = `Error looking up ${tokenOrContract}Gateway address: ${error.message}`;\n    throw error;\n  }\n};\nexport const findTransactionBySigHash = async (network, web3, tokenOrContract, sigHash, logger) => {\n  try {\n    const gatewayAddress = await getGatewayAddress(network, web3, tokenOrContract);\n    const gatewayContract = new web3.eth.Contract(network.addresses.gateways.BTCGateway.abi, gatewayAddress); // We can skip the `status` check and call `getPastLogs` directly - for now both are called in case\n    // the contract\n\n    const status = await gatewayContract.methods.status(sigHash).call();\n\n    if (status) {\n      const recentRegistrationEvents = await web3.eth.getPastLogs({\n        address: gatewayAddress,\n        fromBlock: \"1\",\n        toBlock: \"latest\",\n        // topics: [sha3(\"LogDarknodeRegistered(address,uint256)\"), \"0x000000000000000000000000\" +\n        // address.slice(2), null, null] as any,\n        topics: [sha3(\"LogMint(address,uint256,uint256,bytes32)\"), null, null, sigHash]\n      });\n\n      if (!recentRegistrationEvents.length) {\n        throw new Error(`Mint has been submitted but no log was found.`);\n      }\n\n      const log = recentRegistrationEvents[0];\n      return log.transactionHash;\n    }\n  } catch (error) {\n    // tslint:disable-next-line: no-console\n    if (logger) logger.error(error); // Continue with transaction\n  }\n\n  return;\n};\n/**\n * Returns a random 32 byte hex string (prefixed with '0x').\n */\n\nexport const randomNonce = () => randomBytes(32);\nexport const resolveInToken = sendToken => {\n  switch (sendToken) {\n    case \"BTC\":\n      return RenContract.Btc2Eth;\n\n    case \"BCH\":\n      return RenContract.Bch2Eth;\n\n    case \"ZEC\":\n      return RenContract.Zec2Eth;\n\n    default:\n      return sendToken;\n  }\n};\nexport const resolveOutToken = sendToken => {\n  switch (sendToken) {\n    case \"BTC\":\n      return RenContract.Eth2Btc;\n\n    case \"BCH\":\n      return RenContract.Eth2Bch;\n\n    case \"ZEC\":\n      return RenContract.Eth2Zec;\n\n    default:\n      return sendToken;\n  }\n};\nexport const resolveSendTo = ({\n  isMint\n}) => params => {\n  params.sendToken = isMint ? resolveInToken(params.sendToken) : resolveOutToken(params.sendToken);\n  return params;\n};","map":{"version":3,"sources":["../../src/renVMUtils.ts"],"names":[],"mappings":"AACA,SACI,KADJ,EAC4E,WAD5E,EACyF,SADzF,QAGO,wBAHP;AAIA,OAAO,SAAP,MAAsB,cAAtB;AACA,SAAS,SAAT,QAA0B,iBAA1B;AAEA,SAAS,IAAT,QAAqB,YAArB;AAEA,SAAe,EAAf,EAAmB,WAAnB,EAAgC,OAAhC,EAAyC,QAAzC,EAAmD,KAAnD,QAAgE,UAAhE;AACA,SAAS,SAAT,QAA0B,iBAA1B,C,CAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;;;;;AAKA,OAAO,MAAM,aAAa,GAAG,CAAC,GAAD,EAAe,MAAf,KAA0C;AACnE;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,OAAN,CAAc,GAAG,CAAC,CAAD,CAAjB,IAAwB,GAAG,CAAC,CAAD,CAA3B,GAAmD,GAAhE,CAFmE,CAEE;;AAErE,QAAM,CAAC,KAAD,EAAQ,MAAR,IAAkB,KAAK,CAAC,IAAD,CAA7B;AAEA,QAAM,OAAO,GAAG,SAAS,CAAC,KAAD,EAAQ,MAAR,CAAzB;AACA,QAAM,MAAM,GAAG,EAAE,CAAC,SAAS,CAAC,OAAD,CAAV,CAAjB;AAEA,MAAI,MAAJ,EAAY,MAAM,CAAC,KAAP,CAAa,UAAU,MAAM,eAAe,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,GAAnE;AAEZ,SAAO,MAAP,CAXmE,CAWpD;AAClB,CAZM;AAoBP,MAAM,gBAAgB,GAAG,kBAAzB;AACA,MAAM,YAAY,GAAG,CAAC,SAAD,EAAY,SAAZ,EAAuB,SAAvB,EAAkC,SAAlC,CAArB;AAEA;;;;;AAIA,OAAO,MAAM,gBAAgB,GAAI,WAAD,IAAiD;AAC7E;AACA,QAAM,GAAG,KAAH,EAAU,IAAV,EAAgB,EAAhB,IAAsB,gBAAgB,CAAC,IAAjB,CAAsB,WAAtB,KAAsC,YAAlE;;AACA,MAAI,CAAC,KAAD,IAAU,CAAC,IAAX,IAAmB,CAAC,EAAxB,EAA4B;AACxB,UAAM,IAAI,KAAJ,CAAU,yBAAyB,WAAW,GAA9C,CAAN;AACH;;AAED,SAAO;AACH,IAAA,KAAK,EAAE,KADJ;AAEH,IAAA,IAAI,EAAE,IAFH;AAGH,IAAA,EAAE,EAAE;AAHD,GAAP;AAKH,CAZM;AAcP,OAAO,MAAM,YAAY,GAAI,eAAD,IAA0F;AAClH,UAAQ,eAAR;AACI,SAAK,SAAS,CAAC,GAAf;AAAoB,SAAK,SAAS,CAAC,GAAf;AAAoB,SAAK,SAAS,CAAC,GAAf;AAAoB,aAAO,eAAP;;AAC5D,SAAK,KAAK,CAAC,GAAX;AAAgB,SAAK,KAAL;AAAY,aAAO,SAAS,CAAC,GAAjB;;AAC5B,SAAK,KAAK,CAAC,GAAX;AAAgB,SAAK,KAAL;AAAY,aAAO,SAAS,CAAC,GAAjB;;AAC5B,SAAK,KAAK,CAAC,GAAX;AAAgB,SAAK,KAAL;AAAY,aAAO,SAAS,CAAC,GAAjB;;AAC5B,SAAK,KAAK,CAAC,GAAX;AAAgB,YAAM,IAAI,KAAJ,CAAU,oBAAoB,eAAe,EAA7C,CAAN;;AAChB;AACI,aAAO,YAAY,CAAC,gBAAgB,CAAC,eAAD,CAAhB,CAAkC,KAAnC,CAAnB;AAPR;AASH,CAVM;AAYP,OAAO,MAAM,mBAAmB,GAAG,CAAC,WAAD,EAA2B,OAA3B,KAAiE;AAChG,UAAQ,gBAAgB,CAAC,WAAD,CAAhB,CAA8B,KAAtC;AACI,SAAK,KAAK,CAAC,GAAX;AACI,aAAO,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,MAA3B,CAAkC,QAAzC;;AACJ,SAAK,KAAK,CAAC,GAAX;AACI,aAAO,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,MAA3B,CAAkC,QAAzC;;AACJ,SAAK,KAAK,CAAC,GAAX;AACI,aAAO,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,MAA3B,CAAkC,QAAzC;;AACJ;AACI,YAAM,IAAI,KAAJ,CAAU,wBAAwB,WAAW,EAA7C,CAAN;AARR;AAUH,CAXM;AAaP,OAAO,MAAM,aAAa,GAAG,CAAC,OAAD;AAAmB;AAA+B,EAAlD,EAA8D,WAA9D,EAAwF,KAAxF,EAAuG,OAAvG,EAAmI,MAAnI,KAA8J;AACvL,QAAM,KAAK,GAAG,mBAAmB,CAAC,WAAD,EAAc,OAAd,CAAjC;AACA,QAAM,KAAK,GAAG,aAAa,CAAC,OAAD,EAAU,MAAV,CAA3B;AAEA,QAAM,OAAO,GAAG,SAAS,CACrB,CAAC,SAAD;AAAY;AAAe,WAA3B,EAAsC,SAAtC,EAAiD,SAAjD,CADqB,EAErB,CAAC,EAAE,CAAC,KAAD,CAAH;AAAY;AAAY,EAAA,EAAE,CAAC,KAAD,CAA1B,EAAmC,EAAE,CAAC,EAAD,CAArC,EAA2C,EAAE,CAAC,KAAD,CAA7C,CAFqB,CAAzB;AAKA,QAAM,MAAM,GAAG,EAAE,CAAC,SAAS,CAAC,OAAD,CAAV,CAAjB;AAEA,MAAI,MAAJ,EAAY,MAAM,CAAC,KAAP,CAAa,UAAU,MAAM,eAAe,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,GAAnE;AAEZ,SAAO,MAAP;AACH,CAdM;AAgBP,OAAO,MAAM,eAAe,GAAG,CAAC,KAAD,EAAgB,MAAhB,EAAyC,EAAzC,EAAqD,WAArD,EAA+E,SAA/E,EAAkG,OAAlG,EAA8H,MAA9H,KAAyJ;AACpL,QAAM,KAAK,GAAG,mBAAmB,CAAC,WAAD,EAAc,OAAd,CAAjC;AAEA,QAAM,OAAO,GAAG,SAAS,CACrB,CAAC,SAAD,EAAY,SAAZ,EAAuB,SAAvB,EAAkC,SAAlC,EAA6C,SAA7C,CADqB,EAErB,CAAC,EAAE,CAAC,KAAD,CAAH,EAAY,MAAZ,EAAoB,KAApB,EAA2B,EAA3B,EAA+B,SAA/B,CAFqB,CAAzB;AAKA,QAAM,MAAM,GAAG,EAAE,CAAC,SAAS,CAAC,OAAD,CAAV,CAAjB;AAEA,MAAI,MAAJ,EAAY,MAAM,CAAC,KAAP,CAAa,YAAY,MAAM,eAAe,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAuB,GAArE;AAEZ,SAAO,MAAP;AACH,CAbM;AAeP,OAAO,MAAM,cAAc,GAAI,MAAD,IAA4B;AACtD,MAAI,MAAM,CAAC,QAAP,CAAgB,MAAhB,CAAJ,EAA6B;AACzB,WAAO,MAAM,CAAC,QAAP,CAAgB,QAAhB,CAAP;AACH,GAHqD,CAKtD;;;AACA,MAAI,MAAM,CAAC,KAAP,CAAa,wBAAb,CAAJ,EAA4C;AACxC,WAAO,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,MAAD,CAAnB,EAA6B,KAA7B,EAAoC,QAApC,CAA6C,QAA7C,CAAP;AACH;;AACD,SAAO,MAAP;AACH,CAVM;AAYP,OAAO,MAAM,kBAAkB,GAAG,CAAC,WAAD,EAA2B,SAA3B,EAA8C,IAA9C,EAA+D,MAA/D,KAAkF;AAChH,QAAM,OAAO,GAAG,UAAU,WAAW,IAAI,SAAS,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAN,CAAa,IAAI,IAAI,CAAC,IAAI,EAAxF;AACA,QAAM,MAAM,GAAG,cAAc,CAAC,SAAS,CAAC,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAD,CAAV,CAA7B;AACA,MAAI,MAAJ,EAAY,MAAM,CAAC,KAAP,CAAa,gBAAgB,MAAM,eAAe,OAAO,GAAzD;AACZ,SAAO,MAAP;AACH,CALM;AAOP,OAAO,MAAM,kBAAkB,GAAG,CAAC,WAAD,EAA2B,SAA3B,EAA8C,MAA9C,KAAiE;AAC/F,QAAM,OAAO,GAAG,UAAU,WAAW,IAAI,SAAS,EAAlD;AACA,QAAM,MAAM,GAAG,cAAc,CAAC,SAAS,CAAC,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAD,CAAV,CAA7B;AACA,MAAI,MAAJ,EAAY,MAAM,CAAC,KAAP,CAAa,wBAAwB,MAAM,eAAe,OAAO,GAAjE;AACZ,SAAO,MAAP;AACH,CALM;AAkBP,OAAO,MAAM,iBAAiB,GAAyB,GAAtB,IAAyC,EAAE,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAL,CAAO,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,CAAJ,CAAM,QAAN,CAAe,EAAf,CAAkB,EAA/C,CAArE;;AAEP,MAAM,OAAO,GAAI,CAAD,IAAe,CAAC,KAAK,EAAN,GAAW,EAAX,GAAgB,EAA/C,C,CAAmD;;;AAEnD,MAAM,UAAU,GAAG,IAAI,SAAJ,CAAc,kEAAd,EAAkF,EAAlF,CAAnB;AACA,OAAO,MAAM,YAAY,GAAG,CAAC,QAAD,EAA+B,OAA/B,EAA2D,MAA3D,KAAyF;AACjH,MAAI,CAAC,QAAQ,CAAC,GAAd,EAAmB;AACf,UAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACH;;AAED,QAAM,eAAe,GAAG,eAAe,CAAC,QAAQ,CAAC,OAAT,CAAiB,KAAlB,EAAyB,QAAQ,CAAC,OAAT,CAAiB,MAA1C,EAAkD,QAAQ,CAAC,EAAT,CAAY,EAA9D,EAAkE,QAAQ,CAAC,EAA3E,EAA+E,QAAQ,CAAC,OAAT,CAAiB,KAAhG,EAAuG,OAAvG,EAAgH,MAAhH,CAAvC;;AACA,MAAI,EAAE,CAAC,QAAQ,CAAC,OAAT,CAAiB,OAAlB,CAAF,KAAiC,EAAE,CAAC,eAAD,CAAvC,EAA0D;AACtD,QAAI,MAAJ,EAAY,MAAM,CAAC,IAAP,CAAY,4DAA4D,eAAe,YAAY,QAAQ,CAAC,OAAT,CAAiB,OAAO,EAA3H;AACf;;AAED,QAAM,CAAC,GAAG,QAAQ,CAAC,GAAT,CAAa,CAAvB;AACA,MAAI,CAAC,GAAG,IAAI,SAAJ,CAAc,OAAO,CAAC,QAAQ,CAAC,GAAT,CAAa,CAAd,CAArB,EAAuC,EAAvC,CAAR;AACA,MAAI,CAAC,GAAK,IAAI,SAAJ,CAAc,OAAO,CAAC,QAAQ,CAAC,GAAT,CAAa,CAAd,CAAP,IAA2B,GAAzC,EAA8C,EAA9C,EAAkD,QAAlD,KAA+D,EAAhE,IAAuE,EAAhF,CAZiH,CAcjH;AACA;AACA;;AACA,MAAI,CAAC,CAAC,EAAF,CAAK,UAAU,CAAC,GAAX,CAAe,CAAf,CAAL,CAAJ,EAA6B;AACzB;AACA,IAAA,CAAC,GAAG,UAAU,CAAC,KAAX,CAAiB,CAAjB,CAAJ,CAFyB,CAGzB;;AACA,IAAA,CAAC,GAAG,OAAO,CAAC,CAAD,CAAX;AACH,GAtBgH,CAwBjH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,QAAM,SAAS,GAAI,EAAD,IAAmB,CAAC,IAAI,MAAJ,CAAW,EAAX,IAAiB,EAAE,CAAC,QAAH,CAAY,EAAZ,CAAlB,EAAmC,KAAnC,CAAyC,CAAC,EAA1C,CAArC;;AAEA,QAAM,SAAS,GAAc;AACzB,IAAA,CADyB;AAEzB,IAAA,CAAC,EAAE,SAAS,CAAC,CAAD,CAFa;AAGzB,IAAA;AAHyB,GAA7B;AAMA,SAAO,SAAP;AACH,CAjEM;AAmEP,OAAO,MAAM,eAAe,GAAG,OAAO,OAAP,EAAmC,IAAnC,EAA+C,eAA/C,KAA8I;AACzK,MAAI;AACA,UAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAL,CAAS,QAAb,CAAsB,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,eAA3B,CAA2C,GAAjE,EAAsE,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,eAA3B,CAA2C,OAAjH,CAAjB;AACA,WAAO,MAAM,QAAQ,CAAC,OAAT,CAAiB,gBAAjB,CAAkC,YAAY,CAAC,eAAD,CAA9C,EAAiE,IAAjE,EAAb;AACH,GAHD,CAGE,OAAO,KAAP,EAAc;AACZ,KAAC,KAAK,IAAI,EAAV,EAAc,KAAd,GAAsB,oBAAoB,eAAe,mBAAmB,KAAK,CAAC,OAAO,EAAzF;AACA,UAAM,KAAN;AACH;AACJ,CARM;AAUP,OAAO,MAAM,iBAAiB,GAAG,OAAO,OAAP,EAAmC,IAAnC,EAA+C,eAA/C,KAA6H;AAC1J,MAAI;AACA,UAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAL,CAAS,QAAb,CAAsB,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,eAA3B,CAA2C,GAAjE,EAAsE,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,eAA3B,CAA2C,OAAjH,CAAjB;AACA,WAAO,MAAM,QAAQ,CAAC,OAAT,CAAiB,kBAAjB,CAAoC,YAAY,CAAC,eAAD,CAAhD,EAAmE,IAAnE,EAAb;AACH,GAHD,CAGE,OAAO,KAAP,EAAc;AACZ,KAAC,KAAK,IAAI,EAAV,EAAc,KAAd,GAAsB,oBAAoB,eAAe,oBAAoB,KAAK,CAAC,OAAO,EAA1F;AACA,UAAM,KAAN;AACH;AACJ,CARM;AAUP,OAAO,MAAM,wBAAwB,GAAG,OAAO,OAAP,EAAmC,IAAnC,EAA+C,eAA/C,EAA2H,OAA3H,EAA4I,MAA5I,KAA4L;AAChO,MAAI;AACA,UAAM,cAAc,GAAG,MAAM,iBAAiB,CAAC,OAAD,EAAU,IAAV,EAAgB,eAAhB,CAA9C;AACA,UAAM,eAAe,GAAG,IAAI,IAAI,CAAC,GAAL,CAAS,QAAb,CACpB,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,UAA3B,CAAsC,GADlB,EAEpB,cAFoB,CAAxB,CAFA,CAMA;AACA;;AACA,UAAM,MAAM,GAAG,MAAM,eAAe,CAAC,OAAhB,CAAwB,MAAxB,CAA+B,OAA/B,EAAwC,IAAxC,EAArB;;AACA,QAAI,MAAJ,EAAY;AACR,YAAM,wBAAwB,GAAG,MAAM,IAAI,CAAC,GAAL,CAAS,WAAT,CAAqB;AACxD,QAAA,OAAO,EAAE,cAD+C;AAExD,QAAA,SAAS,EAAE,GAF6C;AAGxD,QAAA,OAAO,EAAE,QAH+C;AAIxD;AACA;AACA,QAAA,MAAM,EAAE,CAAC,IAAI,CAAC,0CAAD,CAAL,EAAmD,IAAnD,EAAyD,IAAzD,EAA+D,OAA/D;AANgD,OAArB,CAAvC;;AAQA,UAAI,CAAC,wBAAwB,CAAC,MAA9B,EAAsC;AAClC,cAAM,IAAI,KAAJ,CAAU,+CAAV,CAAN;AACH;;AACD,YAAM,GAAG,GAAG,wBAAwB,CAAC,CAAD,CAApC;AACA,aAAO,GAAG,CAAC,eAAX;AACH;AACJ,GAxBD,CAwBE,OAAO,KAAP,EAAc;AACZ;AACA,QAAI,MAAJ,EAAY,MAAM,CAAC,KAAP,CAAa,KAAb,EAFA,CAGZ;AACH;;AACD;AACH,CA/BM;AAiCP;;;;AAGA,OAAO,MAAM,WAAW,GAAG,MAAM,WAAW,CAAC,EAAD,CAArC;AAEP,OAAO,MAAM,cAAc,GAAI,SAAD,IAA2D;AACrF,UAAQ,SAAR;AACI,SAAK,KAAL;AACI,aAAO,WAAW,CAAC,OAAnB;;AACJ,SAAK,KAAL;AACI,aAAO,WAAW,CAAC,OAAnB;;AACJ,SAAK,KAAL;AACI,aAAO,WAAW,CAAC,OAAnB;;AACJ;AACI,aAAO,SAAP;AARR;AAUH,CAXM;AAaP,OAAO,MAAM,eAAe,GAAI,SAAD,IAA2D;AACtF,UAAQ,SAAR;AACI,SAAK,KAAL;AACI,aAAO,WAAW,CAAC,OAAnB;;AACJ,SAAK,KAAL;AACI,aAAO,WAAW,CAAC,OAAnB;;AACJ,SAAK,KAAL;AACI,aAAO,WAAW,CAAC,OAAnB;;AACJ;AACI,aAAO,SAAP;AARR;AAUH,CAXM;AAaP,OAAO,MAAM,aAAa,GAAG,CAAqD;AAAE,EAAA;AAAF,CAArD,KAA0F,MAAD,IAA6B;AAC/I,EAAA,MAAM,CAAC,SAAP,GAAmB,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC,SAAR,CAAjB,GAAsC,eAAe,CAAC,MAAM,CAAC,SAAR,CAA9E;AACA,SAAO,MAAP;AACH,CAHM","sourceRoot":"","sourcesContent":["import { Asset, RenContract, RenTokens, } from \"@renproject/interfaces\";\nimport BigNumber from \"bignumber.js\";\nimport { keccak256 } from \"ethereumjs-util\";\nimport { sha3 } from \"web3-utils\";\nimport { Ox, randomBytes, strip0x, toBase64, unzip } from \"./common\";\nimport { rawEncode } from \"./ethereumUtils\";\n// export const generateNHash = (tx: Tx): string => {\n//     const encoded = rawEncode(\n//         [\"bytes32\", \"bytes32\"],\n//         [Ox(tx.hash), Ox(tx.args.n)],\n//     );\n//     return Ox(keccak256(encoded));\n// };\n/**\n * Hash the payloads associated with a RenVM cross-chain transaction.\n *\n * @param zip An array (or spread) of parameters with with types defined.\n */\nexport const generatePHash = (zip, logger) => {\n    // Check if they called as hashPayload([...]) instead of hashPayload(...)\n    const args = Array.isArray(zip[0]) ? zip[0] : zip; // tslint:disable-line: no-any\n    const [types, values] = unzip(args);\n    const message = rawEncode(types, values);\n    const digest = Ox(keccak256(message));\n    if (logger)\n        logger.debug(`pHash: ${digest}: keccak256(${message.toString(\"hex\")})`);\n    return digest; // sha3 can accept a Buffer\n};\nconst renContractRegex = /^(.*)0(.*)2(.*)$/;\nconst defaultMatch = [undefined, undefined, undefined, undefined];\n/**\n * parseRenContract splits a RenVM contract (e.g. `BTC0Eth2Btc`) into the asset\n * (`BTC`), the origin chain (`Eth`) and the target chain (`Btc`).\n */\nexport const parseRenContract = (renContract) => {\n    // re.exec(\"BTC0Eth2Btc\") => ['BTC0Eth2Btc', 'BTC', 'Eth', 'Btc']\n    const [, asset, from, to] = renContractRegex.exec(renContract) || defaultMatch;\n    if (!asset || !from || !to) {\n        throw new Error(`Invalid Ren Contract \"${renContract}\"`);\n    }\n    return {\n        asset: asset,\n        from: from,\n        to: to\n    };\n};\nexport const getTokenName = (tokenOrContract) => {\n    switch (tokenOrContract) {\n        case RenTokens.BTC:\n        case RenTokens.ZEC:\n        case RenTokens.BCH: return tokenOrContract;\n        case Asset.BTC:\n        case \"BTC\": return RenTokens.BTC;\n        case Asset.ZEC:\n        case \"ZEC\": return RenTokens.ZEC;\n        case Asset.BCH:\n        case \"BCH\": return RenTokens.BCH;\n        case Asset.ETH: throw new Error(`Unexpected token ${tokenOrContract}`);\n        default:\n            return getTokenName(parseRenContract(tokenOrContract).asset);\n    }\n};\nexport const syncGetTokenAddress = (renContract, network) => {\n    switch (parseRenContract(renContract).asset) {\n        case Asset.BTC:\n            return network.addresses.gateways.RenBTC._address;\n        case Asset.ZEC:\n            return network.addresses.gateways.RenZEC._address;\n        case Asset.BCH:\n            return network.addresses.gateways.RenBCH._address;\n        default:\n            throw new Error(`Invalid Ren Contract ${renContract}`);\n    }\n};\nexport const generateGHash = (payload, /* amount: number | string, */ to, renContract, nonce, network, logger) => {\n    const token = syncGetTokenAddress(renContract, network);\n    const pHash = generatePHash(payload, logger);\n    const encoded = rawEncode([\"bytes32\", /*\"uint256\",*/ \"address\", \"address\", \"bytes32\"], [Ox(pHash), /*amount,*/ Ox(token), Ox(to), Ox(nonce)]);\n    const digest = Ox(keccak256(encoded));\n    if (logger)\n        logger.debug(`gHash: ${digest}: keccak256(${encoded.toString(\"hex\")})`);\n    return digest;\n};\nexport const generateSighash = (pHash, amount, to, renContract, nonceHash, network, logger) => {\n    const token = syncGetTokenAddress(renContract, network);\n    const encoded = rawEncode([\"bytes32\", \"uint256\", \"address\", \"address\", \"bytes32\"], [Ox(pHash), amount, token, to, nonceHash]);\n    const digest = Ox(keccak256(encoded));\n    if (logger)\n        logger.debug(`sigHash: ${digest}: keccak256(${encoded.toString(\"hex\")})`);\n    return digest;\n};\nexport const txHashToBase64 = (txHash) => {\n    if (Buffer.isBuffer(txHash)) {\n        return txHash.toString(\"base64\");\n    }\n    // Check if it's hex-encoded\n    if (txHash.match(/^(0x)?[0-9a-fA-Z]{64}$/)) {\n        return Buffer.from(strip0x(txHash), \"hex\").toString(\"base64\");\n    }\n    return txHash;\n};\nexport const generateMintTxHash = (renContract, encodedID, utxo, logger) => {\n    const message = `txHash_${renContract}_${encodedID}_${toBase64(utxo.txHash)}_${utxo.vOut}`;\n    const digest = txHashToBase64(keccak256(Buffer.from(message)));\n    if (logger)\n        logger.debug(`Mint txHash: ${digest}: keccak256(${message})`);\n    return digest;\n};\nexport const generateBurnTxHash = (renContract, encodedID, logger) => {\n    const message = `txHash_${renContract}_${encodedID}`;\n    const digest = txHashToBase64(keccak256(Buffer.from(message)));\n    if (logger)\n        logger.debug(`[RenJS] Burn txHash: ${digest}: keccak256(${message})`);\n    return digest;\n};\nexport const signatureToString = (sig) => Ox(`${strip0x(sig.r)}${sig.s}${sig.v.toString(16)}`);\nconst switchV = (v) => v === 27 ? 28 : 27; // 28 - (v - 27);\nconst secp256k1n = new BigNumber(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", 16);\nexport const fixSignature = (response, network, logger) => {\n    if (!response.out) {\n        throw new Error(`Expected transaction response to have signature`);\n    }\n    const expectedSighash = generateSighash(response.autogen.phash, response.autogen.amount, response.in.to, response.to, response.autogen.nhash, network, logger);\n    if (Ox(response.autogen.sighash) !== Ox(expectedSighash)) {\n        if (logger)\n            logger.warn(`Warning: RenVM returned invalid signature hash. Expected ${expectedSighash} but for ${response.autogen.sighash}`);\n    }\n    const r = response.out.r;\n    let s = new BigNumber(strip0x(response.out.s), 16);\n    let v = ((new BigNumber(strip0x(response.out.v) || \"0\", 16).toNumber() + 27) || 27);\n    // For a given key, there are two valid signatures for each signed message.\n    // We always take the one with the lower `s`.\n    // secp256k1n/2 = 57896044618658097711785492504343953926418782139537452191302581570759080747168.5\n    if (s.gt(secp256k1n.div(2))) {\n        // Take s = -s % secp256k1n\n        s = secp256k1n.minus(s);\n        // Switch v\n        v = switchV(v);\n    }\n    // TODO: Fix code below to check against proper mintAuthority\n    // // Currently, the wrong `v` value may be returned from RenVM. We recover the\n    // // address to see if we need to switch `v`. This can be removed once RenVM\n    // // has been updated.\n    // const recovered = {\n    //     [v]: pubToAddress(ecrecover(\n    //         Buffer.from(strip0x(response.autogen.sighash), \"hex\"),\n    //         v,\n    //         Buffer.from(strip0x(r), \"hex\"),\n    //         s.toArrayLike(Buffer, \"be\", 32),\n    //     )),\n    //     [switchV(v)]: pubToAddress(ecrecover(\n    //         Buffer.from(strip0x(response.autogen.sighash), \"hex\"),\n    //         switchV(v),\n    //         Buffer.from(strip0x(r), \"hex\"),\n    //         s.toArrayLike(Buffer, \"be\", 32),\n    //     )),\n    // };\n    // const expected = Buffer.from(strip0x(.network.renVM.mintAuthority), \"hex\");\n    // if (recovered[v].equals(expected)) {\n    //     // Do nothing\n    // } else if (recovered[switchV(v)].equals(expected)) {\n    //     // tslint:disable-next-line: no-console\n    //     console.info(\"[info][ren-js] switching v value\");\n    //     v = switchV(v);\n    // } else {\n    //     throw new Error(`Invalid signature - unable to recover mint authority from signature (Expected ${Ox(expected)}, got ${Ox(recovered[v])})`);\n    // }\n    const to32Bytes = (bn) => (\"0\".repeat(64) + bn.toString(16)).slice(-64);\n    const signature = {\n        r,\n        s: to32Bytes(s),\n        v,\n    };\n    return signature;\n};\nexport const getTokenAddress = async (network, web3, tokenOrContract) => {\n    try {\n        const registry = new web3.eth.Contract(network.addresses.gateways.GatewayRegistry.abi, network.addresses.gateways.GatewayRegistry.address);\n        return await registry.methods.getTokenBySymbol(getTokenName(tokenOrContract)).call();\n    }\n    catch (error) {\n        (error || {}).error = `Error looking up ${tokenOrContract} token address: ${error.message}`;\n        throw error;\n    }\n};\nexport const getGatewayAddress = async (network, web3, tokenOrContract) => {\n    try {\n        const registry = new web3.eth.Contract(network.addresses.gateways.GatewayRegistry.abi, network.addresses.gateways.GatewayRegistry.address);\n        return await registry.methods.getGatewayBySymbol(getTokenName(tokenOrContract)).call();\n    }\n    catch (error) {\n        (error || {}).error = `Error looking up ${tokenOrContract}Gateway address: ${error.message}`;\n        throw error;\n    }\n};\nexport const findTransactionBySigHash = async (network, web3, tokenOrContract, sigHash, logger) => {\n    try {\n        const gatewayAddress = await getGatewayAddress(network, web3, tokenOrContract);\n        const gatewayContract = new web3.eth.Contract(network.addresses.gateways.BTCGateway.abi, gatewayAddress);\n        // We can skip the `status` check and call `getPastLogs` directly - for now both are called in case\n        // the contract\n        const status = await gatewayContract.methods.status(sigHash).call();\n        if (status) {\n            const recentRegistrationEvents = await web3.eth.getPastLogs({\n                address: gatewayAddress,\n                fromBlock: \"1\",\n                toBlock: \"latest\",\n                // topics: [sha3(\"LogDarknodeRegistered(address,uint256)\"), \"0x000000000000000000000000\" +\n                // address.slice(2), null, null] as any,\n                topics: [sha3(\"LogMint(address,uint256,uint256,bytes32)\"), null, null, sigHash],\n            });\n            if (!recentRegistrationEvents.length) {\n                throw new Error(`Mint has been submitted but no log was found.`);\n            }\n            const log = recentRegistrationEvents[0];\n            return log.transactionHash;\n        }\n    }\n    catch (error) {\n        // tslint:disable-next-line: no-console\n        if (logger)\n            logger.error(error);\n        // Continue with transaction\n    }\n    return;\n};\n/**\n * Returns a random 32 byte hex string (prefixed with '0x').\n */\nexport const randomNonce = () => randomBytes(32);\nexport const resolveInToken = (sendToken) => {\n    switch (sendToken) {\n        case \"BTC\":\n            return RenContract.Btc2Eth;\n        case \"BCH\":\n            return RenContract.Bch2Eth;\n        case \"ZEC\":\n            return RenContract.Zec2Eth;\n        default:\n            return sendToken;\n    }\n};\nexport const resolveOutToken = (sendToken) => {\n    switch (sendToken) {\n        case \"BTC\":\n            return RenContract.Eth2Btc;\n        case \"BCH\":\n            return RenContract.Eth2Bch;\n        case \"ZEC\":\n            return RenContract.Eth2Zec;\n        default:\n            return sendToken;\n    }\n};\nexport const resolveSendTo = ({ isMint }) => (params) => {\n    params.sendToken = isMint ? resolveInToken(params.sendToken) : resolveOutToken(params.sendToken);\n    return params;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuVk1VdGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZW5WTVV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFDSCxLQUFLLEVBQW1FLFdBQVcsRUFBRSxTQUFTLEdBRWpHLE1BQU0sd0JBQXdCLENBQUM7QUFDaEMsT0FBTyxTQUFTLE1BQU0sY0FBYyxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU1QyxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRWxDLE9BQU8sRUFBUSxFQUFFLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzNFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU1QyxxREFBcUQ7QUFDckQsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEMsU0FBUztBQUVULHFDQUFxQztBQUNyQyxLQUFLO0FBRUw7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUFDLEdBQVksRUFBRSxNQUFlLEVBQVUsRUFBRTtJQUNuRSx5RUFBeUU7SUFDekUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBbUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsOEJBQThCO0lBRW5HLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXBDLE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDekMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBRXRDLElBQUksTUFBTTtRQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxNQUFNLGVBQWUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFcEYsT0FBTyxNQUFNLENBQUMsQ0FBQywyQkFBMkI7QUFDOUMsQ0FBQyxDQUFDO0FBUUYsTUFBTSxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQztBQUM1QyxNQUFNLFlBQVksR0FBRyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBRWxFOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFHLENBQUMsV0FBd0IsRUFBc0IsRUFBRTtJQUM3RSxpRUFBaUU7SUFDakUsTUFBTSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksWUFBWSxDQUFDO0lBQy9FLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsV0FBVyxHQUFHLENBQUMsQ0FBQztLQUM1RDtJQUVELE9BQU87UUFDSCxLQUFLLEVBQUUsS0FBYztRQUNyQixJQUFJLEVBQUUsSUFBYTtRQUNuQixFQUFFLEVBQUUsRUFBVztLQUNsQixDQUFDO0FBQ04sQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLENBQUMsZUFBMEUsRUFBYSxFQUFFO0lBQ2xILFFBQVEsZUFBZSxFQUFFO1FBQ3JCLEtBQUssU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUFDLEtBQUssU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUFDLEtBQUssU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sZUFBNEIsQ0FBQztRQUNoRyxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUNqRCxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUNqRCxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUNqRCxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixlQUFlLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZFO1lBQ0ksT0FBTyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDcEU7QUFDTCxDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLFdBQXdCLEVBQUUsT0FBMEIsRUFBVSxFQUFFO0lBQ2hHLFFBQVEsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxFQUFFO1FBQ3pDLEtBQUssS0FBSyxDQUFDLEdBQUc7WUFDVixPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDdEQsS0FBSyxLQUFLLENBQUMsR0FBRztZQUNWLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUN0RCxLQUFLLEtBQUssQ0FBQyxHQUFHO1lBQ1YsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBQ3REO1lBQ0ksTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsV0FBVyxFQUFFLENBQUMsQ0FBQztLQUM5RDtBQUNMLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQWdCLEVBQUUsOEJBQThCLENBQUMsRUFBVSxFQUFFLFdBQXdCLEVBQUUsS0FBYSxFQUFFLE9BQTBCLEVBQUUsTUFBZSxFQUFVLEVBQUU7SUFDdkwsTUFBTSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3hELE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFN0MsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUNyQixDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsRUFDM0QsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsV0FBVyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3hELENBQUM7SUFFRixNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFFdEMsSUFBSSxNQUFNO1FBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLE1BQU0sZUFBZSxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVwRixPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxLQUFhLEVBQUUsTUFBdUIsRUFBRSxFQUFVLEVBQUUsV0FBd0IsRUFBRSxTQUFpQixFQUFFLE9BQTBCLEVBQUUsTUFBZSxFQUFVLEVBQUU7SUFDcEwsTUFBTSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXhELE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FDckIsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLEVBQ3ZELENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUM1QyxDQUFDO0lBRUYsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBRXRDLElBQUksTUFBTTtRQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxNQUFNLGVBQWUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFdEYsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQUMsTUFBdUIsRUFBRSxFQUFFO0lBQ3RELElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUN6QixPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDcEM7SUFFRCw0QkFBNEI7SUFDNUIsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixDQUFDLEVBQUU7UUFDeEMsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDakU7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLFdBQXdCLEVBQUUsU0FBaUIsRUFBRSxJQUFlLEVBQUUsTUFBZSxFQUFFLEVBQUU7SUFDaEgsTUFBTSxPQUFPLEdBQUcsVUFBVSxXQUFXLElBQUksU0FBUyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzNGLE1BQU0sTUFBTSxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0QsSUFBSSxNQUFNO1FBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsTUFBTSxlQUFlLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDMUUsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxXQUF3QixFQUFFLFNBQWlCLEVBQUUsTUFBZSxFQUFFLEVBQUU7SUFDL0YsTUFBTSxPQUFPLEdBQUcsVUFBVSxXQUFXLElBQUksU0FBUyxFQUFFLENBQUM7SUFDckQsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRCxJQUFJLE1BQU07UUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixNQUFNLGVBQWUsT0FBTyxHQUFHLENBQUMsQ0FBQztJQUNsRixPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUM7QUFhRixNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxDQUFzQixHQUFNLEVBQVUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFFL0gsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsaUJBQWlCO0FBRXBFLE1BQU0sVUFBVSxHQUFHLElBQUksU0FBUyxDQUFDLGtFQUFrRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3pHLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxDQUFDLFFBQTRCLEVBQUUsT0FBMEIsRUFBRSxNQUFlLEVBQWEsRUFBRTtJQUNqSCxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRTtRQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQztLQUN0RTtJQUVELE1BQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMvSixJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRTtRQUN0RCxJQUFJLE1BQU07WUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLDREQUE0RCxlQUFlLFlBQVksUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQzlJO0lBRUQsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDekIsSUFBSSxDQUFDLEdBQUcsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUVwRiwyRUFBMkU7SUFDM0UsNkNBQTZDO0lBQzdDLGlHQUFpRztJQUNqRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3pCLDJCQUEyQjtRQUMzQixDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QixXQUFXO1FBQ1gsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNsQjtJQUVELDZEQUE2RDtJQUU3RCwrRUFBK0U7SUFDL0UsNkVBQTZFO0lBQzdFLHVCQUF1QjtJQUN2QixzQkFBc0I7SUFDdEIsbUNBQW1DO0lBQ25DLGlFQUFpRTtJQUNqRSxhQUFhO0lBQ2IsMENBQTBDO0lBQzFDLDJDQUEyQztJQUMzQyxVQUFVO0lBRVYsNENBQTRDO0lBQzVDLGlFQUFpRTtJQUNqRSxzQkFBc0I7SUFDdEIsMENBQTBDO0lBQzFDLDJDQUEyQztJQUMzQyxVQUFVO0lBQ1YsS0FBSztJQUVMLDhFQUE4RTtJQUM5RSx1Q0FBdUM7SUFDdkMsb0JBQW9CO0lBQ3BCLHVEQUF1RDtJQUN2RCw4Q0FBOEM7SUFDOUMsd0RBQXdEO0lBQ3hELHNCQUFzQjtJQUN0QixXQUFXO0lBQ1gsa0pBQWtKO0lBQ2xKLElBQUk7SUFFSixNQUFNLFNBQVMsR0FBRyxDQUFDLEVBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUVuRixNQUFNLFNBQVMsR0FBYztRQUN6QixDQUFDO1FBQ0QsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDZixDQUFDO0tBQ0osQ0FBQztJQUVGLE9BQU8sU0FBUyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxLQUFLLEVBQUUsT0FBMEIsRUFBRSxJQUFVLEVBQUUsZUFBMEUsRUFBbUIsRUFBRTtJQUN6SyxJQUFJO1FBQ0EsTUFBTSxRQUFRLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzSSxPQUFPLE1BQU0sUUFBUSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUN4RjtJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ1osQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxHQUFHLG9CQUFvQixlQUFlLG1CQUFtQixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDNUYsTUFBTSxLQUFLLENBQUM7S0FDZjtBQUNMLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLEtBQUssRUFBRSxPQUEwQixFQUFFLElBQVUsRUFBRSxlQUEwRSxFQUFFLEVBQUU7SUFDMUosSUFBSTtRQUNBLE1BQU0sUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0ksT0FBTyxNQUFNLFFBQVEsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDMUY7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNaLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssR0FBRyxvQkFBb0IsZUFBZSxvQkFBb0IsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzdGLE1BQU0sS0FBSyxDQUFDO0tBQ2Y7QUFDTCxDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxLQUFLLEVBQUUsT0FBMEIsRUFBRSxJQUFVLEVBQUUsZUFBMEUsRUFBRSxPQUFlLEVBQUUsTUFBZSxFQUErQixFQUFFO0lBQ2hPLElBQUk7UUFDQSxNQUFNLGNBQWMsR0FBRyxNQUFNLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFDL0UsTUFBTSxlQUFlLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FDekMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFDekMsY0FBYyxDQUNqQixDQUFDO1FBQ0YsbUdBQW1HO1FBQ25HLGVBQWU7UUFDZixNQUFNLE1BQU0sR0FBRyxNQUFNLGVBQWUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3BFLElBQUksTUFBTSxFQUFFO1lBQ1IsTUFBTSx3QkFBd0IsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO2dCQUN4RCxPQUFPLEVBQUUsY0FBYztnQkFDdkIsU0FBUyxFQUFFLEdBQUc7Z0JBQ2QsT0FBTyxFQUFFLFFBQVE7Z0JBQ2pCLDBGQUEwRjtnQkFDMUYsd0NBQXdDO2dCQUN4QyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsMENBQTBDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBYTthQUM5RixDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFO2dCQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7YUFDcEU7WUFDRCxNQUFNLEdBQUcsR0FBRyx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QyxPQUFPLEdBQUcsQ0FBQyxlQUFlLENBQUM7U0FDOUI7S0FDSjtJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ1osdUNBQXVDO1FBQ3ZDLElBQUksTUFBTTtZQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEMsNEJBQTRCO0tBQy9CO0lBQ0QsT0FBTztBQUNYLENBQUMsQ0FBQztBQUVGOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUVqRCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxTQUF5QyxFQUFlLEVBQUU7SUFDckYsUUFBUSxTQUFTLEVBQUU7UUFDZixLQUFLLEtBQUs7WUFDTixPQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUM7UUFDL0IsS0FBSyxLQUFLO1lBQ04sT0FBTyxXQUFXLENBQUMsT0FBTyxDQUFDO1FBQy9CLEtBQUssS0FBSztZQUNOLE9BQU8sV0FBVyxDQUFDLE9BQU8sQ0FBQztRQUMvQjtZQUNJLE9BQU8sU0FBUyxDQUFDO0tBQ3hCO0FBQ0wsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLENBQUMsU0FBeUMsRUFBZSxFQUFFO0lBQ3RGLFFBQVEsU0FBUyxFQUFFO1FBQ2YsS0FBSyxLQUFLO1lBQ04sT0FBTyxXQUFXLENBQUMsT0FBTyxDQUFDO1FBQy9CLEtBQUssS0FBSztZQUNOLE9BQU8sV0FBVyxDQUFDLE9BQU8sQ0FBQztRQUMvQixLQUFLLEtBQUs7WUFDTixPQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUM7UUFDL0I7WUFDSSxPQUFPLFNBQVMsQ0FBQztLQUN4QjtBQUNMLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUFxRCxFQUFFLE1BQU0sRUFBdUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFTLEVBQWlCLEVBQUU7SUFDL0ksTUFBTSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakcsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQyxDQUFDIn0="]},"metadata":{},"sourceType":"module"}