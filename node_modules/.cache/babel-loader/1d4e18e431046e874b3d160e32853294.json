{"ast":null,"code":"'use strict';\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\n\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n  var hashPrevouts;\n  var hashSequence;\n  var hashOutputs;\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    var sequenceBuffers = [];\n\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } // Version\n\n\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n  writer.write(hashPrevouts);\n  writer.write(hashSequence); // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n  writer.write(scriptCode);\n  writer.write(satoshisBuffer);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n  writer.write(hashOutputs); // Locktime\n\n  writer.writeUInt32LE(transaction.nLockTime); // Sighash type\n\n  writer.writeInt32LE(sighashType);\n  return Hash.sha256sha256(writer.toBuffer());\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  var sig;\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n    sig = ECDSA.sign(hashbuf, privateKey).set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  signingMethod = signingMethod || 'ecdsa';\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n    return ECDSA.verify(hashbuf, signature, publicKey);\n  }\n\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitcore-lib/lib/transaction/sighashwitness.js"],"names":["Signature","require","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","sighash","transaction","sighashType","inputNumber","scriptCode","satoshisBuffer","hashPrevouts","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","buffers","n","inputs","length","input","prevTxIdBuffer","prevTxId","readReverse","push","outputIndexBuffer","Buffer","alloc","writeUInt32LE","outputIndex","sha256sha256","concat","SIGHASH_SINGLE","SIGHASH_NONE","sequenceBuffers","m","sequenceBuffer","sequenceNumber","outputWriter","p","outputs","toBufferWriter","toBuffer","writer","version","write","outpointId","nLockTime","writeInt32LE","sign","privateKey","inputIndex","signingMethod","sig","hashbuf","set","nhashtype","Error","verify","signature","publicKey","checkArgument","isUndefined","module","exports"],"mappings":"AAAA;AAEA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,0BAAD,CAA1B;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,0BAAD,CAA1B;;AACA,IAAIK,EAAE,GAAGL,OAAO,CAAC,cAAD,CAAhB;;AACA,IAAIM,IAAI,GAAGN,OAAO,CAAC,gBAAD,CAAlB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,iBAAD,CAAnB;;AACA,IAAIQ,CAAC,GAAGR,OAAO,CAAC,uBAAD,CAAf;;AACA,IAAIS,CAAC,GAAGT,OAAO,CAAC,QAAD,CAAf;AAEA;;;;;;;;;;;;;;AAYA,IAAIU,OAAO,GAAG,SAASA,OAAT,CAAiBC,WAAjB,EAA8BC,WAA9B,EAA2CC,WAA3C,EAAwDC,UAAxD,EAAoEC,cAApE,EAAoF;AAChG;AAEA,MAAIC,YAAJ;AACA,MAAIC,YAAJ;AACA,MAAIC,WAAJ;;AAEA,MAAI,EAAEN,WAAW,GAAGb,SAAS,CAACoB,oBAA1B,CAAJ,EAAqD;AACnD,QAAIC,OAAO,GAAG,EAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,WAAW,CAACW,MAAZ,CAAmBC,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AAClD,UAAIG,KAAK,GAAGb,WAAW,CAACW,MAAZ,CAAmBD,CAAnB,CAAZ;AACA,UAAII,cAAc,GAAG,IAAItB,YAAJ,CAAiBqB,KAAK,CAACE,QAAvB,EAAiCC,WAAjC,EAArB;AACAP,MAAAA,OAAO,CAACQ,IAAR,CAAaH,cAAb;AACA,UAAII,iBAAiB,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAxB;AACAF,MAAAA,iBAAiB,CAACG,aAAlB,CAAgCR,KAAK,CAACS,WAAtC,EAAmD,CAAnD;AACAb,MAAAA,OAAO,CAACQ,IAAR,CAAaC,iBAAb;AACD;;AACDb,IAAAA,YAAY,GAAGV,IAAI,CAAC4B,YAAL,CAAkBJ,MAAM,CAACK,MAAP,CAAcf,OAAd,CAAlB,CAAf;AACD;;AAED,MAAI,EAAER,WAAW,GAAGb,SAAS,CAACoB,oBAA1B,KACA,CAACP,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACqC,cADnC,IACqD,CAACxB,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACsC,YAD5F,EAC0G;AAExG,QAAIC,eAAe,GAAG,EAAtB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,WAAW,CAACW,MAAZ,CAAmBC,MAAvC,EAA+CgB,CAAC,EAAhD,EAAoD;AAClD,UAAIC,cAAc,GAAGV,MAAM,CAACC,KAAP,CAAa,CAAb,CAArB;AACAS,MAAAA,cAAc,CAACR,aAAf,CAA6BrB,WAAW,CAACW,MAAZ,CAAmBiB,CAAnB,EAAsBE,cAAnD,EAAmE,CAAnE;AACAH,MAAAA,eAAe,CAACV,IAAhB,CAAqBY,cAArB;AACD;;AACDvB,IAAAA,YAAY,GAAGX,IAAI,CAAC4B,YAAL,CAAkBJ,MAAM,CAACK,MAAP,CAAcG,eAAd,CAAlB,CAAf;AACD;;AAED,MAAII,YAAY,GAAG,IAAItC,YAAJ,EAAnB;;AACA,MAAI,CAACQ,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACqC,cAAnC,IAAqD,CAACxB,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACsC,YAA5F,EAA0G;AACxG,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,WAAW,CAACiC,OAAZ,CAAoBrB,MAAxC,EAAgDoB,CAAC,EAAjD,EAAqD;AACnDhC,MAAAA,WAAW,CAACiC,OAAZ,CAAoBD,CAApB,EAAuBE,cAAvB,CAAsCH,YAAtC;AACD;;AACDxB,IAAAA,WAAW,GAAGZ,IAAI,CAAC4B,YAAL,CAAkBQ,YAAY,CAACI,QAAb,EAAlB,CAAd;AACD,GALD,MAKO,IAAI,CAAClC,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACqC,cAAnC,IAAqDvB,WAAW,GAAGF,WAAW,CAACiC,OAAZ,CAAoBrB,MAA3F,EAAmG;AACxGZ,IAAAA,WAAW,CAACiC,OAAZ,CAAoB/B,WAApB,EAAiCgC,cAAjC,CAAgDH,YAAhD;AACAxB,IAAAA,WAAW,GAAGZ,IAAI,CAAC4B,YAAL,CAAkBQ,YAAY,CAACI,QAAb,EAAlB,CAAd;AACD,GAzC+F,CA2ChG;;;AACA,MAAIC,MAAM,GAAG,IAAI3C,YAAJ,EAAb;AACA2C,EAAAA,MAAM,CAACf,aAAP,CAAqBrB,WAAW,CAACqC,OAAjC,EA7CgG,CA+ChG;;AACAD,EAAAA,MAAM,CAACE,KAAP,CAAajC,YAAb;AACA+B,EAAAA,MAAM,CAACE,KAAP,CAAahC,YAAb,EAjDgG,CAmDhG;AACA;AACA;;AACA,MAAIiC,UAAU,GAAG,IAAI/C,YAAJ,CAAiBQ,WAAW,CAACW,MAAZ,CAAmBT,WAAnB,EAAgCa,QAAjD,EAA2DC,WAA3D,EAAjB;AACAoB,EAAAA,MAAM,CAACE,KAAP,CAAaC,UAAb;AACAH,EAAAA,MAAM,CAACf,aAAP,CAAqBrB,WAAW,CAACW,MAAZ,CAAmBT,WAAnB,EAAgCoB,WAArD;AAEAc,EAAAA,MAAM,CAACE,KAAP,CAAanC,UAAb;AAEAiC,EAAAA,MAAM,CAACE,KAAP,CAAalC,cAAb;AAEAgC,EAAAA,MAAM,CAACf,aAAP,CAAqBrB,WAAW,CAACW,MAAZ,CAAmBT,WAAnB,EAAgC4B,cAArD,EA9DgG,CAgEhG;;AACAM,EAAAA,MAAM,CAACE,KAAP,CAAa/B,WAAb,EAjEgG,CAmEhG;;AACA6B,EAAAA,MAAM,CAACf,aAAP,CAAqBrB,WAAW,CAACwC,SAAjC,EApEgG,CAsEhG;;AACAJ,EAAAA,MAAM,CAACK,YAAP,CAAoBxC,WAApB;AAEA,SAAON,IAAI,CAAC4B,YAAL,CAAkBa,MAAM,CAACD,QAAP,EAAlB,CAAP;AAED,CA3ED;AA6EA;;;;;;;;;;;;;;AAYA,SAASO,IAAT,CAAc1C,WAAd,EAA2B2C,UAA3B,EAAuC1C,WAAvC,EAAoD2C,UAApD,EAAgEzC,UAAhE,EAA4EC,cAA5E,EAA4FyC,aAA5F,EAA2G;AACzGA,EAAAA,aAAa,GAAGA,aAAa,IAAI,OAAjC;AACA,MAAIC,GAAJ;;AAEA,MAAID,aAAa,KAAK,OAAtB,EAA+B;AAC7B,QAAIE,OAAO,GAAGhD,OAAO,CAACC,WAAD,EAAcC,WAAd,EAA2B2C,UAA3B,EAAuCzC,UAAvC,EAAmDC,cAAnD,CAArB;AACA0C,IAAAA,GAAG,GAAGlD,KAAK,CAAC8C,IAAN,CAAWK,OAAX,EAAoBJ,UAApB,EAAgCK,GAAhC,CAAoC;AACxCC,MAAAA,SAAS,EAAEhD;AAD6B,KAApC,CAAN;AAGA,WAAO6C,GAAP;AACD;;AACD,QAAM,IAAII,KAAJ,CAAU,8BAAV,EAA0CL,aAA1C,CAAN;AACD;AAED;;;;;;;;;;;;;;AAYA,SAASM,MAAT,CAAgBnD,WAAhB,EAA6BoD,SAA7B,EAAwCC,SAAxC,EAAmDT,UAAnD,EAA+DzC,UAA/D,EAA2EC,cAA3E,EAA2FyC,aAA3F,EAA0G;AACxGhD,EAAAA,CAAC,CAACyD,aAAF,CAAgB,CAACxD,CAAC,CAACyD,WAAF,CAAcvD,WAAd,CAAjB;AACAH,EAAAA,CAAC,CAACyD,aAAF,CAAgB,CAACxD,CAAC,CAACyD,WAAF,CAAcH,SAAd,CAAD,IAA6B,CAACtD,CAAC,CAACyD,WAAF,CAAcH,SAAS,CAACH,SAAxB,CAA9C;AACAJ,EAAAA,aAAa,GAAGA,aAAa,IAAI,OAAjC;;AAEA,MAAIA,aAAa,KAAK,OAAtB,EAA+B;AAC7B,QAAIE,OAAO,GAAGhD,OAAO,CAACC,WAAD,EAAcoD,SAAS,CAACH,SAAxB,EAAmCL,UAAnC,EAA+CzC,UAA/C,EAA2DC,cAA3D,CAArB;AACA,WAAOR,KAAK,CAACuD,MAAN,CAAaJ,OAAb,EAAsBK,SAAtB,EAAiCC,SAAjC,CAAP;AACD;;AACD,QAAM,IAAIH,KAAJ,CAAU,8BAAV,EAA0CL,aAA1C,CAAN;AACD;AAED;;;;;AAGAW,MAAM,CAACC,OAAP,GAAiB;AACf1D,EAAAA,OAAO,EAAEA,OADM;AAEf2C,EAAAA,IAAI,EAAEA,IAFS;AAGfS,EAAAA,MAAM,EAAEA;AAHO,CAAjB","sourcesContent":["'use strict';\n\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts;\n  var hashSequence;\n  var hashOutputs;\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n\n  writer.write(scriptCode);\n\n  writer.write(satoshisBuffer);\n\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n\n  return Hash.sha256sha256(writer.toBuffer());\n\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  var sig;\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n    sig = ECDSA.sign(hashbuf, privateKey).set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  signingMethod = signingMethod || 'ecdsa';\n\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n    return ECDSA.verify(hashbuf, signature, publicKey);\n  }\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"]},"metadata":{},"sourceType":"script"}