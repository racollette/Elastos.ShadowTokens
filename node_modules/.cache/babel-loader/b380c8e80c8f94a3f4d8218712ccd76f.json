{"ast":null,"code":"var typeforce = require('typeforce');\n\nvar ECSignature = require('./ecsignature');\n\nvar types = require('./types');\n\nvar secp256k1;\nvar available = false;\n\ntry {\n  // secp256k1 is an optional native module used for accelerating\n  // low-level elliptic curve operations. It's nice to have, but\n  // we can live without it too\n  secp256k1 = require('secp256k1');\n  available = true;\n} catch (e) {// secp256k1 is not available, this is alright\n}\n/**\n * Derive a public key from a 32 byte private key buffer.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n *\n * @param buffer {Buffer} Private key buffer\n * @param compressed {Boolean} Whether the public key should be compressed\n * @return {undefined}\n */\n\n\nvar publicKeyCreate = function (buffer, compressed) {\n  typeforce(types.tuple(types.Buffer256bit, types.Boolean), arguments);\n\n  if (!available) {\n    return undefined;\n  }\n\n  return secp256k1.publicKeyCreate(buffer, compressed);\n};\n/**\n * Create an ECDSA signature over the given message hash `hash` with\n * the private key `d`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be signed\n * @param d {BigInteger} private key which is to be used for signing\n * @return {ECSignature}\n */\n\n\nvar sign = function (hash, d) {\n  typeforce(types.tuple(types.Buffer256bit, types.BigInt), arguments);\n\n  if (!available) {\n    return undefined;\n  }\n\n  var sig = secp256k1.sign(hash, d.toBuffer(32)).signature;\n  return ECSignature.fromDER(secp256k1.signatureExport(sig));\n};\n/**\n * Verify an ECDSA signature over the given message hash `hash` with signature `sig`\n * and public key `pubkey`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be verified\n * @param sig {ECSignature} signature which is to be verified\n * @param pubkey {Buffer} public key which will be used to verify the message signature\n * @return {Boolean}\n */\n\n\nvar verify = function (hash, sig, pubkey) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature, // both compressed and uncompressed public keys are fine\n  types.oneOf(types.BufferN(33), types.BufferN(65))), arguments);\n\n  if (!available) {\n    return undefined;\n  }\n\n  sig = new ECSignature(sig.r, sig.s);\n  sig = secp256k1.signatureNormalize(secp256k1.signatureImport(sig.toDER()));\n  return secp256k1.verify(hash, sig, pubkey);\n};\n\nmodule.exports = {\n  available: available,\n  publicKeyCreate: publicKeyCreate,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitgo-utxo-lib/src/fastcurve.js"],"names":["typeforce","require","ECSignature","types","secp256k1","available","e","publicKeyCreate","buffer","compressed","tuple","Buffer256bit","Boolean","arguments","undefined","sign","hash","d","BigInt","sig","toBuffer","signature","fromDER","signatureExport","verify","pubkey","Hash256bit","oneOf","BufferN","r","s","signatureNormalize","signatureImport","toDER","module","exports"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAIC,WAAW,GAAGD,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,SAAD,CAAnB;;AAEA,IAAIG,SAAJ;AACA,IAAIC,SAAS,GAAG,KAAhB;;AACA,IAAI;AACF;AACA;AACA;AACAD,EAAAA,SAAS,GAAGH,OAAO,CAAC,WAAD,CAAnB;AACAI,EAAAA,SAAS,GAAG,IAAZ;AACD,CAND,CAME,OAAOC,CAAP,EAAU,CACV;AACD;AAED;;;;;;;;;;;;AAUA,IAAIC,eAAe,GAAG,UAAUC,MAAV,EAAkBC,UAAlB,EAA8B;AAClDT,EAAAA,SAAS,CAACG,KAAK,CAACO,KAAN,CAAYP,KAAK,CAACQ,YAAlB,EAAgCR,KAAK,CAACS,OAAtC,CAAD,EAAiDC,SAAjD,CAAT;;AAEA,MAAI,CAACR,SAAL,EAAgB;AACd,WAAOS,SAAP;AACD;;AAED,SAAOV,SAAS,CAACG,eAAV,CAA0BC,MAA1B,EAAkCC,UAAlC,CAAP;AACD,CARD;AAUA;;;;;;;;;;;;AAUA,IAAIM,IAAI,GAAG,UAAUC,IAAV,EAAgBC,CAAhB,EAAmB;AAC5BjB,EAAAA,SAAS,CAACG,KAAK,CAACO,KAAN,CAAYP,KAAK,CAACQ,YAAlB,EAAgCR,KAAK,CAACe,MAAtC,CAAD,EAAgDL,SAAhD,CAAT;;AAEA,MAAI,CAACR,SAAL,EAAgB;AACd,WAAOS,SAAP;AACD;;AAED,MAAIK,GAAG,GAAGf,SAAS,CAACW,IAAV,CAAeC,IAAf,EAAqBC,CAAC,CAACG,QAAF,CAAW,EAAX,CAArB,EAAqCC,SAA/C;AACA,SAAOnB,WAAW,CAACoB,OAAZ,CAAoBlB,SAAS,CAACmB,eAAV,CAA0BJ,GAA1B,CAApB,CAAP;AACD,CATD;AAWA;;;;;;;;;;;;;AAWA,IAAIK,MAAM,GAAG,UAAUR,IAAV,EAAgBG,GAAhB,EAAqBM,MAArB,EAA6B;AACxCzB,EAAAA,SAAS,CAACG,KAAK,CAACO,KAAN,CACRP,KAAK,CAACuB,UADE,EAERvB,KAAK,CAACD,WAFE,EAGR;AACAC,EAAAA,KAAK,CAACwB,KAAN,CAAYxB,KAAK,CAACyB,OAAN,CAAc,EAAd,CAAZ,EAA+BzB,KAAK,CAACyB,OAAN,CAAc,EAAd,CAA/B,CAJQ,CAAD,EAKPf,SALO,CAAT;;AAOA,MAAI,CAACR,SAAL,EAAgB;AACd,WAAOS,SAAP;AACD;;AAEDK,EAAAA,GAAG,GAAG,IAAIjB,WAAJ,CAAgBiB,GAAG,CAACU,CAApB,EAAuBV,GAAG,CAACW,CAA3B,CAAN;AACAX,EAAAA,GAAG,GAAGf,SAAS,CAAC2B,kBAAV,CAA6B3B,SAAS,CAAC4B,eAAV,CAA0Bb,GAAG,CAACc,KAAJ,EAA1B,CAA7B,CAAN;AACA,SAAO7B,SAAS,CAACoB,MAAV,CAAiBR,IAAjB,EAAuBG,GAAvB,EAA4BM,MAA5B,CAAP;AACD,CAfD;;AAiBAS,MAAM,CAACC,OAAP,GAAiB;AACf9B,EAAAA,SAAS,EAAEA,SADI;AAEfE,EAAAA,eAAe,EAAEA,eAFF;AAGfQ,EAAAA,IAAI,EAAEA,IAHS;AAIfS,EAAAA,MAAM,EAAEA;AAJO,CAAjB","sourcesContent":["var typeforce = require('typeforce')\n\nvar ECSignature = require('./ecsignature')\nvar types = require('./types')\n\nvar secp256k1\nvar available = false\ntry {\n  // secp256k1 is an optional native module used for accelerating\n  // low-level elliptic curve operations. It's nice to have, but\n  // we can live without it too\n  secp256k1 = require('secp256k1')\n  available = true\n} catch (e) {\n  // secp256k1 is not available, this is alright\n}\n\n/**\n * Derive a public key from a 32 byte private key buffer.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n *\n * @param buffer {Buffer} Private key buffer\n * @param compressed {Boolean} Whether the public key should be compressed\n * @return {undefined}\n */\nvar publicKeyCreate = function (buffer, compressed) {\n  typeforce(types.tuple(types.Buffer256bit, types.Boolean), arguments)\n\n  if (!available) {\n    return undefined\n  }\n\n  return secp256k1.publicKeyCreate(buffer, compressed)\n}\n\n/**\n * Create an ECDSA signature over the given message hash `hash` with\n * the private key `d`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be signed\n * @param d {BigInteger} private key which is to be used for signing\n * @return {ECSignature}\n */\nvar sign = function (hash, d) {\n  typeforce(types.tuple(types.Buffer256bit, types.BigInt), arguments)\n\n  if (!available) {\n    return undefined\n  }\n\n  var sig = secp256k1.sign(hash, d.toBuffer(32)).signature\n  return ECSignature.fromDER(secp256k1.signatureExport(sig))\n}\n\n/**\n * Verify an ECDSA signature over the given message hash `hash` with signature `sig`\n * and public key `pubkey`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be verified\n * @param sig {ECSignature} signature which is to be verified\n * @param pubkey {Buffer} public key which will be used to verify the message signature\n * @return {Boolean}\n */\nvar verify = function (hash, sig, pubkey) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.ECSignature,\n    // both compressed and uncompressed public keys are fine\n    types.oneOf(types.BufferN(33), types.BufferN(65))),\n    arguments)\n\n  if (!available) {\n    return undefined\n  }\n\n  sig = new ECSignature(sig.r, sig.s)\n  sig = secp256k1.signatureNormalize(secp256k1.signatureImport(sig.toDER()))\n  return secp256k1.verify(hash, sig, pubkey)\n}\n\nmodule.exports = {\n  available: available,\n  publicKeyCreate: publicKeyCreate,\n  sign: sign,\n  verify: verify\n}\n"]},"metadata":{},"sourceType":"script"}