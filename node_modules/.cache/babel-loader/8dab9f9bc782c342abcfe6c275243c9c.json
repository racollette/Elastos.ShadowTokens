{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar createHmac = require('create-hmac');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature');\n\nvar ZERO = Buffer.alloc(1, 0);\nvar ONE = Buffer.alloc(1, 1);\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1'); // https://tools.ietf.org/html/rfc6979#section-3.2\n\nfunction deterministicGenerateK(hash, x, checkSig) {\n  typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments); // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n\n  var k = Buffer.alloc(32, 0);\n  var v = Buffer.alloc(32, 1); // Step D\n\n  k = createHmac('sha256', k).update(v).update(ZERO).update(x).update(hash).digest(); // Step E\n\n  v = createHmac('sha256', k).update(v).digest(); // Step F\n\n  k = createHmac('sha256', k).update(v).update(ONE).update(x).update(hash).digest(); // Step G\n\n  v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = createHmac('sha256', k).update(v).digest();\n  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n\n  while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n    k = createHmac('sha256', k).update(v).update(ZERO).digest();\n    v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = createHmac('sha256', k).update(v).digest();\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nvar N_OVER_TWO = secp256k1.n.shiftRight(1);\n\nfunction sign(hash, d) {\n  typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);\n  var x = d.toBuffer(32);\n  var e = BigInteger.fromBuffer(hash);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r, s;\n  deterministicGenerateK(hash, x, function (k) {\n    var Q = G.multiply(k);\n    if (secp256k1.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return new ECSignature(r, s);\n}\n\nfunction verify(hash, signature, Q) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r = signature.r;\n  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n\n  var e = BigInteger.fromBuffer(hash); // Compute s^-1\n\n  var sInv = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  var u1 = e.multiply(sInv).mod(n);\n  var u2 = r.multiply(sInv).mod(n); // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n\n  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (secp256k1.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  var xR = R.affineX; // 1.4.7 Set v = xR mod n\n\n  var v = xR.mod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.equals(r);\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n  // TODO: remove\n  __curve: secp256k1\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitgo-utxo-lib/src/ecdsa.js"],"names":["Buffer","require","createHmac","typeforce","types","BigInteger","ECSignature","ZERO","alloc","ONE","ecurve","secp256k1","getCurveByName","deterministicGenerateK","hash","x","checkSig","tuple","Hash256bit","Buffer256bit","Function","arguments","k","v","update","digest","T","fromBuffer","signum","compareTo","n","N_OVER_TWO","shiftRight","sign","d","BigInt","toBuffer","e","G","r","s","Q","multiply","isInfinity","affineX","mod","modInverse","add","subtract","verify","signature","ECPoint","sInv","u1","u2","R","multiplyTwo","xR","equals","module","exports","__curve"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar createHmac = require('create-hmac')\nvar typeforce = require('typeforce')\nvar types = require('./types')\n\nvar BigInteger = require('bigi')\nvar ECSignature = require('./ecsignature')\n\nvar ZERO = Buffer.alloc(1, 0)\nvar ONE = Buffer.alloc(1, 1)\n\nvar ecurve = require('ecurve')\nvar secp256k1 = ecurve.getCurveByName('secp256k1')\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK (hash, x, checkSig) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.Buffer256bit,\n    types.Function\n  ), arguments)\n\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  var k = Buffer.alloc(32, 0)\n  var v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO)\n    .update(x)\n    .update(hash)\n    .digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE)\n    .update(x)\n    .update(hash)\n    .digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  var T = BigInteger.fromBuffer(v)\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = BigInteger.fromBuffer(v)\n  }\n\n  return T\n}\n\nvar N_OVER_TWO = secp256k1.n.shiftRight(1)\n\nfunction sign (hash, d) {\n  typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments)\n\n  var x = d.toBuffer(32)\n  var e = BigInteger.fromBuffer(hash)\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  var r, s\n  deterministicGenerateK(hash, x, function (k) {\n    var Q = G.multiply(k)\n\n    if (secp256k1.isInfinity(Q)) return false\n\n    r = Q.affineX.mod(n)\n    if (r.signum() === 0) return false\n\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n)\n    if (s.signum() === 0) return false\n\n    return true\n  })\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s)\n  }\n\n  return new ECSignature(r, s)\n}\n\nfunction verify (hash, signature, Q) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.ECSignature,\n    types.ECPoint\n  ), arguments)\n\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  var r = signature.r\n  var s = signature.s\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash)\n\n  // Compute s^-1\n  var sInv = s.modInverse(n)\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  var u1 = e.multiply(sInv).mod(n)\n  var u2 = r.multiply(sInv).mod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  var R = G.multiplyTwo(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (secp256k1.isInfinity(R)) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  var xR = R.affineX\n\n  // 1.4.7 Set v = xR mod n\n  var v = xR.mod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.equals(r)\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n\n  // TODO: remove\n  __curve: secp256k1\n}\n"]},"metadata":{},"sourceType":"script"}