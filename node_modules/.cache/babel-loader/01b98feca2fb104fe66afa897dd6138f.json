{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar Address = require('../../address');\n\nvar Hash = require('../../crypto/hash');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar Sighash = require('../sighash');\n\nvar SighashWitness = require('../sighashwitness');\n\nvar BufferWriter = require('../../encoding/bufferwriter');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar TransactionSignature = require('../signature');\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\n\n\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\n\ninherits(PublicKeyHashInput, Input);\n\nPublicKeyHashInput.prototype.getRedeemScript = function (publicKey) {\n  if (!this.redeemScript) {\n    var redeemScript = Script.buildWitnessV0Out(publicKey);\n\n    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {\n      var scriptSig = new Script();\n      scriptSig.add(redeemScript.toBuffer());\n      this.setScript(scriptSig);\n      this.redeemScript = redeemScript;\n    }\n  }\n\n  return this.redeemScript;\n};\n\nPublicKeyHashInput.prototype.getScriptCode = function (publicKey) {\n  var writer = new BufferWriter();\n  var script;\n\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(publicKey);\n  } else {\n    script = this.output.script;\n  }\n\n  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();\n  writer.writeVarintNum(scriptBuffer.length);\n  writer.write(scriptBuffer);\n  return writer.toBuffer();\n};\n\nPublicKeyHashInput.prototype.getSighash = function (transaction, privateKey, index, sigtype) {\n  var scriptCode = this.getScriptCode(privateKey);\n  var satoshisBuffer = this.getSatoshisBuffer();\n  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n};\n/* jshint maxparams: 5 */\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Array} of objects that can be\n */\n\n\nPublicKeyHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa';\n  var script;\n\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(privateKey.publicKey);\n  } else {\n    script = this.output.script;\n  }\n\n  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {\n    var signature;\n\n    if (script.isWitnessPublicKeyHashOut()) {\n      var satoshisBuffer = this.getSatoshisBuffer();\n      var scriptCode = this.getScriptCode(privateKey.publicKey);\n      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);\n    } else {\n      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod);\n    }\n\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: signature,\n      sigtype: sigtype\n    })];\n  }\n\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyHashInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    this.setWitnesses([BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]), signature.publicKey.toBuffer()]);\n  } else {\n    this.setScript(Script.buildPublicKeyHashIn(signature.publicKey, signature.signature.toDER(), signature.sigtype));\n  }\n\n  return this;\n};\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyHashInput.prototype.clearSignatures = function () {\n  this.setScript(Script.empty());\n  this.setWitnesses([]);\n  return this;\n};\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\n\n\nPublicKeyHashInput.prototype.isFullySigned = function () {\n  return this.script.isPublicKeyHashIn() || this.hasWitnesses();\n};\n\nPublicKeyHashInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, scriptCode, satoshisBuffer, signingMethod);\n  } else {\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, signingMethod);\n  }\n};\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.REDEEM_SCRIPT_SIZE = 22; // OP_0 (1) pubkeyhash (1 + 20)\n\nPublicKeyHashInput.prototype._estimateSize = function () {\n  var WITNESS_DISCOUNT = 4;\n  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n\n  if (this.output.script.isWitnessPublicKeyHashOut()) {\n    return witnessSize;\n  } else if (this.output.script.isScriptHashOut()) {\n    return witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n};\n\nmodule.exports = PublicKeyHashInput;","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js"],"names":["inherits","require","$","BufferUtil","Address","Hash","Input","Output","Sighash","SighashWitness","BufferWriter","Script","Signature","TransactionSignature","PublicKeyHashInput","apply","arguments","prototype","getRedeemScript","publicKey","redeemScript","buildWitnessV0Out","buildScriptHashOut","equals","output","script","scriptSig","add","toBuffer","setScript","getScriptCode","writer","isScriptHashOut","scriptBuffer","buildPublicKeyHashOut","toAddress","writeVarintNum","length","write","getSighash","transaction","privateKey","index","sigtype","scriptCode","satoshisBuffer","getSatoshisBuffer","sighash","getSignatures","hashData","signingMethod","checkState","sha256ripemd160","SIGHASH_ALL","getPublicKeyHash","signature","isWitnessPublicKeyHashOut","sign","prevTxId","outputIndex","inputIndex","addSignature","isValidSignature","setWitnesses","concat","toDER","integerAsSingleByteBuffer","buildPublicKeyHashIn","clearSignatures","empty","isFullySigned","isPublicKeyHashIn","hasWitnesses","nhashtype","verify","SCRIPT_MAX_SIZE","REDEEM_SCRIPT_SIZE","_estimateSize","WITNESS_DISCOUNT","witnessSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Address = require('../../address');\nvar Hash = require('../../crypto/hash');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar SighashWitness = require('../sighashwitness');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar BufferUtil = require('../../util/buffer');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\nPublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {\n  if (!this.redeemScript) {\n    var redeemScript = Script.buildWitnessV0Out(publicKey);\n    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {\n      var scriptSig = new Script();\n      scriptSig.add(redeemScript.toBuffer());\n      this.setScript(scriptSig);\n      this.redeemScript = redeemScript;\n    }\n  }\n  return this.redeemScript;\n};\n\nPublicKeyHashInput.prototype.getScriptCode = function(publicKey) {\n  var writer = new BufferWriter();\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(publicKey);\n  } else {\n    script = this.output.script;\n  }\n  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();\n  writer.writeVarintNum(scriptBuffer.length);\n  writer.write(scriptBuffer);\n  return writer.toBuffer();\n};\n\nPublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var scriptCode = this.getScriptCode(privateKey);\n  var satoshisBuffer = this.getSatoshisBuffer();\n  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n};\n\n/* jshint maxparams: 5 */\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Array} of objects that can be\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa';\n\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(privateKey.publicKey);\n  } else {\n    script = this.output.script;\n  }\n\n  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {\n    var signature;\n    if (script.isWitnessPublicKeyHashOut()) {\n      var satoshisBuffer = this.getSatoshisBuffer();\n      var scriptCode = this.getScriptCode(privateKey.publicKey);\n      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);\n    } else {\n      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod);\n    }\n\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: signature,\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    this.setWitnesses([\n      BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]),\n      signature.publicKey.toBuffer()\n    ]);\n  } else {\n    this.setScript(Script.buildPublicKeyHashIn(\n      signature.publicKey,\n      signature.signature.toDER(),\n      signature.sigtype\n    ));\n  }\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  this.setWitnesses([]);\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn() || this.hasWitnesses();\n};\n\nPublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer,\n      signingMethod\n    );\n  } else {\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.output.script,\n      signingMethod\n    );\n  }\n};\n\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\nPublicKeyHashInput.REDEEM_SCRIPT_SIZE = 22; // OP_0 (1) pubkeyhash (1 + 20)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  var WITNESS_DISCOUNT = 4;\n  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  if (this.output.script.isWitnessPublicKeyHashOut()) {\n    return witnessSize;\n  } else if (this.output.script.isScriptHashOut()) {\n    return witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n};\n\nmodule.exports = PublicKeyHashInput;\n"]},"metadata":{},"sourceType":"script"}