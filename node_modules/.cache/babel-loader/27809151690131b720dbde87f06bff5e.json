{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar JSUtil = require('../util/js');\n\nconst {\n  sign\n} = require('./ecdsa');\n\nvar Signature = function Signature(r, s, isSchnorr) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s, isSchnorr);\n  }\n\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s,\n      isSchnorr: isSchnorr\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n/* jshint maxcomplexity: 7 */\n\n\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; // whether the recovered pubkey is compressed\n\n  this.isSchnorr = obj.isSchnorr;\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function (buf, strict) {\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype \n  if ((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\n    let obj = Signature.parseSchnorrEncodedSig(buf);\n    let sig = new Signature();\n    sig.r = obj.r;\n    sig.s = obj.s;\n    sig.isSchnorr = true;\n    return sig;\n  }\n\n  if (buf.length === 64 && buf[0] === 0x30) {\n    return \"64 DER (ecdsa) signatures not allowed\";\n  }\n\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n}; // The format used in a tx\n\n\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n}; // The format used in a tx\n\n\nSignature.fromDataFormat = function (buf) {\n  var derbuf = buf.slice(0, buf.length);\n  var sig = new Signature.fromDER(derbuf, false);\n  return sig;\n};\n\nSignature.fromString = function (str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\nSignature.parseSchnorrEncodedSig = function (buf) {\n  let r = buf.slice(0, 32);\n  let s = buf.slice(32, 64);\n  let hashtype;\n\n  if (buf.length === 65) {\n    hashtype = buf.slice(64, 65);\n    this.nhashtype = hashtype;\n  }\n\n  var obj = {\n    r: BN.fromBuffer(r),\n    s: BN.fromBuffer(s),\n    nhashtype: hashtype\n  };\n  return obj;\n};\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\n\n\nSignature.parseDER = function (buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n  return obj;\n};\n\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n\n  if (compressed === false) {\n    val = val - 4;\n  }\n\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function (signingMethod) {\n  // Schnorr signatures use a 64 byte r,s format, where as ECDSA takes the form decribed\n  // below, above the isDER function signature.\n  signingMethod = signingMethod || \"ecdsa\";\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  if (signingMethod === \"schnorr\") {\n    return Buffer.concat([rnbuf, snbuf]);\n  }\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\nSignature.isTxDER = function (buf) {\n  return Signature.isDER(buf.slice(0, buf.length - 1));\n};\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\n\n\nSignature.isDER = function (buf) {\n  // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  // * total-length: 1-byte length descriptor of everything that follows,\n  // excluding the sighash byte.\n  // * R-length: 1-byte length descriptor of the R value that follows.\n  // * R: arbitrary-length big-endian encoded R value. It must use the\n  // shortest possible encoding for a positive integers (which means no null\n  // bytes at the start, except a single one when the next byte has its\n  // highest bit set).\n  // * S-length: 1-byte length descriptor of the S value that follows.\n  // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n  // Minimum and maximum size constraints.\n  if (buf.length < 8 || buf.length > 72) {\n    return false;\n  } //\n  // Check that the signature is a compound structure of proper size.\n  //\n  // A signature is of type 0x30 (compound).\n\n\n  if (buf[0] != 0x30) {\n    return false;\n  } // Make sure the length covers the entire signature.\n  // Remove:\n  // * 1 byte for the coupound type.\n  // * 1 byte for the length of the signature.\n\n\n  if (buf[1] != buf.length - 2) {\n    return false;\n  } //\n  // Check that R is an positive integer of sensible size.\n  //\n  // Check whether the R element is an integer.\n\n\n  if (buf[2] != 0x02) {\n    return false;\n  } // Extract the length of the R element.\n\n\n  var lenR = buf[3]; // Zero-length integers are not allowed for R.\n\n  if (lenR == 0) {\n    return false;\n  } // Negative numbers are not allowed for R.\n\n\n  if (buf[4] & 0x80) {\n    return false;\n  } // Make sure the length of the R element is consistent with the signature\n  // size.\n  // Remove:\n  // * 1 byte for the coumpound type.\n  // * 1 byte for the length of the signature.\n  // * 2 bytes for the integer type of R and S.\n  // * 2 bytes for the size of R and S.\n  // * 1 byte for S itself.\n\n\n  if (lenR > buf.length - 7) {\n    return false;\n  } // Null bytes at the start of R are not allowed, unless R would otherwise be\n  // interpreted as a negative number.\n  //\n  // /!\\ This check can only be performed after we checked that lenR is\n  //     consistent with the size of the signature or we risk to access out of\n  //     bound elements.\n\n\n  if (lenR > 1 && buf[4] == 0x00 && !(buf[5] & 0x80)) {\n    return false;\n  } //\n  // Check that S is an positive integer of sensible size.\n  //\n  // S's definition starts after R's definition:\n  // * 1 byte for the coumpound type.\n  // * 1 byte for the length of the signature.\n  // * 1 byte for the size of R.\n  // * lenR bytes for R itself.\n  // * 1 byte to get to S.\n\n\n  var startS = lenR + 4; // Check whether the S element is an integer.\n\n  if (buf[startS] != 0x02) {\n    return false;\n  } // Extract the length of the S element.\n\n\n  var lenS = buf[startS + 1]; // Zero-length integers are not allowed for S.\n\n  if (lenS == 0) {\n    return false;\n  } // Negative numbers are not allowed for S.\n\n\n  if (buf[startS + 2] & 0x80) {\n    return false;\n  } // Verify that the length of S is consistent with the size of the signature\n  // including metadatas:\n  // * 1 byte for the integer type of S.\n  // * 1 byte for the size of S.\n\n\n  if (startS + lenS + 2 != buf.length) {\n    return false;\n  } // Null bytes at the start of S are not allowed, unless S would otherwise be\n  // interpreted as a negative number.\n  //\n  // /!\\ This check can only be performed after we checked that lenR and lenS\n  //     are consistent with the size of the signature or we risk to access\n  //     out of bound elements.\n\n\n  if (lenS > 1 && buf[startS + 2] == 0x00 && !(buf[startS + 3] & 0x80)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\n\n\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\n\n\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  // base mask was 1F\n\n\n  var mask = ~(Signature.SIGHASH_FORKID | Signature.SIGHASH_ANYONECANPAY) >>> 0;\n  var temp = this.nhashtype & mask;\n\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n\n  return true;\n};\n\nSignature.prototype.toTxFormat = function (signingMethod) {\n  var derbuf = this.toDER(signingMethod);\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_FORKID = 0x40;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\nmodule.exports = Signature;","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitcore-lib-cash/lib/crypto/signature.js"],"names":["BN","require","_","$","BufferUtil","JSUtil","sign","Signature","r","s","isSchnorr","set","obj","prototype","undefined","i","compressed","nhashtype","fromCompact","buf","checkArgument","isBuffer","sig","slice","b2","b3","Error","length","fromBuffer","fromDER","strict","parseSchnorrEncodedSig","parseDER","fromTxFormat","readUInt8","derbuf","fromDataFormat","fromString","str","Buffer","from","hashtype","isUndefined","header","buflength","rheader","rlength","rbuf","rneg","sheader","slength","sbuf","sneg","sumlength","toCompact","val","b1","toBuffer","size","concat","toDER","signingMethod","rnbuf","snbuf","der","toString","isTxDER","isDER","lenR","startS","lenS","hasLowS","lt","gt","hasDefinedHashtype","isNaturalNumber","mask","SIGHASH_FORKID","SIGHASH_ANYONECANPAY","temp","SIGHASH_ALL","SIGHASH_SINGLE","toTxFormat","alloc","writeUInt8","SIGHASH_NONE","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\nconst { sign } = require('./ecdsa');\n\nvar Signature = function Signature(r, s, isSchnorr) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s, isSchnorr);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s,\n      isSchnorr: isSchnorr,\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n  this.compressed = typeof obj.compressed !== 'undefined' ?\n    obj.compressed : this.compressed; // whether the recovered pubkey is compressed\n  this.isSchnorr = obj.isSchnorr;\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype \n  if((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\n    let obj = Signature.parseSchnorrEncodedSig(buf);\n    let sig = new Signature();\n    sig.r = obj.r;\n    sig.s = obj.s;\n    sig.isSchnorr = true;\n    return sig;\n  } if (buf.length === 64 && buf[0] === 0x30) {\n    return \"64 DER (ecdsa) signatures not allowed\";\n  }\n  \n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\n\n// The format used in a tx\nSignature.fromDataFormat = function(buf) {\n  var derbuf = buf.slice(0, buf.length);\n  var sig = new Signature.fromDER(derbuf, false);\n  return sig;\n};\n\n\nSignature.fromString = function(str) {\n  var buf = Buffer.from(str, 'hex');\n  \n  return Signature.fromDER(buf);\n};\n\n\nSignature.parseSchnorrEncodedSig = function(buf) {\n  let r = buf.slice(0,32);\n  let s = buf.slice(32, 64);\n  let hashtype;\n  if (buf.length === 65) {\n    hashtype = buf.slice(64,65);\n    this.nhashtype = hashtype;\n  }\n\n  var obj = {\n    r: BN.fromBuffer(r),\n    s: BN.fromBuffer(s),\n    nhashtype: hashtype\n  };\n\n  return obj;\n};\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function(signingMethod) {\n\n  // Schnorr signatures use a 64 byte r,s format, where as ECDSA takes the form decribed\n  // below, above the isDER function signature.\n\n  signingMethod = signingMethod || \"ecdsa\";\n\n\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  if(signingMethod === \"schnorr\") {\n    return Buffer.concat([rnbuf, snbuf]);\n  }\n  \n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n\nSignature.isTxDER = function(buf) {\n  return Signature.isDER(buf.slice(0, buf.length-1));\n}\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isDER = function(buf) {\n  // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  // * total-length: 1-byte length descriptor of everything that follows,\n  // excluding the sighash byte.\n  // * R-length: 1-byte length descriptor of the R value that follows.\n  // * R: arbitrary-length big-endian encoded R value. It must use the\n  // shortest possible encoding for a positive integers (which means no null\n  // bytes at the start, except a single one when the next byte has its\n  // highest bit set).\n  // * S-length: 1-byte length descriptor of the S value that follows.\n  // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n\n  // Minimum and maximum size constraints.\n  if (buf.length < 8 || buf.length > 72) {\n    return false;\n  }\n\n  //\n  // Check that the signature is a compound structure of proper size.\n  //\n\n  // A signature is of type 0x30 (compound).\n  if (buf[0] != 0x30) {\n    return false;\n  }\n\n  // Make sure the length covers the entire signature.\n  // Remove:\n  // * 1 byte for the coupound type.\n  // * 1 byte for the length of the signature.\n  if (buf[1] != buf.length - 2) {\n    return false;\n  }\n\n  //\n  // Check that R is an positive integer of sensible size.\n  //\n\n  // Check whether the R element is an integer.\n  if (buf[2] != 0x02) {\n    return false;\n  }\n\n  // Extract the length of the R element.\n  var lenR = buf[3];\n\n  // Zero-length integers are not allowed for R.\n  if (lenR == 0) {\n    return false;\n  }\n\n  // Negative numbers are not allowed for R.\n  if (buf[4] & 0x80) {\n    return false;\n  }\n\n  // Make sure the length of the R element is consistent with the signature\n  // size.\n  // Remove:\n  // * 1 byte for the coumpound type.\n  // * 1 byte for the length of the signature.\n  // * 2 bytes for the integer type of R and S.\n  // * 2 bytes for the size of R and S.\n  // * 1 byte for S itself.\n  if (lenR > (buf.length - 7)) {\n    return false;\n  }\n\n  // Null bytes at the start of R are not allowed, unless R would otherwise be\n  // interpreted as a negative number.\n  //\n  // /!\\ This check can only be performed after we checked that lenR is\n  //     consistent with the size of the signature or we risk to access out of\n  //     bound elements.\n  if (lenR > 1 && (buf[4] == 0x00) && !(buf[5] & 0x80)) {\n    return false;\n  }\n\n  //\n  // Check that S is an positive integer of sensible size.\n  //\n\n  // S's definition starts after R's definition:\n  // * 1 byte for the coumpound type.\n  // * 1 byte for the length of the signature.\n  // * 1 byte for the size of R.\n  // * lenR bytes for R itself.\n  // * 1 byte to get to S.\n  var startS = lenR + 4;\n\n  // Check whether the S element is an integer.\n  if (buf[startS] != 0x02) {\n    return false;\n  }\n\n  // Extract the length of the S element.\n  var lenS = buf[startS + 1];\n\n  // Zero-length integers are not allowed for S.\n  if (lenS == 0) {\n    return false;\n  }\n\n  // Negative numbers are not allowed for S.\n  if (buf[startS + 2] & 0x80) {\n    return false;\n  }\n\n  // Verify that the length of S is consistent with the size of the signature\n  // including metadatas:\n  // * 1 byte for the integer type of S.\n  // * 1 byte for the size of S.\n  if (startS + lenS + 2 != buf.length) {\n    return false;\n  }\n\n  // Null bytes at the start of S are not allowed, unless S would otherwise be\n  // interpreted as a negative number.\n  //\n  // /!\\ This check can only be performed after we checked that lenR and lenS\n  //     are consistent with the size of the signature or we risk to access\n  //     out of bound elements.\n  if (lenS > 1 && (buf[startS + 2] == 0x00) && !(buf[startS + 3] & 0x80)) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  // base mask was 1F\n  var mask =  ~(Signature.SIGHASH_FORKID | Signature.SIGHASH_ANYONECANPAY) >>>0;\n  var temp = this.nhashtype  & mask;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function(signingMethod) {\n  var derbuf = this.toDER(signingMethod);\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_FORKID = 0x40;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\n\nmodule.exports = Signature;\n"]},"metadata":{},"sourceType":"script"}