{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar buffer = require('buffer');\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar Network = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PrivateKey = require('./privatekey');\n\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\n\nvar hdErrors = errors.HDPrivateKey;\n\nvar BufferUtil = require('./util/buffer');\n\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\n\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidPath = function (arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\n\n\nHDPrivateKey._getDerivationIndexes = function (path) {\n  var steps = path.split('/'); // Special cases:\n\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function (step) {\n    var isHardened = step.slice(-1) === '\\'';\n\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n\n    var index = +step; // cast to number\n\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.derive = function (arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.deriveNonCompliantChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function (index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({\n      size: 32\n    });\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function (path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidSerialized = function (data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\n\n\nHDPrivateKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(0, 4);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPrivateKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function (arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,\n    privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? Buffer.from(arg.privateKey, 'hex') : arg.privateKey,\n    checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function (network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\n\n\nHDPrivateKey.fromSeed = function (hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\nHDPrivateKey.prototype._calcHDPublicKey = function () {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\n\n\nHDPrivateKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey];\n  var concat = buffer.Buffer.concat(sequence);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  this._hdPublicKey = null;\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function () {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function () {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\n\n\nHDPrivateKey.prototype.toString = function () {\n  return this.xprivkey;\n};\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\n\n\nHDPrivateKey.prototype.inspect = function () {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\n\n\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\n\n\nHDPrivateKey.fromBuffer = function (arg) {\n  return new HDPrivateKey(arg.toString());\n};\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\n\n\nHDPrivateKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\nmodule.exports = HDPrivateKey;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitcore-lib/lib/hdprivatekey.js"],"names":["assert","require","buffer","_","$","BN","Base58","Base58Check","Hash","Network","Point","PrivateKey","Random","errors","hdErrors","HDPrivateKey","BufferUtil","JSUtil","MINIMUM_ENTROPY_BITS","BITS_TO_BYTES","MAXIMUM_ENTROPY_BITS","arg","_generateRandomly","get","isString","isBuffer","isValidSerialized","_buildFromSerialized","isValidJSON","_buildFromJSON","toString","getSerializedError","isObject","_buildFromObject","UnrecognizedArgument","isValidPath","hardened","indexes","_getDerivationIndexes","every","isNumber","Hardened","MaxIndex","path","steps","split","includes","RootElementAlias","slice","map","step","isHardened","NaN","index","some","isNaN","prototype","derive","deriveNonCompliantChild","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","nonCompliant","InvalidPath","indexBuffer","integerAsBuffer","data","nonZeroPadded","privateKey","bn","toBuffer","concat","Buffer","from","privateKeyBuffer","size","length","publicKey","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","add","toBigNumber","umod","getN","isValid","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","reduce","prev","validCharacters","InvalidB58Char","decode","e","InvalidB58Checksum","DataLength","InvalidLength","isUndefined","error","_validateNetwork","networkArg","InvalidNetworkArgument","version","integerFromBuffer","xprivkey","InvalidNetwork","fromString","checkArgument","fromObject","JSON","parse","buffers","integerAsSingleByteBuffer","isHexa","checksum","undefined","_buildFromBuffers","decoded","VersionStart","VersionEnd","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PrivateKeyStart","PrivateKeyEnd","ChecksumStart","ChecksumEnd","fromSeed","getRandomBuffer","hexa","isHexaString","InvalidEntropyArgument","NotEnoughEntropy","TooMuchEntropy","defaultNetwork","_calcHDPublicKey","_hdPublicKey","HDPublicKey","_validateBufferArguments","defineImmutable","sequence","emptyBuffer","encode","toPublicKey","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","Object","defineProperty","configurable","enumerable","xpubkey","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PrivateKeySize","CheckSumSize","inspect","toObject","toJSON","bufferToHex","copy","DefaultDepth","DefaultFingerprint","DefaultChildIndex","SerializedByteSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n\nvar assert = require('assert');\nvar buffer = require('buffer');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PrivateKey = require('./privatekey');\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function(arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\n\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n"]},"metadata":{},"sourceType":"script"}