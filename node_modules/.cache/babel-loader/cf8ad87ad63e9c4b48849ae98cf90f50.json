{"ast":null,"code":"/* eslint-disable */\nimport createLogger from 'logging';\nimport debugLogger from 'debug';\nimport SimplePeer from 'simple-peer';\nimport { isBrowser } from 'browser-or-node';\nimport uuid from 'uuid/v4';\nimport MewConnectCommon from './MewConnectCommon';\nconst debug = debugLogger('MEWconnect:webRTC-communication');\nconst debugPeer = debugLogger('MEWconnectVerbose:peer-instances');\nconst debugStages = debugLogger('MEWconnect:peer-stages');\nconst logger = createLogger('WebRtcCommunication');\nexport default class WebRtcCommunication extends MewConnectCommon {\n  constructor(mewCrypto) {\n    super();\n    this.Peer = SimplePeer;\n    this.mewCrypto = mewCrypto;\n    this.peersCreated = {};\n    this.allPeerIds = [];\n    this.iceState = '';\n    this.answerReceived = {};\n    this.answersReceived = [];\n    this.offersSent = -1;\n    this.turnTimer = null;\n    this.turnWaitTime = 5000;\n    this.enableTimer = true;\n    this.tryingTurn = false;\n    this.connected = false;\n    this.signals = this.jsonDetails.signals;\n    this.rtcEvents = this.jsonDetails.rtc;\n    this.version = this.jsonDetails.version;\n    this.versions = this.jsonDetails.versions;\n    this.lifeCycle = this.jsonDetails.lifeCycle;\n    this.iceStates = this.jsonDetails.iceConnectionState;\n    this.activeInitiatorId = null;\n    this.usingVersion = '';\n    this.p = null;\n    this.canSignal = false;\n  }\n\n  clearExtraOnConnection() {\n    this.peersCreated = {};\n    this.allPeerIds = [];\n    this.answerReceived = {};\n    this.answersReceived = [];\n  }\n\n  isAlive() {\n    if (this.p !== null) {\n      return this.p.connected && !this.p.destroyed;\n    }\n\n    return false;\n  }\n\n  setConnectionVersion(version) {\n    this.usingVersion = version;\n  }\n\n  setActiveInitiatorId(id) {\n    this.activeInitiatorId = id;\n  } // can be used to listen to specific events, especially those that pass data\n\n\n  uiCommunicator(event, data) {\n    debug(event, data);\n    this.emit(event, data);\n    this.emitStatus(event);\n  } // special status emitter to allow simple listening of various statuses in one listener\n\n\n  emitStatus(event) {\n    this.emit('status', event);\n  } // Check if a WebRTC connection exists before a window/tab is closed or refreshed\n  // Destroy the connection if one exists\n\n\n  destroyOnUnload() {\n    if (isBrowser) {\n      // eslint-disable-next-line no-undef\n      window.onunload = window.onbeforeunload = () => {\n        const iceStates = [this.iceStates.new, this.iceStates.connecting, this.iceStates.connected];\n\n        if (!this.Peer.destroyed || iceStates.includes(this.iceState)) {\n          this.rtcDestroy();\n        }\n      };\n    }\n  }\n\n  setActivePeerId() {\n    this.activePeerId = uuid();\n    this.allPeerIds.push(this.activePeerId);\n  }\n\n  getActivePeerId() {\n    const split = this.activePeerId.split('-');\n    return split.join('-');\n  }\n\n  fallbackTimer(clear) {\n    if (this.usingVersion === 'V2') {\n      if (clear) {\n        clearTimeout(this.turnTimer);\n      } else if (this.enableTimer) {\n        clearTimeout(this.turnTimer);\n        this.turnTimer = setTimeout(() => {\n          this.willAttemptTurn();\n        }, this.turnWaitTime);\n      }\n    }\n  }\n\n  start(simpleOptions) {\n    this.canSignal = !this.canSignal;\n    this.fallbackTimer();\n    this.setActivePeerId();\n    this.p = new this.Peer(simpleOptions);\n    const peerID = this.getActivePeerId();\n    this.answerReceived[peerID] = false;\n    this.p.peerInstanceId = peerID;\n    this.peersCreated[peerID] = this.p;\n    this.p.on(this.rtcEvents.error, this.onError.bind(this, peerID));\n    this.p.on(this.rtcEvents.connect, this.onConnect.bind(this, peerID));\n    this.p.on(this.rtcEvents.close, this.onClose.bind(this, peerID));\n    this.p.on(this.rtcEvents.data, this.onData.bind(this, peerID));\n    this.p.on(this.rtcEvents.signal, this.signalListener.bind(this));\n    debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n\n    this.p._pc.addEventListener('iceconnectionstatechange', this.stateChangeListener.bind(this, peerID));\n  }\n\n  onConnect(peerID) {\n    debug('onConnect', peerID);\n    this.connected = true;\n    this.emit('connect', peerID);\n    this.clearExtraOnConnection();\n  }\n\n  signalListener(data) {\n    if (this.canSignal) {\n      this.canSignal = !this.canSignal;\n      ++this.offersSent;\n      debug('webRTC setup signal received');\n      this.emit('signal', data);\n    }\n  }\n\n  receiveAnswer(plainTextOffer, peerID) {\n    debug('receiveAnswer for version: ', this.usingVersion);\n    this.fallbackTimer();\n\n    if (this.tryingTurn && this.usingVersion === 'V1') {\n      this.answersReceived.push(plainTextOffer);\n\n      if (this.turnTimer === null) {\n        const _self = this;\n\n        this.turnTimer = setTimeout(this.receiveTurnAnswer.bind(_self), 1000);\n      }\n    } else if (this.tryingTurn && this.usingVersion === 'V2') {\n      this.enableTimer = false;\n\n      if (this.turnTimer !== null) {\n        clearTimeout(this.turnTimer);\n      }\n\n      debug('webRtc receiveAnswer');\n      debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n\n      try {\n        this.p.signal(plainTextOffer);\n        debug('webRTC answer received and processed');\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    } else {\n      debug('webRtc receiveAnswer', this.answerReceived);\n      debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n\n      try {\n        this.answerReceived[this.p.peerInstanceId] = true;\n        this.p.signal(plainTextOffer);\n        debug('webRTC answer received and processed');\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    }\n  }\n\n  receiveTurnAnswer() {\n    const plainTextOffer = this.answersReceived[this.answersReceived.length - 1];\n    debug('webRtc receiveTurnAnswer', this.answerReceived);\n    debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n\n    try {\n      this.answerReceived[this.p.peerInstanceId] = true;\n      this.p.signal(plainTextOffer);\n      debug('webRTC answer received and processed');\n    } catch (e) {\n      // eslint-disable-next-line\n      console.error(e);\n    }\n  } // ----- Socket Event handlers\n  // Handle Socket Disconnect Event\n\n\n  socketDisconnectHandler(reason) {\n    debug(reason);\n    this.socketV1Connected = false;\n  } // Handle Socket Attempting Turn informative signal\n  // Provide Notice that initial WebRTC connection failed and the fallback method will be used\n\n\n  willAttemptTurn() {\n    debugStages('TRY TURN CONNECTION');\n    this.uiCommunicator(this.lifeCycle.UsingFallback);\n\n    if (!this.tryingTurn && this.usingVersion === 'V2') {\n      debugStages(' TRY TURN V2');\n      this.tryingTurn = true;\n\n      try {\n        this.useFallback();\n        this.uiCommunicator(this.lifeCycle.UsingFallback);\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    }\n\n    this.tryingTurn = true;\n  }\n\n  turnReset(peerId) {\n    debug('TURN_RESET');\n    this.tryingTurn = true;\n    this.answerReceived[peerId] = false;\n  }\n\n  useFallback() {\n    if (!this.connected) {\n      this.emit('useFallback', this.activeInitiatorId);\n    }\n  } // Handle Socket event to initiate turn connection\n  // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN\n\n\n  beginTurn(data) {\n    this.tryingTurn = true;\n    this.retryViaTurn(data);\n  } // ----- Failure Handlers\n\n\n  stateChangeListener(peerID, evt) {\n    // eslint-disable-next-line no-undef\n    if (typeof jest === 'undefined') {\n      // included because target is not defined in jest\n      debug(`iceConnectionState: ${evt.target.iceConnectionState}`);\n      debugPeer('this.allPeerIds', this.allPeerIds);\n      debugPeer('peerID', peerID);\n\n      if (evt.target.iceConnectionState === 'connected' || evt.target.iceConnectionState === 'completed') {\n        if (this.timer) {\n          clearTimeout(this.timer);\n        }\n\n        if (!this.connected) {\n          this.connected = true;\n          this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);\n        }\n      }\n\n      if ((evt.target.iceConnectionState === 'failed' || evt.target.iceConnectionState === 'disconnected') && !this.turnDisabled) {\n        this.turnDisabled = true;\n        this.useFallback();\n      }\n    }\n  } // =========================================================\n  // =========================================================\n  // =========================================================\n\n\n  async onData(peerID, data) {\n    debug('DATA RECEIVED');\n    debugPeer('peerID', peerID);\n    this.fallbackTimer();\n    this.emit('data', data);\n\n    try {\n      let decryptedData;\n\n      if (this.isJSON(data)) {\n        decryptedData = await this.mewCrypto.decrypt(JSON.parse(data.toString()));\n      } else {\n        decryptedData = await this.mewCrypto.decrypt(JSON.parse(data.toString()));\n      }\n\n      if (this.isJSON(decryptedData)) {\n        const parsed = JSON.parse(decryptedData);\n        this.emit('data', {\n          type: parsed.type,\n          data: parsed.data,\n          id: parsed.id\n        });\n      } else {\n        this.emit('data', {\n          type: decryptedData.type,\n          data: decryptedData.data,\n          id: decryptedData.id\n        });\n      }\n    } catch (e) {\n      logger.error(e);\n      debug('onData ERROR: data=', data);\n      debug('onData ERROR: data.toString()=', data.toString());\n    }\n  }\n\n  onClose(peerID, data) {\n    debugStages('WRTC onClose event');\n    debug('peerID', peerID);\n\n    if (!this.isAlive()) {\n      debugStages('WRTC CLOSE', data);\n\n      if (this.connected) {\n        this.uiCommunicator(this.lifeCycle.RtcClosedEvent);\n        this.uiCommunicator(this.lifeCycle.disconnected);\n        this.connected = false;\n      } else {\n        this.connected = false;\n      }\n    }\n  }\n\n  onError(peerID, err) {\n    debugStages('WRTC onError event');\n    debug('peerID', peerID);\n    debug(err.code);\n    debug('error', err);\n\n    if (!this.connected && !this.tryingTurn && !this.turnDisabled) {\n      this.useFallback();\n    } else {\n      if (!this.isAlive()) {\n        this.uiCommunicator(this.lifeCycle.RtcErrorEvent);\n      }\n    }\n  } // ----- WebRTC Communication Methods\n\n\n  sendRtcMessageClosure(type, msg, id) {\n    return () => {\n      debug(`[SEND RTC MESSAGE Closure] type:  ${type},  message:  ${msg}`);\n      this.rtcSend(JSON.stringify({\n        type,\n        data: msg,\n        id\n      }));\n    };\n  }\n\n  sendRtcMessage(type, msg, id) {\n    debug(msg);\n    debug(`[SEND RTC MESSAGE] type:  ${type},  message:  ${msg}, id: ${id}`);\n    this.rtcSend(JSON.stringify({\n      type,\n      data: msg,\n      id\n    }));\n  }\n\n  disconnectRTCClosure() {\n    return () => {\n      debugStages('DISCONNECT RTC Closure');\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n      this.rtcDestroy();\n      this.instance = null;\n    };\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.rtcDestroy();\n    this.instance = null;\n  }\n\n  async rtcSend(arg) {\n    debug(this.isAlive()); // todo remove dev item\n\n    if (this.isAlive()) {\n      let encryptedSend;\n\n      if (typeof arg === 'string') {\n        encryptedSend = await this.mewCrypto.encrypt(arg);\n      } else {\n        encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(arg));\n      }\n\n      debug('SENDING RTC');\n      this.p.send(JSON.stringify(encryptedSend));\n    } else {\n      // eslint-disable-next-line\n      this.uiCommunicator(this.lifeCycle.attemptedDisconnectedSend);\n      return false;\n    }\n  }\n\n  rtcDestroy() {\n    debug('rtcDestroy'); // todo remove dev item\n\n    if (this.isAlive()) {\n      this.p.destroy();\n      debug('DESTROYED'); // todo remove dev item\n\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);\n    } else if (!this.p.destroyed) {\n      try {\n        this.p.destroy();\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/@myetherwallet/mewconnect-web-client/src/connectClient/WebRtcCommunication.js"],"names":["createLogger","debugLogger","SimplePeer","isBrowser","uuid","MewConnectCommon","debug","debugPeer","debugStages","logger","WebRtcCommunication","constructor","mewCrypto","Peer","peersCreated","allPeerIds","iceState","answerReceived","answersReceived","offersSent","turnTimer","turnWaitTime","enableTimer","tryingTurn","connected","signals","jsonDetails","rtcEvents","rtc","version","versions","lifeCycle","iceStates","iceConnectionState","activeInitiatorId","usingVersion","p","canSignal","clearExtraOnConnection","isAlive","destroyed","setConnectionVersion","setActiveInitiatorId","id","uiCommunicator","event","data","emit","emitStatus","destroyOnUnload","window","onunload","onbeforeunload","new","connecting","includes","rtcDestroy","setActivePeerId","activePeerId","push","getActivePeerId","split","join","fallbackTimer","clear","clearTimeout","setTimeout","willAttemptTurn","start","simpleOptions","peerID","peerInstanceId","on","error","onError","bind","connect","onConnect","close","onClose","onData","signal","signalListener","_pc","addEventListener","stateChangeListener","receiveAnswer","plainTextOffer","_self","receiveTurnAnswer","e","console","length","socketDisconnectHandler","reason","socketV1Connected","UsingFallback","useFallback","turnReset","peerId","beginTurn","retryViaTurn","evt","jest","target","timer","RtcConnectedEvent","turnDisabled","decryptedData","isJSON","decrypt","JSON","parse","toString","parsed","type","RtcClosedEvent","disconnected","err","code","RtcErrorEvent","sendRtcMessageClosure","msg","rtcSend","stringify","sendRtcMessage","disconnectRTCClosure","RtcDisconnectEvent","instance","disconnectRTC","arg","encryptedSend","encrypt","send","attemptedDisconnectedSend","destroy","RtcDestroyedEvent"],"mappings":"AAAA;AACA,OAAOA,YAAP,MAAyB,SAAzB;AACA,OAAOC,WAAP,MAAwB,OAAxB;AAEA,OAAOC,UAAP,MAAuB,aAAvB;AACA,SAASC,SAAT,QAA0B,iBAA1B;AAEA,OAAOC,IAAP,MAAiB,SAAjB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AAEA,MAAMC,KAAK,GAAGL,WAAW,CAAC,iCAAD,CAAzB;AACA,MAAMM,SAAS,GAAGN,WAAW,CAAC,kCAAD,CAA7B;AACA,MAAMO,WAAW,GAAGP,WAAW,CAAC,wBAAD,CAA/B;AACA,MAAMQ,MAAM,GAAGT,YAAY,CAAC,qBAAD,CAA3B;AAEA,eAAe,MAAMU,mBAAN,SAAkCL,gBAAlC,CAAmD;AAChEM,EAAAA,WAAW,CAACC,SAAD,EAAY;AACrB;AACA,SAAKC,IAAL,GAAYX,UAAZ;AACA,SAAKU,SAAL,GAAiBA,SAAjB;AACA,SAAKE,YAAL,GAAoB,EAApB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,UAAL,GAAkB,CAAC,CAAnB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AAEA,SAAKC,OAAL,GAAe,KAAKC,WAAL,CAAiBD,OAAhC;AACA,SAAKE,SAAL,GAAiB,KAAKD,WAAL,CAAiBE,GAAlC;AACA,SAAKC,OAAL,GAAe,KAAKH,WAAL,CAAiBG,OAAhC;AACA,SAAKC,QAAL,GAAgB,KAAKJ,WAAL,CAAiBI,QAAjC;AACA,SAAKC,SAAL,GAAiB,KAAKL,WAAL,CAAiBK,SAAlC;AACA,SAAKC,SAAL,GAAiB,KAAKN,WAAL,CAAiBO,kBAAlC;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,CAAL,GAAS,IAAT;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACD;;AAEDC,EAAAA,sBAAsB,GAAG;AACvB,SAAKxB,YAAL,GAAoB,EAApB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKE,cAAL,GAAsB,EAAtB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACD;;AAEDqB,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKH,CAAL,KAAW,IAAf,EAAqB;AACnB,aAAO,KAAKA,CAAL,CAAOZ,SAAP,IAAoB,CAAC,KAAKY,CAAL,CAAOI,SAAnC;AACD;;AACD,WAAO,KAAP;AACD;;AAEDC,EAAAA,oBAAoB,CAACZ,OAAD,EAAU;AAC5B,SAAKM,YAAL,GAAoBN,OAApB;AACD;;AAEDa,EAAAA,oBAAoB,CAACC,EAAD,EAAI;AACtB,SAAKT,iBAAL,GAAyBS,EAAzB;AACD,GAjD+D,CAmDhE;;;AACAC,EAAAA,cAAc,CAACC,KAAD,EAAQC,IAAR,EAAc;AAC1BxC,IAAAA,KAAK,CAACuC,KAAD,EAAQC,IAAR,CAAL;AACA,SAAKC,IAAL,CAAUF,KAAV,EAAiBC,IAAjB;AACA,SAAKE,UAAL,CAAgBH,KAAhB;AACD,GAxD+D,CA0DhE;;;AACAG,EAAAA,UAAU,CAACH,KAAD,EAAQ;AAChB,SAAKE,IAAL,CAAU,QAAV,EAAoBF,KAApB;AACD,GA7D+D,CA+DhE;AACA;;;AACAI,EAAAA,eAAe,GAAG;AAChB,QAAI9C,SAAJ,EAAe;AACb;AACA+C,MAAAA,MAAM,CAACC,QAAP,GAAkBD,MAAM,CAACE,cAAP,GAAwB,MAAM;AAC9C,cAAMpB,SAAS,GAAG,CAChB,KAAKA,SAAL,CAAeqB,GADC,EAEhB,KAAKrB,SAAL,CAAesB,UAFC,EAGhB,KAAKtB,SAAL,CAAeR,SAHC,CAAlB;;AAKA,YAAI,CAAC,KAAKX,IAAL,CAAU2B,SAAX,IAAwBR,SAAS,CAACuB,QAAV,CAAmB,KAAKvC,QAAxB,CAA5B,EAA+D;AAC7D,eAAKwC,UAAL;AACD;AACF,OATD;AAUD;AACF;;AAEDC,EAAAA,eAAe,GAAG;AAChB,SAAKC,YAAL,GAAoBtD,IAAI,EAAxB;AACA,SAAKW,UAAL,CAAgB4C,IAAhB,CAAqB,KAAKD,YAA1B;AACD;;AAEDE,EAAAA,eAAe,GAAG;AAChB,UAAMC,KAAK,GAAG,KAAKH,YAAL,CAAkBG,KAAlB,CAAwB,GAAxB,CAAd;AACA,WAAOA,KAAK,CAACC,IAAN,CAAW,GAAX,CAAP;AACD;;AAEDC,EAAAA,aAAa,CAACC,KAAD,EAAQ;AACnB,QAAI,KAAK7B,YAAL,KAAsB,IAA1B,EAAgC;AAC9B,UAAI6B,KAAJ,EAAW;AACTC,QAAAA,YAAY,CAAC,KAAK7C,SAAN,CAAZ;AACD,OAFD,MAEO,IAAI,KAAKE,WAAT,EAAsB;AAC3B2C,QAAAA,YAAY,CAAC,KAAK7C,SAAN,CAAZ;AACA,aAAKA,SAAL,GAAiB8C,UAAU,CAAC,MAAM;AAChC,eAAKC,eAAL;AACD,SAF0B,EAExB,KAAK9C,YAFmB,CAA3B;AAGD;AACF;AACF;;AAED+C,EAAAA,KAAK,CAACC,aAAD,EAAgB;AACnB,SAAKhC,SAAL,GAAiB,CAAC,KAAKA,SAAvB;AACA,SAAK0B,aAAL;AACA,SAAKN,eAAL;AACA,SAAKrB,CAAL,GAAS,IAAI,KAAKvB,IAAT,CAAcwD,aAAd,CAAT;AACA,UAAMC,MAAM,GAAG,KAAKV,eAAL,EAAf;AACA,SAAK3C,cAAL,CAAoBqD,MAApB,IAA8B,KAA9B;AACA,SAAKlC,CAAL,CAAOmC,cAAP,GAAwBD,MAAxB;AACA,SAAKxD,YAAL,CAAkBwD,MAAlB,IAA4B,KAAKlC,CAAjC;AACA,SAAKA,CAAL,CAAOoC,EAAP,CAAU,KAAK7C,SAAL,CAAe8C,KAAzB,EAAgC,KAAKC,OAAL,CAAaC,IAAb,CAAkB,IAAlB,EAAwBL,MAAxB,CAAhC;AACA,SAAKlC,CAAL,CAAOoC,EAAP,CAAU,KAAK7C,SAAL,CAAeiD,OAAzB,EAAkC,KAAKC,SAAL,CAAeF,IAAf,CAAoB,IAApB,EAA0BL,MAA1B,CAAlC;AACA,SAAKlC,CAAL,CAAOoC,EAAP,CAAU,KAAK7C,SAAL,CAAemD,KAAzB,EAAgC,KAAKC,OAAL,CAAaJ,IAAb,CAAkB,IAAlB,EAAwBL,MAAxB,CAAhC;AACA,SAAKlC,CAAL,CAAOoC,EAAP,CAAU,KAAK7C,SAAL,CAAemB,IAAzB,EAA+B,KAAKkC,MAAL,CAAYL,IAAZ,CAAiB,IAAjB,EAAuBL,MAAvB,CAA/B;AACA,SAAKlC,CAAL,CAAOoC,EAAP,CAAU,KAAK7C,SAAL,CAAesD,MAAzB,EAAiC,KAAKC,cAAL,CAAoBP,IAApB,CAAyB,IAAzB,CAAjC;AACArE,IAAAA,KAAK,CAAE,mBAAkB,KAAK8B,CAAL,CAAOmC,cAAe,EAA1C,CAAL;;AACA,SAAKnC,CAAL,CAAO+C,GAAP,CAAWC,gBAAX,CACE,0BADF,EAEE,KAAKC,mBAAL,CAAyBV,IAAzB,CAA8B,IAA9B,EAAoCL,MAApC,CAFF;AAID;;AAEDO,EAAAA,SAAS,CAACP,MAAD,EAAS;AAChBhE,IAAAA,KAAK,CAAC,WAAD,EAAcgE,MAAd,CAAL;AACA,SAAK9C,SAAL,GAAiB,IAAjB;AACA,SAAKuB,IAAL,CAAU,SAAV,EAAqBuB,MAArB;AACA,SAAKhC,sBAAL;AACD;;AAED4C,EAAAA,cAAc,CAACpC,IAAD,EAAO;AACnB,QAAI,KAAKT,SAAT,EAAoB;AAClB,WAAKA,SAAL,GAAiB,CAAC,KAAKA,SAAvB;AACA,QAAE,KAAKlB,UAAP;AACAb,MAAAA,KAAK,CAAC,8BAAD,CAAL;AACA,WAAKyC,IAAL,CAAU,QAAV,EAAoBD,IAApB;AACD;AACF;;AAEDwC,EAAAA,aAAa,CAACC,cAAD,EAAiBjB,MAAjB,EAAyB;AACpChE,IAAAA,KAAK,CAAC,6BAAD,EAAgC,KAAK6B,YAArC,CAAL;AACA,SAAK4B,aAAL;;AACA,QAAI,KAAKxC,UAAL,IAAmB,KAAKY,YAAL,KAAsB,IAA7C,EAAmD;AACjD,WAAKjB,eAAL,CAAqByC,IAArB,CAA0B4B,cAA1B;;AACA,UAAI,KAAKnE,SAAL,KAAmB,IAAvB,EAA6B;AAC3B,cAAMoE,KAAK,GAAG,IAAd;;AACA,aAAKpE,SAAL,GAAiB8C,UAAU,CAAC,KAAKuB,iBAAL,CAAuBd,IAAvB,CAA4Ba,KAA5B,CAAD,EAAqC,IAArC,CAA3B;AACD;AACF,KAND,MAMO,IAAI,KAAKjE,UAAL,IAAmB,KAAKY,YAAL,KAAsB,IAA7C,EAAmD;AACxD,WAAKb,WAAL,GAAmB,KAAnB;;AACA,UAAI,KAAKF,SAAL,KAAmB,IAAvB,EAA6B;AAC3B6C,QAAAA,YAAY,CAAC,KAAK7C,SAAN,CAAZ;AACD;;AACDd,MAAAA,KAAK,CAAC,sBAAD,CAAL;AACAA,MAAAA,KAAK,CAAE,mBAAkB,KAAK8B,CAAL,CAAOmC,cAAe,EAA1C,CAAL;;AACA,UAAI;AACF,aAAKnC,CAAL,CAAO6C,MAAP,CAAcM,cAAd;AACAjF,QAAAA,KAAK,CAAC,sCAAD,CAAL;AACD,OAHD,CAGE,OAAOoF,CAAP,EAAU;AACV;AACAC,QAAAA,OAAO,CAAClB,KAAR,CAAciB,CAAd;AACD;AACF,KAdM,MAcA;AACLpF,MAAAA,KAAK,CAAC,sBAAD,EAAyB,KAAKW,cAA9B,CAAL;AACAX,MAAAA,KAAK,CAAE,mBAAkB,KAAK8B,CAAL,CAAOmC,cAAe,EAA1C,CAAL;;AACA,UAAI;AACF,aAAKtD,cAAL,CAAoB,KAAKmB,CAAL,CAAOmC,cAA3B,IAA6C,IAA7C;AACA,aAAKnC,CAAL,CAAO6C,MAAP,CAAcM,cAAd;AACAjF,QAAAA,KAAK,CAAC,sCAAD,CAAL;AACD,OAJD,CAIE,OAAOoF,CAAP,EAAU;AACV;AACAC,QAAAA,OAAO,CAAClB,KAAR,CAAciB,CAAd;AACD;AACF;AACF;;AAEDD,EAAAA,iBAAiB,GAAG;AAClB,UAAMF,cAAc,GAAG,KAAKrE,eAAL,CACrB,KAAKA,eAAL,CAAqB0E,MAArB,GAA8B,CADT,CAAvB;AAGAtF,IAAAA,KAAK,CAAC,0BAAD,EAA6B,KAAKW,cAAlC,CAAL;AACAX,IAAAA,KAAK,CAAE,mBAAkB,KAAK8B,CAAL,CAAOmC,cAAe,EAA1C,CAAL;;AACA,QAAI;AACF,WAAKtD,cAAL,CAAoB,KAAKmB,CAAL,CAAOmC,cAA3B,IAA6C,IAA7C;AACA,WAAKnC,CAAL,CAAO6C,MAAP,CAAcM,cAAd;AACAjF,MAAAA,KAAK,CAAC,sCAAD,CAAL;AACD,KAJD,CAIE,OAAOoF,CAAP,EAAU;AACV;AACAC,MAAAA,OAAO,CAAClB,KAAR,CAAciB,CAAd;AACD;AACF,GAhM+D,CAkMhE;AAEA;;;AACAG,EAAAA,uBAAuB,CAACC,MAAD,EAAS;AAC9BxF,IAAAA,KAAK,CAACwF,MAAD,CAAL;AACA,SAAKC,iBAAL,GAAyB,KAAzB;AACD,GAxM+D,CA0MhE;AACA;;;AACA5B,EAAAA,eAAe,GAAG;AAChB3D,IAAAA,WAAW,CAAC,qBAAD,CAAX;AACA,SAAKoC,cAAL,CAAoB,KAAKb,SAAL,CAAeiE,aAAnC;;AACA,QAAI,CAAC,KAAKzE,UAAN,IAAoB,KAAKY,YAAL,KAAsB,IAA9C,EAAoD;AAClD3B,MAAAA,WAAW,CAAC,cAAD,CAAX;AACA,WAAKe,UAAL,GAAkB,IAAlB;;AACA,UAAI;AACF,aAAK0E,WAAL;AACA,aAAKrD,cAAL,CAAoB,KAAKb,SAAL,CAAeiE,aAAnC;AACD,OAHD,CAGE,OAAON,CAAP,EAAU;AACV;AACAC,QAAAA,OAAO,CAAClB,KAAR,CAAciB,CAAd;AACD;AACF;;AACD,SAAKnE,UAAL,GAAkB,IAAlB;AACD;;AAED2E,EAAAA,SAAS,CAACC,MAAD,EAAS;AAChB7F,IAAAA,KAAK,CAAC,YAAD,CAAL;AACA,SAAKiB,UAAL,GAAkB,IAAlB;AACA,SAAKN,cAAL,CAAoBkF,MAApB,IAA8B,KAA9B;AACD;;AAEDF,EAAAA,WAAW,GAAG;AACZ,QAAI,CAAC,KAAKzE,SAAV,EAAqB;AACnB,WAAKuB,IAAL,CAAU,aAAV,EAAyB,KAAKb,iBAA9B;AACD;AACF,GAvO+D,CAyOhE;AACA;;;AACAkE,EAAAA,SAAS,CAACtD,IAAD,EAAO;AACd,SAAKvB,UAAL,GAAkB,IAAlB;AACA,SAAK8E,YAAL,CAAkBvD,IAAlB;AACD,GA9O+D,CAgPhE;;;AAEAuC,EAAAA,mBAAmB,CAACf,MAAD,EAASgC,GAAT,EAAc;AAC/B;AACA,QAAI,OAAOC,IAAP,KAAgB,WAApB,EAAiC;AAC/B;AACAjG,MAAAA,KAAK,CAAE,uBAAsBgG,GAAG,CAACE,MAAJ,CAAWvE,kBAAmB,EAAtD,CAAL;AACA1B,MAAAA,SAAS,CAAC,iBAAD,EAAoB,KAAKQ,UAAzB,CAAT;AACAR,MAAAA,SAAS,CAAC,QAAD,EAAW+D,MAAX,CAAT;;AACA,UACEgC,GAAG,CAACE,MAAJ,CAAWvE,kBAAX,KAAkC,WAAlC,IACAqE,GAAG,CAACE,MAAJ,CAAWvE,kBAAX,KAAkC,WAFpC,EAGE;AACA,YAAI,KAAKwE,KAAT,EAAgB;AACdxC,UAAAA,YAAY,CAAC,KAAKwC,KAAN,CAAZ;AACD;;AACD,YAAI,CAAC,KAAKjF,SAAV,EAAqB;AACnB,eAAKA,SAAL,GAAiB,IAAjB;AACA,eAAKoB,cAAL,CAAoB,KAAKb,SAAL,CAAe2E,iBAAnC;AACD;AACF;;AACD,UACE,CAACJ,GAAG,CAACE,MAAJ,CAAWvE,kBAAX,KAAkC,QAAlC,IACCqE,GAAG,CAACE,MAAJ,CAAWvE,kBAAX,KAAkC,cADpC,KAEA,CAAC,KAAK0E,YAHR,EAIE;AACA,aAAKA,YAAL,GAAoB,IAApB;AACA,aAAKV,WAAL;AACD;AACF;AACF,GA9Q+D,CAgRhE;AACA;AACA;;;AACA,QAAMjB,MAAN,CAAaV,MAAb,EAAqBxB,IAArB,EAA2B;AACzBxC,IAAAA,KAAK,CAAC,eAAD,CAAL;AACAC,IAAAA,SAAS,CAAC,QAAD,EAAW+D,MAAX,CAAT;AACA,SAAKP,aAAL;AAEA,SAAKhB,IAAL,CAAU,MAAV,EAAkBD,IAAlB;;AACA,QAAI;AACF,UAAI8D,aAAJ;;AACA,UAAI,KAAKC,MAAL,CAAY/D,IAAZ,CAAJ,EAAuB;AACrB8D,QAAAA,aAAa,GAAG,MAAM,KAAKhG,SAAL,CAAekG,OAAf,CACpBC,IAAI,CAACC,KAAL,CAAWlE,IAAI,CAACmE,QAAL,EAAX,CADoB,CAAtB;AAGD,OAJD,MAIO;AACLL,QAAAA,aAAa,GAAG,MAAM,KAAKhG,SAAL,CAAekG,OAAf,CACpBC,IAAI,CAACC,KAAL,CAAWlE,IAAI,CAACmE,QAAL,EAAX,CADoB,CAAtB;AAGD;;AACD,UAAI,KAAKJ,MAAL,CAAYD,aAAZ,CAAJ,EAAgC;AAC9B,cAAMM,MAAM,GAAGH,IAAI,CAACC,KAAL,CAAWJ,aAAX,CAAf;AACA,aAAK7D,IAAL,CAAU,MAAV,EAAkB;AAAEoE,UAAAA,IAAI,EAAED,MAAM,CAACC,IAAf;AAAqBrE,UAAAA,IAAI,EAAEoE,MAAM,CAACpE,IAAlC;AAAwCH,UAAAA,EAAE,EAAEuE,MAAM,CAACvE;AAAnD,SAAlB;AACD,OAHD,MAGO;AACL,aAAKI,IAAL,CAAU,MAAV,EAAkB;AAChBoE,UAAAA,IAAI,EAAEP,aAAa,CAACO,IADJ;AAEhBrE,UAAAA,IAAI,EAAE8D,aAAa,CAAC9D,IAFJ;AAGjBH,UAAAA,EAAE,EAAEiE,aAAa,CAACjE;AAHD,SAAlB;AAKD;AACF,KArBD,CAqBE,OAAO+C,CAAP,EAAU;AACVjF,MAAAA,MAAM,CAACgE,KAAP,CAAaiB,CAAb;AACApF,MAAAA,KAAK,CAAC,qBAAD,EAAwBwC,IAAxB,CAAL;AACAxC,MAAAA,KAAK,CAAC,gCAAD,EAAmCwC,IAAI,CAACmE,QAAL,EAAnC,CAAL;AACD;AACF;;AAEDlC,EAAAA,OAAO,CAACT,MAAD,EAASxB,IAAT,EAAe;AACpBtC,IAAAA,WAAW,CAAC,oBAAD,CAAX;AACAF,IAAAA,KAAK,CAAC,QAAD,EAAWgE,MAAX,CAAL;;AACA,QAAI,CAAC,KAAK/B,OAAL,EAAL,EAAqB;AACnB/B,MAAAA,WAAW,CAAC,YAAD,EAAesC,IAAf,CAAX;;AACA,UAAI,KAAKtB,SAAT,EAAoB;AAClB,aAAKoB,cAAL,CAAoB,KAAKb,SAAL,CAAeqF,cAAnC;AACA,aAAKxE,cAAL,CAAoB,KAAKb,SAAL,CAAesF,YAAnC;AACA,aAAK7F,SAAL,GAAiB,KAAjB;AACD,OAJD,MAIO;AACL,aAAKA,SAAL,GAAiB,KAAjB;AACD;AACF;AACF;;AAEDkD,EAAAA,OAAO,CAACJ,MAAD,EAASgD,GAAT,EAAc;AACnB9G,IAAAA,WAAW,CAAC,oBAAD,CAAX;AACAF,IAAAA,KAAK,CAAC,QAAD,EAAWgE,MAAX,CAAL;AACAhE,IAAAA,KAAK,CAACgH,GAAG,CAACC,IAAL,CAAL;AACAjH,IAAAA,KAAK,CAAC,OAAD,EAAUgH,GAAV,CAAL;;AACA,QAAI,CAAC,KAAK9F,SAAN,IAAmB,CAAC,KAAKD,UAAzB,IAAuC,CAAC,KAAKoF,YAAjD,EAA+D;AAC7D,WAAKV,WAAL;AACD,KAFD,MAEO;AACL,UAAI,CAAC,KAAK1D,OAAL,EAAL,EAAqB;AACnB,aAAKK,cAAL,CAAoB,KAAKb,SAAL,CAAeyF,aAAnC;AACD;AACF;AACF,GAhV+D,CAkVhE;;;AAEAC,EAAAA,qBAAqB,CAACN,IAAD,EAAOO,GAAP,EAAY/E,EAAZ,EAAgB;AACnC,WAAO,MAAM;AACXrC,MAAAA,KAAK,CAAE,qCAAoC6G,IAAK,gBAAeO,GAAI,EAA9D,CAAL;AACA,WAAKC,OAAL,CAAaZ,IAAI,CAACa,SAAL,CAAe;AAAET,QAAAA,IAAF;AAAQrE,QAAAA,IAAI,EAAE4E,GAAd;AAAmB/E,QAAAA;AAAnB,OAAf,CAAb;AACD,KAHD;AAID;;AAEDkF,EAAAA,cAAc,CAACV,IAAD,EAAOO,GAAP,EAAY/E,EAAZ,EAAgB;AAC5BrC,IAAAA,KAAK,CAACoH,GAAD,CAAL;AACApH,IAAAA,KAAK,CAAE,6BAA4B6G,IAAK,gBAAeO,GAAI,SAAQ/E,EAAG,EAAjE,CAAL;AACA,SAAKgF,OAAL,CAAaZ,IAAI,CAACa,SAAL,CAAe;AAAET,MAAAA,IAAF;AAAQrE,MAAAA,IAAI,EAAE4E,GAAd;AAAmB/E,MAAAA;AAAnB,KAAf,CAAb;AACD;;AAEDmF,EAAAA,oBAAoB,GAAG;AACrB,WAAO,MAAM;AACXtH,MAAAA,WAAW,CAAC,wBAAD,CAAX;AACA,WAAKgB,SAAL,GAAiB,KAAjB;AACA,WAAKoB,cAAL,CAAoB,KAAKb,SAAL,CAAegG,kBAAnC;AACA,WAAKvE,UAAL;AACA,WAAKwE,QAAL,GAAgB,IAAhB;AACD,KAND;AAOD;;AAEDC,EAAAA,aAAa,GAAG;AACdzH,IAAAA,WAAW,CAAC,gBAAD,CAAX;AACA,SAAKgB,SAAL,GAAiB,KAAjB;AACA,SAAKoB,cAAL,CAAoB,KAAKb,SAAL,CAAegG,kBAAnC;AACA,SAAKvE,UAAL;AACA,SAAKwE,QAAL,GAAgB,IAAhB;AACD;;AAED,QAAML,OAAN,CAAcO,GAAd,EAAmB;AACjB5H,IAAAA,KAAK,CAAC,KAAKiC,OAAL,EAAD,CAAL,CADiB,CACM;;AACvB,QAAI,KAAKA,OAAL,EAAJ,EAAoB;AAClB,UAAI4F,aAAJ;;AACA,UAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;AAC3BC,QAAAA,aAAa,GAAG,MAAM,KAAKvH,SAAL,CAAewH,OAAf,CAAuBF,GAAvB,CAAtB;AACD,OAFD,MAEO;AACLC,QAAAA,aAAa,GAAG,MAAM,KAAKvH,SAAL,CAAewH,OAAf,CAAuBrB,IAAI,CAACa,SAAL,CAAeM,GAAf,CAAvB,CAAtB;AACD;;AACD5H,MAAAA,KAAK,CAAC,aAAD,CAAL;AACA,WAAK8B,CAAL,CAAOiG,IAAP,CAAYtB,IAAI,CAACa,SAAL,CAAeO,aAAf,CAAZ;AACD,KATD,MASO;AACL;AACA,WAAKvF,cAAL,CAAoB,KAAKb,SAAL,CAAeuG,yBAAnC;AACA,aAAO,KAAP;AACD;AACF;;AAED9E,EAAAA,UAAU,GAAG;AACXlD,IAAAA,KAAK,CAAC,YAAD,CAAL,CADW,CACU;;AACrB,QAAI,KAAKiC,OAAL,EAAJ,EAAoB;AAClB,WAAKH,CAAL,CAAOmG,OAAP;AACAjI,MAAAA,KAAK,CAAC,WAAD,CAAL,CAFkB,CAEE;;AACpB,WAAKkB,SAAL,GAAiB,KAAjB;AACA,WAAKoB,cAAL,CAAoB,KAAKb,SAAL,CAAeyG,iBAAnC;AACD,KALD,MAKO,IAAI,CAAC,KAAKpG,CAAL,CAAOI,SAAZ,EAAuB;AAC5B,UAAI;AACF,aAAKJ,CAAL,CAAOmG,OAAP;AACD,OAFD,CAEE,OAAO7C,CAAP,EAAU;AACV;AACAC,QAAAA,OAAO,CAAClB,KAAR,CAAciB,CAAd;AACD;AACF;AACF;;AApZ+D","sourcesContent":["/* eslint-disable */\nimport createLogger from 'logging';\nimport debugLogger from 'debug';\n\nimport SimplePeer from 'simple-peer';\nimport { isBrowser } from 'browser-or-node';\n\nimport uuid from 'uuid/v4';\nimport MewConnectCommon from './MewConnectCommon';\n\nconst debug = debugLogger('MEWconnect:webRTC-communication');\nconst debugPeer = debugLogger('MEWconnectVerbose:peer-instances');\nconst debugStages = debugLogger('MEWconnect:peer-stages');\nconst logger = createLogger('WebRtcCommunication');\n\nexport default class WebRtcCommunication extends MewConnectCommon {\n  constructor(mewCrypto) {\n    super();\n    this.Peer = SimplePeer;\n    this.mewCrypto = mewCrypto;\n    this.peersCreated = {};\n    this.allPeerIds = [];\n    this.iceState = '';\n    this.answerReceived = {};\n    this.answersReceived = [];\n    this.offersSent = -1;\n    this.turnTimer = null;\n    this.turnWaitTime = 5000;\n    this.enableTimer = true;\n    this.tryingTurn = false;\n    this.connected = false;\n\n    this.signals = this.jsonDetails.signals;\n    this.rtcEvents = this.jsonDetails.rtc;\n    this.version = this.jsonDetails.version;\n    this.versions = this.jsonDetails.versions;\n    this.lifeCycle = this.jsonDetails.lifeCycle;\n    this.iceStates = this.jsonDetails.iceConnectionState;\n    this.activeInitiatorId = null;\n    this.usingVersion = '';\n    this.p = null;\n    this.canSignal = false;\n  }\n\n  clearExtraOnConnection() {\n    this.peersCreated = {};\n    this.allPeerIds = [];\n    this.answerReceived = {};\n    this.answersReceived = [];\n  }\n\n  isAlive() {\n    if (this.p !== null) {\n      return this.p.connected && !this.p.destroyed;\n    }\n    return false;\n  }\n\n  setConnectionVersion(version) {\n    this.usingVersion = version;\n  }\n\n  setActiveInitiatorId(id){\n    this.activeInitiatorId = id;\n  }\n\n  // can be used to listen to specific events, especially those that pass data\n  uiCommunicator(event, data) {\n    debug(event, data);\n    this.emit(event, data);\n    this.emitStatus(event);\n  }\n\n  // special status emitter to allow simple listening of various statuses in one listener\n  emitStatus(event) {\n    this.emit('status', event);\n  }\n\n  // Check if a WebRTC connection exists before a window/tab is closed or refreshed\n  // Destroy the connection if one exists\n  destroyOnUnload() {\n    if (isBrowser) {\n      // eslint-disable-next-line no-undef\n      window.onunload = window.onbeforeunload = () => {\n        const iceStates = [\n          this.iceStates.new,\n          this.iceStates.connecting,\n          this.iceStates.connected\n        ];\n        if (!this.Peer.destroyed || iceStates.includes(this.iceState)) {\n          this.rtcDestroy();\n        }\n      };\n    }\n  }\n\n  setActivePeerId() {\n    this.activePeerId = uuid();\n    this.allPeerIds.push(this.activePeerId);\n  }\n\n  getActivePeerId() {\n    const split = this.activePeerId.split('-');\n    return split.join('-');\n  }\n\n  fallbackTimer(clear) {\n    if (this.usingVersion === 'V2') {\n      if (clear) {\n        clearTimeout(this.turnTimer);\n      } else if (this.enableTimer) {\n        clearTimeout(this.turnTimer);\n        this.turnTimer = setTimeout(() => {\n          this.willAttemptTurn();\n        }, this.turnWaitTime);\n      }\n    }\n  }\n\n  start(simpleOptions) {\n    this.canSignal = !this.canSignal;\n    this.fallbackTimer();\n    this.setActivePeerId();\n    this.p = new this.Peer(simpleOptions);\n    const peerID = this.getActivePeerId();\n    this.answerReceived[peerID] = false;\n    this.p.peerInstanceId = peerID;\n    this.peersCreated[peerID] = this.p;\n    this.p.on(this.rtcEvents.error, this.onError.bind(this, peerID));\n    this.p.on(this.rtcEvents.connect, this.onConnect.bind(this, peerID));\n    this.p.on(this.rtcEvents.close, this.onClose.bind(this, peerID));\n    this.p.on(this.rtcEvents.data, this.onData.bind(this, peerID));\n    this.p.on(this.rtcEvents.signal, this.signalListener.bind(this));\n    debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n    this.p._pc.addEventListener(\n      'iceconnectionstatechange',\n      this.stateChangeListener.bind(this, peerID)\n    );\n  }\n\n  onConnect(peerID) {\n    debug('onConnect', peerID);\n    this.connected = true;\n    this.emit('connect', peerID);\n    this.clearExtraOnConnection();\n  }\n\n  signalListener(data) {\n    if (this.canSignal) {\n      this.canSignal = !this.canSignal;\n      ++this.offersSent;\n      debug('webRTC setup signal received');\n      this.emit('signal', data);\n    }\n  }\n\n  receiveAnswer(plainTextOffer, peerID) {\n    debug('receiveAnswer for version: ', this.usingVersion);\n    this.fallbackTimer();\n    if (this.tryingTurn && this.usingVersion === 'V1') {\n      this.answersReceived.push(plainTextOffer);\n      if (this.turnTimer === null) {\n        const _self = this;\n        this.turnTimer = setTimeout(this.receiveTurnAnswer.bind(_self), 1000);\n      }\n    } else if (this.tryingTurn && this.usingVersion === 'V2') {\n      this.enableTimer = false;\n      if (this.turnTimer !== null) {\n        clearTimeout(this.turnTimer);\n      }\n      debug('webRtc receiveAnswer');\n      debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n      try {\n        this.p.signal(plainTextOffer);\n        debug('webRTC answer received and processed');\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    } else {\n      debug('webRtc receiveAnswer', this.answerReceived);\n      debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n      try {\n        this.answerReceived[this.p.peerInstanceId] = true;\n        this.p.signal(plainTextOffer);\n        debug('webRTC answer received and processed');\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    }\n  }\n\n  receiveTurnAnswer() {\n    const plainTextOffer = this.answersReceived[\n      this.answersReceived.length - 1\n    ];\n    debug('webRtc receiveTurnAnswer', this.answerReceived);\n    debug(`active PEER_ID: ${this.p.peerInstanceId}`);\n    try {\n      this.answerReceived[this.p.peerInstanceId] = true;\n      this.p.signal(plainTextOffer);\n      debug('webRTC answer received and processed');\n    } catch (e) {\n      // eslint-disable-next-line\n      console.error(e);\n    }\n  }\n\n  // ----- Socket Event handlers\n\n  // Handle Socket Disconnect Event\n  socketDisconnectHandler(reason) {\n    debug(reason);\n    this.socketV1Connected = false;\n  }\n\n  // Handle Socket Attempting Turn informative signal\n  // Provide Notice that initial WebRTC connection failed and the fallback method will be used\n  willAttemptTurn() {\n    debugStages('TRY TURN CONNECTION');\n    this.uiCommunicator(this.lifeCycle.UsingFallback);\n    if (!this.tryingTurn && this.usingVersion === 'V2') {\n      debugStages(' TRY TURN V2');\n      this.tryingTurn = true;\n      try {\n        this.useFallback();\n        this.uiCommunicator(this.lifeCycle.UsingFallback);\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    }\n    this.tryingTurn = true;\n  }\n\n  turnReset(peerId) {\n    debug('TURN_RESET');\n    this.tryingTurn = true;\n    this.answerReceived[peerId] = false;\n  }\n\n  useFallback() {\n    if (!this.connected) {\n      this.emit('useFallback', this.activeInitiatorId);\n    }\n  }\n\n  // Handle Socket event to initiate turn connection\n  // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN\n  beginTurn(data) {\n    this.tryingTurn = true;\n    this.retryViaTurn(data);\n  }\n\n  // ----- Failure Handlers\n\n  stateChangeListener(peerID, evt) {\n    // eslint-disable-next-line no-undef\n    if (typeof jest === 'undefined') {\n      // included because target is not defined in jest\n      debug(`iceConnectionState: ${evt.target.iceConnectionState}`);\n      debugPeer('this.allPeerIds', this.allPeerIds);\n      debugPeer('peerID', peerID);\n      if (\n        evt.target.iceConnectionState === 'connected' ||\n        evt.target.iceConnectionState === 'completed'\n      ) {\n        if (this.timer) {\n          clearTimeout(this.timer);\n        }\n        if (!this.connected) {\n          this.connected = true;\n          this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);\n        }\n      }\n      if (\n        (evt.target.iceConnectionState === 'failed' ||\n          evt.target.iceConnectionState === 'disconnected') &&\n        !this.turnDisabled\n      ) {\n        this.turnDisabled = true;\n        this.useFallback();\n      }\n    }\n  }\n\n  // =========================================================\n  // =========================================================\n  // =========================================================\n  async onData(peerID, data) {\n    debug('DATA RECEIVED');\n    debugPeer('peerID', peerID);\n    this.fallbackTimer();\n\n    this.emit('data', data);\n    try {\n      let decryptedData;\n      if (this.isJSON(data)) {\n        decryptedData = await this.mewCrypto.decrypt(\n          JSON.parse(data.toString())\n        );\n      } else {\n        decryptedData = await this.mewCrypto.decrypt(\n          JSON.parse(data.toString())\n        );\n      }\n      if (this.isJSON(decryptedData)) {\n        const parsed = JSON.parse(decryptedData);\n        this.emit('data', { type: parsed.type, data: parsed.data, id: parsed.id });\n      } else {\n        this.emit('data', {\n          type: decryptedData.type,\n          data: decryptedData.data,\n         id: decryptedData.id\n        });\n      }\n    } catch (e) {\n      logger.error(e);\n      debug('onData ERROR: data=', data);\n      debug('onData ERROR: data.toString()=', data.toString());\n    }\n  }\n\n  onClose(peerID, data) {\n    debugStages('WRTC onClose event');\n    debug('peerID', peerID);\n    if (!this.isAlive()) {\n      debugStages('WRTC CLOSE', data);\n      if (this.connected) {\n        this.uiCommunicator(this.lifeCycle.RtcClosedEvent);\n        this.uiCommunicator(this.lifeCycle.disconnected);\n        this.connected = false;\n      } else {\n        this.connected = false;\n      }\n    }\n  }\n\n  onError(peerID, err) {\n    debugStages('WRTC onError event');\n    debug('peerID', peerID);\n    debug(err.code);\n    debug('error', err);\n    if (!this.connected && !this.tryingTurn && !this.turnDisabled) {\n      this.useFallback();\n    } else {\n      if (!this.isAlive()) {\n        this.uiCommunicator(this.lifeCycle.RtcErrorEvent);\n      }\n    }\n  }\n\n  // ----- WebRTC Communication Methods\n\n  sendRtcMessageClosure(type, msg, id) {\n    return () => {\n      debug(`[SEND RTC MESSAGE Closure] type:  ${type},  message:  ${msg}`);\n      this.rtcSend(JSON.stringify({ type, data: msg, id }));\n    };\n  }\n\n  sendRtcMessage(type, msg, id) {\n    debug(msg);\n    debug(`[SEND RTC MESSAGE] type:  ${type},  message:  ${msg}, id: ${id}`);\n    this.rtcSend(JSON.stringify({ type, data: msg, id }));\n  }\n\n  disconnectRTCClosure() {\n    return () => {\n      debugStages('DISCONNECT RTC Closure');\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n      this.rtcDestroy();\n      this.instance = null;\n    };\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.rtcDestroy();\n    this.instance = null;\n  }\n\n  async rtcSend(arg) {\n    debug(this.isAlive()); // todo remove dev item\n    if (this.isAlive()) {\n      let encryptedSend;\n      if (typeof arg === 'string') {\n        encryptedSend = await this.mewCrypto.encrypt(arg);\n      } else {\n        encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(arg));\n      }\n      debug('SENDING RTC');\n      this.p.send(JSON.stringify(encryptedSend));\n    } else {\n      // eslint-disable-next-line\n      this.uiCommunicator(this.lifeCycle.attemptedDisconnectedSend);\n      return false;\n    }\n  }\n\n  rtcDestroy() {\n    debug('rtcDestroy'); // todo remove dev item\n    if (this.isAlive()) {\n      this.p.destroy();\n      debug('DESTROYED'); // todo remove dev item\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);\n    } else if (!this.p.destroyed) {\n      try {\n        this.p.destroy();\n      } catch (e) {\n        // eslint-disable-next-line\n        console.error(e);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}