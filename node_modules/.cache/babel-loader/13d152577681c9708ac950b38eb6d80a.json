{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar BufferUtil = require('../util/buffer');\n\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\n\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\n\nPoint.fromX = function fromX(odd, x) {\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n\n  point.validate();\n  return point;\n};\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\n\n\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\n\n\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nif (!Point.prototype._getX) Point.prototype._getX = Point.prototype.getX;\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\n\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nif (!Point.prototype._getY) Point.prototype._getY = Point.prototype.getY;\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\n\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\n\n\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  } //todo: needs test case\n\n\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n\n  return BufferUtil.concat([prefix, xbuf]);\n}; // todo: needs test case\n\n\nPoint.prototype.hasSquare = function () {\n  return !this.isInfinity() && this.isSquare(this.getY());\n}; // todo: needs test cases\n\n\nPoint.prototype.isSquare = function (x) {\n  let p = new BN('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F', 'hex');\n  let x0 = new BN(x);\n  let base = x0.toRed(BN.red(p));\n  let res = base.redPow(p.sub(BN.One).div(new BN(2))).fromRed(); //refactor to BN arithmetic operations\n\n  return res.eq(new BN(1));\n};\n\nmodule.exports = Point;","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitcore-lib-cash/lib/crypto/point.js"],"names":["BN","require","BufferUtil","EC","ec","ecPoint","curve","point","bind","ecPointFromX","pointFromX","Point","x","y","isRed","e","Error","validate","prototype","Object","getPrototypeOf","fromX","odd","getG","g","getN","n","toArray","_getX","getX","_getY","getY","isInfinity","p2","isOdd","cmp","mul","pointToCompressed","xbuf","toBuffer","size","ybuf","prefix","length","Buffer","from","concat","hasSquare","isSquare","p","x0","base","toRed","red","res","redPow","sub","One","div","fromRed","eq","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\n\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nif (!Point.prototype._getX)\n  Point.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nif (!Point.prototype._getY)\n  Point.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\n// todo: needs test case\nPoint.prototype.hasSquare = function() {\n  return !this.isInfinity() && this.isSquare(this.getY());\n}\n\n// todo: needs test cases\nPoint.prototype.isSquare = function(x) {\n  let p = new BN('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F', 'hex');\n  let x0 = new BN(x);\n  let base = x0.toRed(BN.red(p));\n  let res = base.redPow(p.sub(BN.One).div(new BN(2))).fromRed(); //refactor to BN arithmetic operations\n  return res.eq(new BN(1));\n}\n\nmodule.exports = Point;\n"]},"metadata":{},"sourceType":"script"}