{"ast":null,"code":"'use strict'; // Copyright (c) 2018 Matias Alejo Garcia\n// Copyright (c) 2017 Emilio Almansi\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Converts an array of integers made up of `from` bits into an\n * array of integers made up of `to` bits. The output array is\n * zero-padded if necessary, unless strict mode is true.\n * Original by Pieter Wuille: https://github.com/sipa/bech32.\n *\n * @param {Array} data Array of integers made up of `from` bits.\n * @param {number} from Length in bits of elements in the input array.\n * @param {number} to Length in bits of elements in the output array.\n * @param {bool} strict Require the conversion to be completed without padding.\n */\n\nvar $ = require('./preconditions');\n\nmodule.exports = function (data, from, to, strict) {\n  strict = strict || false;\n  var accumulator = 0;\n  var bits = 0;\n  var result = [];\n  var mask = (1 << to) - 1;\n\n  for (var i = 0; i < data.length; i++) {\n    var value = data[i];\n    $.checkArgument(!(value < 0 || value >> from !== 0), 'value ' + value);\n    accumulator = accumulator << from | value;\n    bits += from;\n\n    while (bits >= to) {\n      bits -= to;\n      result.push(accumulator >> bits & mask);\n    }\n  }\n\n  if (!strict) {\n    if (bits > 0) {\n      result.push(accumulator << to - bits & mask);\n    }\n  } else {\n    $.checkState(!(bits >= from || accumulator << to - bits & mask), 'Conversion requires padding but strict mode was used');\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib-cash/lib/util/convertBits.js"],"names":["$","require","module","exports","data","from","to","strict","accumulator","bits","result","mask","i","length","value","checkArgument","push","checkState"],"mappings":"AAAA,a,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AAWA,IAAIA,CAAC,GAAGC,OAAO,CAAC,iBAAD,CAAf;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAASC,IAAT,EAAeC,IAAf,EAAqBC,EAArB,EAAyBC,MAAzB,EAAgC;AAC/CA,EAAAA,MAAM,GAAGA,MAAM,IAAI,KAAnB;AACA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,IAAI,GAAG,CAAC,KAAKL,EAAN,IAAY,CAAvB;;AACA,OAAK,IAAIM,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACR,IAAI,CAACS,MAArB,EAA6BD,CAAC,EAA9B,EAAkC;AAChC,QAAIE,KAAK,GAAGV,IAAI,CAACQ,CAAD,CAAhB;AACAZ,IAAAA,CAAC,CAACe,aAAF,CAAgB,EAAED,KAAK,GAAG,CAAR,IAAcA,KAAK,IAAIT,IAAV,KAAoB,CAAnC,CAAhB,EAAuD,WAAWS,KAAlE;AAEAN,IAAAA,WAAW,GAAIA,WAAW,IAAIH,IAAhB,GAAwBS,KAAtC;AACAL,IAAAA,IAAI,IAAIJ,IAAR;;AACA,WAAOI,IAAI,IAAIH,EAAf,EAAmB;AACjBG,MAAAA,IAAI,IAAIH,EAAR;AACAI,MAAAA,MAAM,CAACM,IAAP,CAAaR,WAAW,IAAIC,IAAhB,GAAwBE,IAApC;AACD;AACF;;AACD,MAAI,CAACJ,MAAL,EAAa;AACX,QAAIE,IAAI,GAAG,CAAX,EAAc;AACZC,MAAAA,MAAM,CAACM,IAAP,CAAaR,WAAW,IAAKF,EAAE,GAAGG,IAAtB,GAA+BE,IAA3C;AACD;AACF,GAJD,MAIO;AACNX,IAAAA,CAAC,CAACiB,UAAF,CAAa,EAAER,IAAI,IAAIJ,IAAR,IAAkBG,WAAW,IAAKF,EAAE,GAAGG,IAAtB,GAA+BE,IAAlD,CAAb,EAAwE,sDAAxE;AACA;;AACD,SAAOD,MAAP;AACD,CAzBD","sourcesContent":["'use strict';\n// Copyright (c) 2018 Matias Alejo Garcia\n// Copyright (c) 2017 Emilio Almansi\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Converts an array of integers made up of `from` bits into an\n * array of integers made up of `to` bits. The output array is\n * zero-padded if necessary, unless strict mode is true.\n * Original by Pieter Wuille: https://github.com/sipa/bech32.\n *\n * @param {Array} data Array of integers made up of `from` bits.\n * @param {number} from Length in bits of elements in the input array.\n * @param {number} to Length in bits of elements in the output array.\n * @param {bool} strict Require the conversion to be completed without padding.\n */\nvar $ = require('./preconditions');\n\nmodule.exports = function(data, from, to, strict){\n  strict = strict || false;\n  var accumulator = 0;\n  var bits = 0;\n  var result = [];\n  var mask = (1 << to) - 1;\n  for (var i=0; i<data.length; i++) {\n    var value = data[i];\n    $.checkArgument(!(value < 0 || (value >> from) !== 0), 'value ' + value);\n\n    accumulator = (accumulator << from) | value;\n    bits += from;\n    while (bits >= to) {\n      bits -= to;\n      result.push((accumulator >> bits) & mask);\n    }\n  }\n  if (!strict) {\n    if (bits > 0) {\n      result.push((accumulator << (to - bits)) & mask);\n    }\n  } else {\n   $.checkState(!(bits >= from || ((accumulator << (to - bits)) & mask)),  'Conversion requires padding but strict mode was used');\n  }\n  return result;\n};\n"]},"metadata":{},"sourceType":"script"}