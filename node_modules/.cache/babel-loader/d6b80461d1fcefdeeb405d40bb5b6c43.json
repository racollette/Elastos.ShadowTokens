{"ast":null,"code":"const BigInteger = require('bigi');\n\nconst ECPair = require('../ecpair');\n/**\n * Create an ECPair from the raw private key bytes\n * @param {Buffer} buffer - Private key for the ECPair. Must be exactly 32 bytes.\n * @param {Object} [network] - Network for the ECPair. Defaults to bitcoin.\n * @return {ECPair}\n */\n\n\nfunction privateKeyBufferToECPair(buffer, network) {\n  if (!Buffer.isBuffer(buffer) || buffer.length !== 32) {\n    throw new Error('invalid private key buffer');\n  }\n\n  const d = BigInteger.fromBuffer(buffer);\n  return new ECPair(d, null, {\n    network\n  });\n}\n/**\n * Get the private key as a 32 bytes buffer. If it is smaller than 32 bytes, pad it with zeros\n * @param {ECPair} ecPair\n * @return {Buffer} 32 bytes\n */\n\n\nfunction privateKeyBufferFromECPair(ecPair) {\n  if (!(ecPair instanceof ECPair)) {\n    throw new TypeError(`invalid argument ecpair`);\n  }\n\n  if (!ecPair.d) throw new Error('Missing private key');\n  return ecPair.d.toBuffer(32);\n}\n\nmodule.exports = {\n  privateKeyBufferToECPair,\n  privateKeyBufferFromECPair\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitgo-utxo-lib/src/bitgo/keyutil.js"],"names":["BigInteger","require","ECPair","privateKeyBufferToECPair","buffer","network","Buffer","isBuffer","length","Error","d","fromBuffer","privateKeyBufferFromECPair","ecPair","TypeError","toBuffer","module","exports"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,MAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;AAEA;;;;;;;;AAMA,SAASE,wBAAT,CAAmCC,MAAnC,EAA2CC,OAA3C,EAAoD;AAClD,MAAI,CAACC,MAAM,CAACC,QAAP,CAAgBH,MAAhB,CAAD,IAA4BA,MAAM,CAACI,MAAP,KAAkB,EAAlD,EAAsD;AACpD,UAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,QAAMC,CAAC,GAAGV,UAAU,CAACW,UAAX,CAAsBP,MAAtB,CAAV;AACA,SAAO,IAAIF,MAAJ,CAAWQ,CAAX,EAAc,IAAd,EAAoB;AAAEL,IAAAA;AAAF,GAApB,CAAP;AACD;AAED;;;;;;;AAKA,SAASO,0BAAT,CAAqCC,MAArC,EAA6C;AAC3C,MAAI,EAAEA,MAAM,YAAYX,MAApB,CAAJ,EAAiC;AAC/B,UAAM,IAAIY,SAAJ,CAAe,yBAAf,CAAN;AACD;;AAED,MAAI,CAACD,MAAM,CAACH,CAAZ,EAAe,MAAM,IAAID,KAAJ,CAAU,qBAAV,CAAN;AAEf,SAAOI,MAAM,CAACH,CAAP,CAASK,QAAT,CAAkB,EAAlB,CAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACfd,EAAAA,wBADe;AAEfS,EAAAA;AAFe,CAAjB","sourcesContent":["const BigInteger = require('bigi')\nconst ECPair = require('../ecpair')\n\n/**\n * Create an ECPair from the raw private key bytes\n * @param {Buffer} buffer - Private key for the ECPair. Must be exactly 32 bytes.\n * @param {Object} [network] - Network for the ECPair. Defaults to bitcoin.\n * @return {ECPair}\n */\nfunction privateKeyBufferToECPair (buffer, network) {\n  if (!Buffer.isBuffer(buffer) || buffer.length !== 32) {\n    throw new Error('invalid private key buffer')\n  }\n\n  const d = BigInteger.fromBuffer(buffer)\n  return new ECPair(d, null, { network })\n}\n\n/**\n * Get the private key as a 32 bytes buffer. If it is smaller than 32 bytes, pad it with zeros\n * @param {ECPair} ecPair\n * @return {Buffer} 32 bytes\n */\nfunction privateKeyBufferFromECPair (ecPair) {\n  if (!(ecPair instanceof ECPair)) {\n    throw new TypeError(`invalid argument ecpair`)\n  }\n\n  if (!ecPair.d) throw new Error('Missing private key')\n\n  return ecPair.d.toBuffer(32)\n}\n\nmodule.exports = {\n  privateKeyBufferToECPair,\n  privateKeyBufferFromECPair\n}\n"]},"metadata":{},"sourceType":"script"}