{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar errors = require('./errors');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Networks = require('./networks');\n\nvar Hash = require('./crypto/hash');\n\nvar JSUtil = require('./util/js');\n\nvar PublicKey = require('./publickey');\n\nvar BN = require('./crypto/bn');\n\nvar base32 = require('./util/base32');\n\nvar convertBits = require('./util/convertBits');\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\n * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash` and `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\n\n\nfunction Address(data, network, type) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\", \"testnet\", or \"regtest\".');\n  }\n\n  if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash) {\n    throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type); // set defaults if not set\n\n\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n  return this;\n}\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\n\n\nAddress.prototype._classifyArguments = function (data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n    return Address._transformHash(data);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof data === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n/** @static */\n\n\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\n\nAddress.PayToScriptHash = 'scripthash';\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\n\nAddress._transformHash = function (hash) {\n  var info = {};\n\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (hash.length !== 20) {\n    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n  }\n\n  info.hashBuffer = hash;\n  return info;\n};\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\n\n\nAddress._transformObject = function (data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\n\n\nAddress._classifyFromVersion = function (buffer) {\n  var version = {};\n  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n  if (pubkeyhashNetwork) {\n    version.network = pubkeyhashNetwork;\n    version.type = Address.PayToPublicKeyHash;\n  } else if (scripthashNetwork) {\n    version.network = scripthashNetwork;\n    version.type = Address.PayToScriptHash;\n  }\n\n  return version;\n};\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformBuffer = function (buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length !== 1 + 20) {\n    throw new TypeError('Address buffers must be exactly 21 bytes.');\n  }\n\n  var networkObj = Networks.get(network);\n\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || networkObj && networkObj !== bufferVersion.network) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || type && type !== bufferVersion.type) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  info.hashBuffer = buffer.slice(1);\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\n\n\nAddress._transformPublicKey = function (pubkey) {\n  var info = {};\n\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n\n  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  info.type = Address.PayToPublicKeyHash;\n  return info;\n};\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\n\n\nAddress._transformScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n\n  return info;\n};\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @return {Address}\n */\n\n\nAddress.createMultisig = function (publicKeys, threshold, network) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n};\n\nfunction decodeCashAddress(address) {\n  function hasSingleCase(string) {\n    var lowerCase = string.toLowerCase();\n    var upperCase = string.toUpperCase();\n    var hasSingleCase = string === lowerCase || string === upperCase;\n    return hasSingleCase;\n  }\n\n  function validChecksum(prefix, payload) {\n    function prefixToArray(prefix) {\n      var result = [];\n\n      for (var i = 0; i < prefix.length; i++) {\n        result.push(prefix.charCodeAt(i) & 31);\n      }\n\n      return result;\n    }\n\n    var prefixData = prefixToArray(prefix).concat([0]);\n    return polymod(prefixData.concat(payload)) === 0;\n  }\n\n  $.checkArgument(hasSingleCase(address), 'Mixed case');\n  address = address.toLowerCase();\n  var pieces = address.split(':');\n  $.checkArgument(pieces.length <= 2, 'Invalid format:' + address);\n  var prefix, encodedPayload;\n\n  if (pieces.length === 2) {\n    prefix = pieces[0];\n    encodedPayload = pieces[1];\n  } else {\n    prefix = null;\n    encodedPayload = pieces[0];\n  }\n\n  var payload = base32.decode(encodedPayload.toLowerCase());\n\n  if (prefix) {\n    $.checkArgument(validChecksum(prefix, payload), 'Invalid checksum:' + address);\n  } else {\n    var netNames = ['livenet', 'testnet', 'regtest'];\n    var i;\n\n    while (!prefix && (i = netNames.shift())) {\n      var p = Networks.get(i).prefix;\n\n      if (validChecksum(p, payload)) {\n        prefix = p;\n      }\n    }\n\n    $.checkArgument(prefix, 'Invalid checksum:' + address);\n  }\n\n  var convertedBits = convertBits(payload.slice(0, -8), 5, 8, true);\n  var versionByte = convertedBits.shift();\n  var hash = convertedBits;\n  $.checkArgument(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size:' + address);\n\n  function getType(versionByte) {\n    switch (versionByte & 120) {\n      case 0:\n        return 'pubkeyhash';\n\n      case 8:\n        return 'scripthash';\n\n      default:\n        throw new Error('Invalid address type in version byte:' + versionByte);\n    }\n  }\n\n  var type = getType(versionByte);\n  var network = Networks.get(prefix); //console.log('[address.js.336:network:]',network); //TODO\n\n  var info = {}; //return { prefix, type, hash };\n  //console.log('[address.js.339]', hash); //TODO\n\n  info.hashBuffer = Buffer.from(hash);\n  info.network = network;\n  info.type = type;\n  return info;\n}\n\nAddress._decodeCashAddress = decodeCashAddress;\n/**\n * Internal function to transform a bitcoin cash address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\nAddress._transformString = function (data, network, type) {\n  if (typeof data !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if (data.length < 34) {\n    throw new Error('Invalid Address string provided');\n  }\n\n  if (data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  data = data.trim();\n  var networkObj = Networks.get(network);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (data.length > 35) {\n    var info = decodeCashAddress(data);\n\n    if (!info.network || networkObj && networkObj.name !== info.network.name) {\n      throw new TypeError('Address has mismatched network type.');\n    }\n\n    if (!info.type || type && type !== info.type) {\n      throw new TypeError('Address has mismatched type.');\n    }\n\n    return info;\n  } else {\n    var addressBuffer = Base58Check.decode(data); // Legacy addr\n\n    return Address._transformBuffer(addressBuffer, network, type);\n  }\n};\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromPublicKey = function (data, network) {\n  var info = Address._transformPublicKey(data);\n\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromPublicKeyHash = function (hash, network) {\n  var info = Address._transformHash(hash);\n\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromScriptHash = function (hash, network) {\n  $.checkArgument(hash, 'hash parameter is required');\n\n  var info = Address._transformHash(hash);\n\n  return new Address(info.hashBuffer, network, Address.PayToScriptHash);\n};\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.payingTo = function (script, network) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n};\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n\n  var info = Address._transformScript(script, network);\n\n  return new Address(info.hashBuffer, network, info.type);\n};\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromBuffer = function (buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromString = function (str, network, type) {\n  var info = Address._transformString(str, network, type);\n\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\n\n\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(JSUtil.isHexa(obj.hash), 'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.');\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\n\n\nAddress.getValidationError = function (data, network, type) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\n\n\nAddress.isValid = function (data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToPublicKeyHash = function () {\n  return this.type === Address.PayToPublicKeyHash;\n};\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToScriptHash = function () {\n  return this.type === Address.PayToScriptHash;\n};\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\n\n\nAddress.prototype.toBuffer = function () {\n  var version = Buffer.from([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n/**\n * @returns {Object} A plain object with the address information\n */\n\n\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype.inspect = function () {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n/***\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n\nAddress.prototype.toCashBuffer = function () {\n  var version = Buffer.from([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n/**\n * Will return a the base58 (legacy) string representation of the address\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype.toLegacyAddress = function () {\n  return Base58Check.encode(this.toBuffer());\n};\n/**\n * Will return a cashaddr representation of the address. Always return lower case\n * Can be converted by the caller to uppercase is needed (still valid).\n *\n * @returns {string} Bitcoin Cash address\n */\n\n\nAddress.prototype.toCashAddress = function (stripPrefix) {\n  function getTypeBits(type) {\n    switch (type) {\n      case 'pubkeyhash':\n        return 0;\n\n      case 'scripthash':\n        return 8;\n\n      default:\n        throw new Error('Invalid type:' + type);\n    }\n  }\n\n  function getHashSizeBits(hash) {\n    switch (hash.length * 8) {\n      case 160:\n        return 0;\n\n      case 192:\n        return 1;\n\n      case 224:\n        return 2;\n\n      case 256:\n        return 3;\n\n      case 320:\n        return 4;\n\n      case 384:\n        return 5;\n\n      case 448:\n        return 6;\n\n      case 512:\n        return 7;\n\n      default:\n        throw new Error('Invalid hash size:' + hash.length);\n    }\n  }\n\n  var eight0 = [0, 0, 0, 0, 0, 0, 0, 0];\n  var prefixData = this.network.prefixArray.concat([0]);\n  var versionByte = getTypeBits(this.type) + getHashSizeBits(this.hashBuffer);\n  var arr = Array.prototype.slice.call(this.hashBuffer, 0);\n  var payloadData = convertBits([versionByte].concat(arr), 8, 5);\n  var checksumData = prefixData.concat(payloadData).concat(eight0);\n  var payload = payloadData.concat(checksumToArray(polymod(checksumData)));\n\n  if (stripPrefix === true) {\n    return base32.encode(payload);\n  } else {\n    return this.network.prefix + ':' + base32.encode(payload);\n  }\n};\n/**\n * Will return a string representation of the address (defaults to CashAddr format)\n *\n * @returns {string} address\n */\n\n\nAddress.prototype.toString = Address.prototype.toCashAddress;\n/***\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @param {number} versionByte\n */\n\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n    case 0:\n      return 160;\n\n    case 1:\n      return 192;\n\n    case 2:\n      return 224;\n\n    case 3:\n      return 256;\n\n    case 4:\n      return 320;\n\n    case 5:\n      return 384;\n\n    case 6:\n      return 448;\n\n    case 7:\n      return 512;\n  }\n}\n/***\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @param {number} checksum Computed checksum.\n */\n\n\nfunction checksumToArray(checksum) {\n  var result = [];\n\n  for (var i = 0; i < 8; ++i) {\n    result.push(checksum & 31);\n    checksum /= 32;\n  }\n\n  return result.reverse();\n}\n/***\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @param {Array} data Array of 5-bit integers over which the checksum is to be computed.\n */\n\n\nvar GENERATOR1 = [0x98, 0x79, 0xf3, 0xae, 0x1e];\nvar GENERATOR2 = [0xf2bc8e61, 0xb76d99e2, 0x3e5fb3c4, 0x2eabe2a8, 0x4f43e470];\n\nfunction polymod(data) {\n  // Treat c as 8 bits + 32 bits\n  var c0 = 0,\n      c1 = 1,\n      C = 0;\n\n  for (var j = 0; j < data.length; j++) {\n    // Set C to c shifted by 35\n    C = c0 >>> 3; // 0x[07]ffffffff\n\n    c0 &= 0x07; // Shift as a whole number\n\n    c0 <<= 5;\n    c0 |= c1 >>> 27; // 0xffffffff >>> 5\n\n    c1 &= 0x07ffffff;\n    c1 <<= 5; // xor the last 5 bits\n\n    c1 ^= data[j];\n\n    for (var i = 0; i < GENERATOR1.length; ++i) {\n      if (C & 1 << i) {\n        c0 ^= GENERATOR1[i];\n        c1 ^= GENERATOR2[i];\n      }\n    }\n  }\n\n  c1 ^= 1; // Negative numbers -> large positive numbers\n\n  if (c1 < 0) {\n    c1 ^= 1 << 31;\n    c1 += (1 << 30) * 2;\n  } // Unless bitwise operations are used,\n  // numbers are consisting of 52 bits, except\n  // the sign bit. The result is max 40 bits,\n  // so it fits perfectly in one number!\n\n\n  return c0 * (1 << 30) * 4 + c1;\n}\n\nmodule.exports = Address;\n\nvar Script = require('./script');","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitcore-lib-cash/lib/address.js"],"names":["_","require","$","errors","Base58Check","Networks","Hash","JSUtil","PublicKey","BN","base32","convertBits","Address","data","network","type","isArray","isNumber","createMultisig","checkArgument","get","TypeError","PayToPublicKeyHash","PayToScriptHash","info","_classifyArguments","defaultNetwork","defineImmutable","hashBuffer","prototype","Buffer","Uint8Array","length","_transformHash","_transformBuffer","_transformPublicKey","Script","_transformScript","_transformString","isObject","_transformObject","hash","from","_classifyFromVersion","buffer","version","pubkeyhashNetwork","scripthashNetwork","networkObj","bufferVersion","slice","pubkey","sha256ripemd160","toBuffer","script","getAddressInfo","CantDeriveAddress","publicKeys","threshold","payingTo","buildMultisigOut","decodeCashAddress","address","hasSingleCase","string","lowerCase","toLowerCase","upperCase","toUpperCase","validChecksum","prefix","payload","prefixToArray","result","i","push","charCodeAt","prefixData","concat","polymod","pieces","split","encodedPayload","decode","netNames","shift","p","convertedBits","versionByte","getHashSize","getType","Error","_decodeCashAddress","trim","name","addressBuffer","fromPublicKey","fromPublicKeyHash","fromScriptHash","fromScript","fromBuffer","fromString","str","fromObject","obj","checkState","isHexa","getValidationError","error","e","isValid","isPayToPublicKeyHash","isPayToScriptHash","buf","toObject","toJSON","toString","inspect","toCashBuffer","toLegacyAddress","encode","toCashAddress","stripPrefix","getTypeBits","getHashSizeBits","eight0","prefixArray","arr","Array","call","payloadData","checksumData","checksumToArray","checksum","reverse","GENERATOR1","GENERATOR2","c0","c1","C","j","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\nvar BN = require('./crypto/bn');\n\nvar base32 = require('./util/base32');\nvar convertBits = require('./util/convertBits');\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\n * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash` and `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\", \"testnet\", or \"regtest\".');\n  }\n\n  if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n    return Address._transformHash(data);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20) {\n    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n  }\n  info.hashBuffer = hash;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n  if (pubkeyhashNetwork) {\n    version.network = pubkeyhashNetwork;\n    version.type = Address.PayToPublicKeyHash;\n  } else if (scripthashNetwork) {\n    version.network = scripthashNetwork;\n    version.type = Address.PayToScriptHash;\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (buffer.length !== 1 + 20) {\n    throw new TypeError('Address buffers must be exactly 21 bytes.');\n  }\n\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || (networkObj && networkObj !== bufferVersion.network)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  info.hashBuffer = buffer.slice(1);\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  info.type = Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n};\n\nfunction decodeCashAddress(address) {\n\n\n  function hasSingleCase(string) {\n    var lowerCase = string.toLowerCase();\n    var upperCase = string.toUpperCase();\n    var hasSingleCase  = string === lowerCase || string === upperCase;\n\n    return hasSingleCase;\n  }\n\n  function validChecksum(prefix, payload) {\n    function prefixToArray(prefix) {\n      var result = [];\n      for (var i=0; i<prefix.length; i++) {\n        result.push(prefix.charCodeAt(i) & 31);\n      }\n      return result;\n    }\n\n    var prefixData = prefixToArray(prefix).concat([0]);\n    return polymod(prefixData.concat(payload)) === 0;\n  }\n\n  $.checkArgument(hasSingleCase(address), 'Mixed case');\n  address = address.toLowerCase();\n\n  var pieces = address.split(':');\n  $.checkArgument(pieces.length <= 2, 'Invalid format:'+ address);\n\n  var prefix, encodedPayload;\n\n  if (pieces.length === 2) {\n    prefix = pieces[0];\n    encodedPayload = pieces[1];\n  } else {\n    prefix = null;\n    encodedPayload = pieces[0];\n  }\n\n  var payload = base32.decode(encodedPayload.toLowerCase());\n\n  if (prefix) {\n    $.checkArgument(validChecksum(prefix, payload), 'Invalid checksum:'+ address);\n  } else {\n\n    var netNames = ['livenet','testnet','regtest'];\n    var i;\n\n    while(!prefix && (i = netNames.shift())){\n      var p  =  Networks.get(i).prefix;\n      if(validChecksum(p, payload)) {\n        prefix = p;\n      }\n    }\n    $.checkArgument(prefix, 'Invalid checksum:'+ address);\n  }\n\n  var convertedBits = convertBits(payload.slice(0, -8), 5, 8, true);\n  var versionByte = convertedBits.shift();\n  var hash = convertedBits;\n\n  $.checkArgument(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size:'+ address);\n\n  function getType(versionByte) {\n    switch (versionByte & 120) {\n    case 0:\n      return 'pubkeyhash';\n    case 8:\n      return 'scripthash';\n    default:\n      throw new Error('Invalid address type in version byte:' + versionByte);\n    }\n  }\n\n\n  var type = getType(versionByte);\n  var network = Networks.get(prefix);\n//console.log('[address.js.336:network:]',network); //TODO\n\n  var info = {};\n\n  //return { prefix, type, hash };\n//console.log('[address.js.339]', hash); //TODO\n\n  info.hashBuffer = Buffer.from(hash);\n  info.network = network;\n  info.type = type;\n  return info;\n}\n\nAddress._decodeCashAddress = decodeCashAddress\n\n/**\n * Internal function to transform a bitcoin cash address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n  if (data.length < 34){\n    throw new Error('Invalid Address string provided');\n  }\n\n  if(data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  data = data.trim();\n  var networkObj = Networks.get(network);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (data.length > 35){\n    var info = decodeCashAddress(data);\n    if (!info.network || (networkObj && networkObj.name !== info.network.name)) {\n      throw new TypeError('Address has mismatched network type.');\n    }\n    if (!info.type || (type && type !== info.type)) {\n      throw new TypeError('Address has mismatched type.');\n    }\n    return info;\n  } else {\n    var addressBuffer = Base58Check.decode(data);\n    // Legacy addr\n    return Address._transformBuffer(addressBuffer, network, type);\n  }\n};\n\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network) {\n  var info = Address._transformPublicKey(data);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToScriptHash);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n\n  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  var version = Buffer.from([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\n/***\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\nAddress.prototype.toCashBuffer = function() {\n  var version = Buffer.from([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n\n/**\n * Will return a the base58 (legacy) string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toLegacyAddress = function () {\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a cashaddr representation of the address. Always return lower case\n * Can be converted by the caller to uppercase is needed (still valid).\n *\n * @returns {string} Bitcoin Cash address\n */\n\n\nAddress.prototype.toCashAddress = function(stripPrefix) {\n  function getTypeBits(type) {\n    switch (type) {\n      case 'pubkeyhash':\n        return 0;\n      case 'scripthash':\n        return 8;\n      default:\n        throw new Error('Invalid type:'+ type);\n    }\n  }\n\n  function getHashSizeBits(hash) {\n    switch (hash.length * 8) {\n      case 160:\n        return 0;\n      case 192:\n        return 1;\n      case 224:\n        return 2;\n      case 256:\n        return 3;\n      case 320:\n        return 4;\n      case 384:\n        return 5;\n      case 448:\n        return 6;\n      case 512:\n        return 7;\n      default:\n        throw new Error('Invalid hash size:'+ hash.length);\n      }\n  }\n\n  var eight0 = [0,0,0,0, 0,0,0,0];\n  var prefixData = this.network.prefixArray.concat([0]);\n  var versionByte = getTypeBits(this.type) + getHashSizeBits(this.hashBuffer);\n  var arr =  Array.prototype.slice.call(this.hashBuffer, 0);\n  var payloadData = convertBits([versionByte].concat(arr), 8, 5);\n  var checksumData = prefixData.concat(payloadData).concat(eight0);\n  var payload = payloadData.concat(checksumToArray(polymod(checksumData)));\n  if(stripPrefix === true) {\n    return base32.encode(payload);\n  } else {\n    return this.network.prefix+ ':' + base32.encode(payload);\n  }\n};\n\n/**\n * Will return a string representation of the address (defaults to CashAddr format)\n *\n * @returns {string} address\n */\nAddress.prototype.toString = Address.prototype.toCashAddress;\n\n/***\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @param {number} versionByte\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n  case 0:\n    return 160;\n  case 1:\n    return 192;\n  case 2:\n    return 224;\n  case 3:\n    return 256;\n  case 4:\n    return 320;\n  case 5:\n    return 384;\n  case 6:\n    return 448;\n  case 7:\n    return 512;\n  }\n}\n\n\n/***\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @param {number} checksum Computed checksum.\n */\nfunction checksumToArray(checksum) {\n  var result = [];\n  for (var i = 0; i < 8; ++i) {\n    result.push(checksum & 31);\n    checksum /= 32;\n  }\n  return result.reverse();\n}\n\n/***\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @param {Array} data Array of 5-bit integers over which the checksum is to be computed.\n */\nvar GENERATOR1 = [0x98, 0x79, 0xf3, 0xae, 0x1e];\nvar GENERATOR2 = [0xf2bc8e61, 0xb76d99e2, 0x3e5fb3c4, 0x2eabe2a8, 0x4f43e470];\n\nfunction polymod(data) {\n  // Treat c as 8 bits + 32 bits\n  var c0 = 0, c1 = 1, C = 0;\n  for (var j = 0; j < data.length; j++) {\n    // Set C to c shifted by 35\n    C = c0 >>> 3;\n    // 0x[07]ffffffff\n    c0 &= 0x07;\n    // Shift as a whole number\n    c0 <<= 5;\n    c0 |= c1 >>> 27;\n    // 0xffffffff >>> 5\n    c1 &= 0x07ffffff;\n    c1 <<= 5;\n    // xor the last 5 bits\n    c1 ^= data[j];\n    for (var i = 0; i < GENERATOR1.length; ++i) {\n      if (C & (1 << i)) {\n        c0 ^= GENERATOR1[i];\n        c1 ^= GENERATOR2[i];\n      }\n    }\n  }\n  c1 ^= 1;\n  // Negative numbers -> large positive numbers\n  if (c1 < 0) {\n    c1 ^= 1 << 31;\n    c1 += (1 << 30) * 2;\n  }\n  // Unless bitwise operations are used,\n  // numbers are consisting of 52 bits, except\n  // the sign bit. The result is max 40 bits,\n  // so it fits perfectly in one number!\n  return c0 * (1 << 30) * 4 + c1;\n}\n\nmodule.exports = Address;\n\nvar Script = require('./script');\n"]},"metadata":{},"sourceType":"script"}