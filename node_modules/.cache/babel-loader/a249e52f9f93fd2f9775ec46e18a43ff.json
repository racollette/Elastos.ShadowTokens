{"ast":null,"code":"// Base58 encoding/decoding\n// Originally written by Mike Hearn for BitcoinJ\n// Copyright (c) 2011 Google Inc\n// Ported to JavaScript by Stefan Thomas\n// Merged Buffer refactorings from base58-native by Stephen Pair\n// Copyright (c) 2013 BitPay Inc\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nvar ALPHABET_MAP = {};\n\nfor (var i = 0; i < ALPHABET.length; ++i) {\n  ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n}\n\nvar BASE = ALPHABET.length;\nmodule.exports = {\n  decode: function (string) {\n    if (string.length === 0) return [];\n    var i,\n        j,\n        bytes = [0];\n\n    for (i = 0; i < string.length; ++i) {\n      var c = string[i];\n      if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n      for (j = 0; j < bytes.length; ++j) bytes[j] *= BASE;\n\n      bytes[0] += ALPHABET_MAP[c];\n      var carry = 0;\n\n      for (j = 0; j < bytes.length; ++j) {\n        bytes[j] += carry;\n        carry = bytes[j] >> 8;\n        bytes[j] &= 0xff;\n      }\n\n      while (carry) {\n        bytes.push(carry & 0xff);\n        carry >>= 8;\n      }\n    } // deal with leading zeros\n\n\n    for (i = 0; string[i] === '1' && i < string.length - 1; ++i) {\n      bytes.push(0);\n    }\n\n    return bytes.reverse();\n  }\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/wallet-address-validator/src/crypto/base58.js"],"names":["ALPHABET","ALPHABET_MAP","i","length","charAt","BASE","module","exports","decode","string","j","bytes","c","Error","carry","push","reverse"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,QAAQ,GAAG,4DAAf;AACA,IAAIC,YAAY,GAAG,EAAnB;;AACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACG,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;AACtCD,EAAAA,YAAY,CAACD,QAAQ,CAACI,MAAT,CAAgBF,CAAhB,CAAD,CAAZ,GAAmCA,CAAnC;AACH;;AACD,IAAIG,IAAI,GAAGL,QAAQ,CAACG,MAApB;AAEAG,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,MAAM,EAAE,UAASC,MAAT,EAAiB;AACrB,QAAIA,MAAM,CAACN,MAAP,KAAkB,CAAtB,EAAyB,OAAO,EAAP;AAEzB,QAAID,CAAJ;AAAA,QAAOQ,CAAP;AAAA,QAAUC,KAAK,GAAG,CAAC,CAAD,CAAlB;;AACA,SAAKT,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGO,MAAM,CAACN,MAAvB,EAA+B,EAAED,CAAjC,EAAoC;AAChC,UAAIU,CAAC,GAAGH,MAAM,CAACP,CAAD,CAAd;AACA,UAAI,EAAEU,CAAC,IAAIX,YAAP,CAAJ,EAA0B,MAAM,IAAIY,KAAJ,CAAU,sBAAV,CAAN;;AAE1B,WAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,KAAK,CAACR,MAAtB,EAA8B,EAAEO,CAAhC,EAAmCC,KAAK,CAACD,CAAD,CAAL,IAAYL,IAAZ;;AACnCM,MAAAA,KAAK,CAAC,CAAD,CAAL,IAAYV,YAAY,CAACW,CAAD,CAAxB;AAEA,UAAIE,KAAK,GAAG,CAAZ;;AACA,WAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,KAAK,CAACR,MAAtB,EAA8B,EAAEO,CAAhC,EAAmC;AAC/BC,QAAAA,KAAK,CAACD,CAAD,CAAL,IAAYI,KAAZ;AACAA,QAAAA,KAAK,GAAGH,KAAK,CAACD,CAAD,CAAL,IAAY,CAApB;AACAC,QAAAA,KAAK,CAACD,CAAD,CAAL,IAAY,IAAZ;AACH;;AAED,aAAOI,KAAP,EAAc;AACVH,QAAAA,KAAK,CAACI,IAAN,CAAWD,KAAK,GAAG,IAAnB;AACAA,QAAAA,KAAK,KAAK,CAAV;AACH;AACJ,KAtBoB,CAuBrB;;;AACA,SAAKZ,CAAC,GAAG,CAAT,EAAYO,MAAM,CAACP,CAAD,CAAN,KAAc,GAAd,IAAqBA,CAAC,GAAGO,MAAM,CAACN,MAAP,GAAgB,CAArD,EAAwD,EAAED,CAA1D,EAA4D;AACxDS,MAAAA,KAAK,CAACI,IAAN,CAAW,CAAX;AACH;;AAED,WAAOJ,KAAK,CAACK,OAAN,EAAP;AACH;AA9BY,CAAjB","sourcesContent":["// Base58 encoding/decoding\n// Originally written by Mike Hearn for BitcoinJ\n// Copyright (c) 2011 Google Inc\n// Ported to JavaScript by Stefan Thomas\n// Merged Buffer refactorings from base58-native by Stephen Pair\n// Copyright (c) 2013 BitPay Inc\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nvar ALPHABET_MAP = {};\nfor (var i = 0; i < ALPHABET.length; ++i) {\n    ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n}\nvar BASE = ALPHABET.length;\n\nmodule.exports = {\n    decode: function(string) {\n        if (string.length === 0) return [];\n\n        var i, j, bytes = [0];\n        for (i = 0; i < string.length; ++i) {\n            var c = string[i];\n            if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n            for (j = 0; j < bytes.length; ++j) bytes[j] *= BASE\n            bytes[0] += ALPHABET_MAP[c];\n\n            var carry = 0;\n            for (j = 0; j < bytes.length; ++j) {\n                bytes[j] += carry;\n                carry = bytes[j] >> 8;\n                bytes[j] &= 0xff\n            }\n\n            while (carry) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (i = 0; string[i] === '1' && i < string.length - 1; ++i){\n            bytes.push(0);\n        }\n\n        return bytes.reverse();\n    }\n};\n"]},"metadata":{},"sourceType":"script"}