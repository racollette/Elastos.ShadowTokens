{"ast":null,"code":"/* eslint-disable */\n// import createLogger from 'logging';\nimport debugLogger from 'debug';\nimport { isBrowser } from 'browser-or-node';\nimport { V1endpoint, V2endpoint } from '../config';\nimport uuid from 'uuid/v4';\nimport MewConnectCommon from '../MewConnectCommon';\nimport MewConnectCrypto from '../MewConnectCrypto';\nimport MewConnectInitiatorV2 from './MewConnectInitiatorV2';\nimport MewConnectInitiatorV1 from './MewConnectInitiatorV1';\nimport WebRtcCommunication from '../WebRtcCommunication';\nimport PopUpCreator from '../../connectWindow/popUpCreator';\nconst debug = debugLogger('MEWconnect:initiator-base'); // const debugPeer = debugLogger('MEWconnectVerbose:peer-instances');\n\nconst debugStages = debugLogger('MEWconnect:initiator-stages'); // const logger = createLogger('MewConnectInitiator');\n\nconst debugConnectionState = debugLogger('MEWconnect:connection-state');\nexport default class MewConnectInitiator extends MewConnectCommon {\n  constructor(options = {}) {\n    super(options.version);\n    this.optionVersion = options.version || 2.0;\n    this.showPopup = options.showPopup || false;\n\n    try {\n      this.supportedBrowser = MewConnectCommon.checkBrowser();\n      this.requestIds = [];\n      this.V1 = {};\n      this.V2 = {};\n      this.activePeerId = '';\n      this.allPeerIds = [];\n      this.peersCreated = [];\n      this.v1Url = options.v1Url || V1endpoint;\n      this.v2Url = options.v2Url || V2endpoint;\n      this.turnTest = options.turnTest;\n      this.destroyOnUnload(typeof window !== 'undefined');\n      this.p = null;\n      this.socketV2Connected = false;\n      this.socketV1Connected = false;\n      this.connected = false;\n      this.tryingTurn = false;\n      this.turnDisabled = false;\n      this.signalUrl = null;\n      this.iceState = '';\n      this.turnServers = [];\n      this.refreshTimer = null;\n      this.refreshDelay = 20000;\n      this.socketsCreated = false;\n      this.refreshCount = 0;\n      this.abandonedTimeout = 300000;\n      this.mewCrypto = options.cryptoImpl || MewConnectCrypto.create();\n      this.webRtcCommunication = new WebRtcCommunication(this.mewCrypto);\n      this.popupCreator = options.popupCreator || new PopUpCreator();\n      debugConnectionState('Initial Connection State:', MewConnectInitiator.getConnectionState());\n      this.version = this.jsonDetails.version;\n      this.lifeCycle = this.jsonDetails.lifeCycle;\n      this.iceStates = this.jsonDetails.iceConnectionState;\n      this.stunServers = options.stunServers || this.jsonDetails.stunSrvers; // Socket is abandoned.  disconnect.\n\n      this.timer = null;\n      setTimeout(() => {\n        if (this.socket) {\n          this.socketDisconnect();\n          this.refreshCheck();\n        }\n      }, this.abandonedTimeout);\n    } catch (e) {\n      debug('constructor error:', e);\n    }\n  }\n\n  static setConnectionState(connectionState) {\n    if (!connectionState) MewConnectInitiator.connectionState = 'disconnected';else MewConnectInitiator.connectionState = connectionState;\n  }\n\n  static getConnectionState() {\n    if (!MewConnectInitiator.connectionState) return 'disconnected';\n    return MewConnectInitiator.connectionState;\n  }\n\n  isAlive() {\n    if (this.p !== null) {\n      return this.p.connected && !this.p.destroyed;\n    }\n\n    return false;\n  }\n\n  focusPopupWindow() {\n    if (this.popupCreator.popupWindowOpen) {\n      this.popupCreator.popupWindow.focus();\n    }\n  } // Check if a WebRTC connection exists before a window/tab is closed or refreshed\n  // Destroy the connection if one exists\n\n\n  destroyOnUnload() {\n    if (isBrowser) {\n      try {\n        // eslint-disable-next-line no-undef\n        if (!window) return; // eslint-disable-next-line no-undef\n\n        window.onunload = window.onbeforeunload = () => {\n          const iceStates = [this.iceStates.new, this.iceStates.connecting, this.iceStates.connected];\n\n          if (this.Peer) {\n            if (!this.Peer.destroyed || iceStates.includes(this.iceState)) {\n              this.rtcDestroy();\n            }\n          }\n\n          this.popupCreator.removeWindowClosedListener();\n          this.popupCreator.closePopupWindow();\n        };\n      } catch (e) {\n        debug(e);\n      }\n    }\n  }\n\n  static checkBrowser() {\n    return MewConnectCommon.checkBrowser();\n  }\n\n  static checkWebRTCAvailable() {\n    return MewConnectCommon.checkWebRTCAvailable();\n  } // Returns a boolean indicating whether the socket connection exists and is active\n\n\n  getSocketConnectionState() {\n    return this.socketV1Connected || this.socketV2Connected;\n  } // Returns a boolean indicating whether the WebRTC connection exists and is active\n\n\n  getConnectonState() {\n    return this.connected;\n  } // can be used to listen to specific events, especially those that pass data\n\n\n  uiCommunicator(event, data) {\n    debug('MewConnectInitiator event emitted', event);\n    this.emit(event, data);\n    this.emitStatus(event);\n  } // special status emitter to allow simple listening of various statuses in one listener\n\n\n  emitStatus(event) {\n    this.emit('status', event);\n  } // Emit/Provide the details used in creating the QR Code\n\n\n  displayCode(privateKey) {\n    try {\n      if (privateKey instanceof Buffer) {\n        privateKey = privateKey.toString('hex');\n      }\n\n      let dapp = 'example';\n\n      if (typeof window !== 'undefined') {\n        dapp = window.location.hostname;\n      }\n\n      debug('handshake', privateKey);\n      this.socketKey = privateKey;\n      const separator = this.jsonDetails.connectionCodeSeparator;\n      let qrCodeString = this.version + separator + privateKey + separator + this.connId + ':name=' + dapp.replace(/^www\\./, '');\n\n      if (dapp.includes('myetherwallet.com')) {\n        qrCodeString = this.version + separator + privateKey + separator + this.connId;\n      } else if (dapp.includes('mewbuilds.com')) {\n        qrCodeString = this.version + separator + privateKey + separator + this.connId;\n      }\n\n      debug(qrCodeString);\n\n      if (this.showPopup) {\n        if (this.popupCreator.popupWindowOpen) {\n          this.popupCreator.updateQrCode(qrCodeString);\n        } else {\n          this.popupCreator.refreshQrcode = this.initiatorStart.bind(this);\n          this.popupCreator.openPopupWindow(qrCodeString);\n          this.popupCreator.popupWindow.addEventListener('beforeunload', () => {\n            if (!this.connected) {\n              // eslint-disable-next-line no-console\n              debug('popup window closed');\n              this.uiCommunicator('popup_window_closed');\n              MewConnectInitiator.setConnectionState();\n              this.socketDisconnect();\n              this.emit(this.lifeCycle.AuthRejected);\n              this.refreshCheck();\n            }\n          });\n        }\n      } else {\n        this.uiCommunicator(this.lifeCycle.codeDisplay, qrCodeString);\n        this.uiCommunicator(this.lifeCycle.checkNumber, privateKey);\n        this.uiCommunicator(this.lifeCycle.ConnectionId, this.connId);\n      }\n    } catch (e) {\n      debug('displayCode error:', e);\n    }\n  }\n  /*\n  ===================================================================================\n  Keys\n  ===================================================================================\n  */\n\n  /* Set the public and private keys, connId, and signed that will be used\n   * for the duration of the pairing process. The receiver will need to have access\n   * to this information as well, however, the initiator creates the credentials to be\n   * shared with the receiver.\n   */\n\n\n  generateKeys(testPrivate) {\n    if (!this.mewCrypto) this.mewCrypto = MewConnectCrypto.create();\n    let keys = {};\n\n    if (testPrivate) {\n      keys = this.mewCrypto.setPrivate(testPrivate);\n    } else {\n      keys = this.mewCrypto.generateKeys();\n    }\n\n    this.publicKey = keys.publicKey;\n    this.privateKey = keys.privateKey;\n    this.connId = this.mewCrypto.generateConnId(this.publicKey);\n    this.signed = this.mewCrypto.signMessageSync(this.privateKey, this.privateKey);\n    debug('this.signed', this.signed);\n  }\n\n  async refreshCode() {\n    this.initiatorStart();\n  }\n\n  refreshCheck() {\n    if (this.refreshTimer !== null) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n  } // TODO change this to use supplied urls at time point\n\n\n  async initiatorStart(url, testPrivate) {\n    // this.refreshTimer = setTimeout(() => {\n    //   this.refreshCode();\n    // }, this.refreshDelay);\n    if (this.socketV1Connected) {\n      this.V1.socketDisconnect();\n    }\n\n    if (this.socketV2Connected) {\n      this.V2.socketDisconnect();\n    }\n\n    this.generateKeys(testPrivate);\n    this.displayCode(this.privateKey);\n    this.webRtcCommunication.once(this.lifeCycle.disconnected, this.uiCommunicator.bind(this, this.lifeCycle.RtcClosedEvent));\n    const options = {\n      stunServers: this.stunServers,\n      turnTest: this.turnTest,\n      version: this.optionVersion,\n      uiCommunicator: this.uiCommunicator.bind(this),\n      webRtcCommunication: this.webRtcCommunication,\n      crypto: this.mewCrypto\n    };\n    this.webRtcCommunication.on('data', this.dataReceived.bind(this));\n\n    try {\n      this.V2 = new MewConnectInitiatorV2({\n        url: V2endpoint,\n        ...options\n      });\n      await this.V2.initiatorStart(V2endpoint, this.mewCrypto, {\n        signed: this.signed,\n        connId: this.connId\n      });\n      this.V2.on('sendingOffer', () => {\n        this.refreshCheck();\n      });\n      this.V2.on('retryingViaTurn', () => {\n        this.refreshCheck();\n      });\n    } catch (e) {\n      // eslint-disable-next-line\n      console.error(e);\n      this.V2 = {};\n    }\n\n    try {\n      this.V1 = new MewConnectInitiatorV1({\n        url: V1endpoint,\n        ...options\n      });\n      await this.V1.initiatorStart(V1endpoint, this.mewCrypto, {\n        signed: this.signed,\n        connId: this.connId\n      });\n    } catch (e) {\n      // eslint-disable-next-line\n      console.error(e);\n      this.V1 = {};\n    }\n\n    this.webRtcCommunication.setActiveInitiatorId(this.V2.initiatorId);\n\n    if (this.V1.on) {\n      this.V1.on('socketPaired', () => {\n        if (this.V2.socketDisconnect) this.V2.socketDisconnect();\n        this.socketV1Connected = true;\n      });\n    }\n\n    if (this.V2.on) {\n      this.V2.on('socketPaired', () => {\n        if (this.V1.socketDisconnect) this.V1.socketDisconnect();\n        this.socketV2Connected = true;\n      });\n    }\n\n    this.webRtcCommunication.on(this.jsonDetails.lifeCycle.RtcConnectedEvent, () => {\n      this.refreshCheck();\n      this.connected = true;\n      this.popupCreator.removeWindowClosedListener();\n      this.popupCreator.closePopupWindow();\n      MewConnectInitiator.setConnectionState('connected');\n    });\n  }\n\n  socketDisconnect() {\n    this.V2.socketDisconnect();\n    this.V1.socketDisconnect();\n    this.refreshCheck();\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.webRtcCommunication.disconnectRTC();\n    this.instance = null;\n  }\n\n  async rtcSend(arg) {\n    await this.webRtcCommunication.rtcSend(arg);\n  }\n\n  sendRtcMessage(type, data) {\n    const id = uuid();\n    this.requestIds.push(id);\n    debug('MESSAGE IDS KNOWN', this.requestIds);\n    this.webRtcCommunication.sendRtcMessage(type, data, id);\n  }\n\n  dataReceived(data) {\n    debug('dataReceived', data);\n\n    if (data.id) {\n      debug('MESSAGE ID RECEIVED', data.id);\n\n      if (this.requestIds.includes(data.id)) {\n        this.uiCommunicator(data.type, data.data);\n        const idx = this.requestIds.findIndex(item => item === id);\n        this.requestIds.splice(idx, 1);\n        debug('MESSAGE IDS KNOWN', this.requestIds);\n      } else {\n        debug('**NO MESSAGE ID RECEIVED : field present**');\n        this.uiCommunicator(data.type, data.data);\n      }\n    } else {\n      debug('**NO MESSAGE ID RECEIVED : field absent**');\n      this.uiCommunicator(data.type, data.data);\n    }\n  }\n\n  testV1Turn() {\n    this.V1.disconnectRTC();\n  }\n\n  testV2Turn() {\n    this.V2.disconnectRTC();\n    this.V2.emit(this.lifeCycle);\n  }\n\n}","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/@myetherwallet/mewconnect-web-client/src/connectClient/initiator/MewConnectInitiator.js"],"names":["debugLogger","isBrowser","V1endpoint","V2endpoint","uuid","MewConnectCommon","MewConnectCrypto","MewConnectInitiatorV2","MewConnectInitiatorV1","WebRtcCommunication","PopUpCreator","debug","debugStages","debugConnectionState","MewConnectInitiator","constructor","options","version","optionVersion","showPopup","supportedBrowser","checkBrowser","requestIds","V1","V2","activePeerId","allPeerIds","peersCreated","v1Url","v2Url","turnTest","destroyOnUnload","window","p","socketV2Connected","socketV1Connected","connected","tryingTurn","turnDisabled","signalUrl","iceState","turnServers","refreshTimer","refreshDelay","socketsCreated","refreshCount","abandonedTimeout","mewCrypto","cryptoImpl","create","webRtcCommunication","popupCreator","getConnectionState","jsonDetails","lifeCycle","iceStates","iceConnectionState","stunServers","stunSrvers","timer","setTimeout","socket","socketDisconnect","refreshCheck","e","setConnectionState","connectionState","isAlive","destroyed","focusPopupWindow","popupWindowOpen","popupWindow","focus","onunload","onbeforeunload","new","connecting","Peer","includes","rtcDestroy","removeWindowClosedListener","closePopupWindow","checkWebRTCAvailable","getSocketConnectionState","getConnectonState","uiCommunicator","event","data","emit","emitStatus","displayCode","privateKey","Buffer","toString","dapp","location","hostname","socketKey","separator","connectionCodeSeparator","qrCodeString","connId","replace","updateQrCode","refreshQrcode","initiatorStart","bind","openPopupWindow","addEventListener","AuthRejected","codeDisplay","checkNumber","ConnectionId","generateKeys","testPrivate","keys","setPrivate","publicKey","generateConnId","signed","signMessageSync","refreshCode","clearTimeout","url","once","disconnected","RtcClosedEvent","crypto","on","dataReceived","console","error","setActiveInitiatorId","initiatorId","RtcConnectedEvent","disconnectRTC","RtcDisconnectEvent","instance","rtcSend","arg","sendRtcMessage","type","id","push","idx","findIndex","item","splice","testV1Turn","testV2Turn"],"mappings":"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","sourcesContent":["/* eslint-disable */\n// import createLogger from 'logging';\nimport debugLogger from 'debug';\nimport { isBrowser } from 'browser-or-node';\nimport { V1endpoint, V2endpoint } from '../config';\nimport uuid from 'uuid/v4';\n\nimport MewConnectCommon from '../MewConnectCommon';\nimport MewConnectCrypto from '../MewConnectCrypto';\nimport MewConnectInitiatorV2 from './MewConnectInitiatorV2';\nimport MewConnectInitiatorV1 from './MewConnectInitiatorV1';\n\nimport WebRtcCommunication from '../WebRtcCommunication';\nimport PopUpCreator from '../../connectWindow/popUpCreator';\n\nconst debug = debugLogger('MEWconnect:initiator-base');\n// const debugPeer = debugLogger('MEWconnectVerbose:peer-instances');\nconst debugStages = debugLogger('MEWconnect:initiator-stages');\n// const logger = createLogger('MewConnectInitiator');\nconst debugConnectionState = debugLogger('MEWconnect:connection-state');\n\nexport default class MewConnectInitiator extends MewConnectCommon {\n  constructor(options = {}) {\n    super(options.version);\n    this.optionVersion = options.version || 2.0;\n    this.showPopup = options.showPopup || false;\n    try {\n      this.supportedBrowser = MewConnectCommon.checkBrowser();\nthis.requestIds = [];\n      this.V1 = {};\n      this.V2 = {};\n\n      this.activePeerId = '';\n      this.allPeerIds = [];\n      this.peersCreated = [];\n      this.v1Url = options.v1Url || V1endpoint;\n      this.v2Url = options.v2Url || V2endpoint;\n\n      this.turnTest = options.turnTest;\n\n      this.destroyOnUnload(typeof window !== 'undefined');\n      this.p = null;\n      this.socketV2Connected = false;\n      this.socketV1Connected = false;\n      this.connected = false;\n      this.tryingTurn = false;\n      this.turnDisabled = false;\n      this.signalUrl = null;\n      this.iceState = '';\n      this.turnServers = [];\n      this.refreshTimer = null;\n      this.refreshDelay = 20000;\n      this.socketsCreated = false;\n      this.refreshCount = 0;\n      this.abandonedTimeout = 300000;\n\n      this.mewCrypto = options.cryptoImpl || MewConnectCrypto.create();\n      this.webRtcCommunication = new WebRtcCommunication(this.mewCrypto);\n      this.popupCreator = options.popupCreator || new PopUpCreator();\n\n      debugConnectionState(\n        'Initial Connection State:',\n        MewConnectInitiator.getConnectionState()\n      );\n      this.version = this.jsonDetails.version;\n      this.lifeCycle = this.jsonDetails.lifeCycle;\n      this.iceStates = this.jsonDetails.iceConnectionState;\n      this.stunServers = options.stunServers || this.jsonDetails.stunSrvers;\n\n      // Socket is abandoned.  disconnect.\n      this.timer = null;\n      setTimeout(() => {\n        if (this.socket) {\n          this.socketDisconnect();\n          this.refreshCheck();\n        }\n      }, this.abandonedTimeout);\n    } catch (e) {\n      debug('constructor error:', e);\n    }\n  }\n\n  static setConnectionState(connectionState) {\n    if (!connectionState) MewConnectInitiator.connectionState = 'disconnected';\n    else MewConnectInitiator.connectionState = connectionState;\n  }\n\n  static getConnectionState() {\n    if (!MewConnectInitiator.connectionState) return 'disconnected';\n    return MewConnectInitiator.connectionState;\n  }\n\n  isAlive() {\n    if (this.p !== null) {\n      return this.p.connected && !this.p.destroyed;\n    }\n    return false;\n  }\n\n  focusPopupWindow() {\n    if (this.popupCreator.popupWindowOpen) {\n      this.popupCreator.popupWindow.focus();\n    }\n  }\n\n  // Check if a WebRTC connection exists before a window/tab is closed or refreshed\n  // Destroy the connection if one exists\n  destroyOnUnload() {\n    if (isBrowser) {\n      try {\n        // eslint-disable-next-line no-undef\n        if (!window) return;\n        // eslint-disable-next-line no-undef\n        window.onunload = window.onbeforeunload = () => {\n          const iceStates = [\n            this.iceStates.new,\n            this.iceStates.connecting,\n            this.iceStates.connected\n          ];\n          if (this.Peer) {\n            if (!this.Peer.destroyed || iceStates.includes(this.iceState)) {\n              this.rtcDestroy();\n            }\n          }\n          this.popupCreator.removeWindowClosedListener();\n          this.popupCreator.closePopupWindow();\n        };\n      } catch (e) {\n        debug(e);\n      }\n    }\n  }\n\n  static checkBrowser() {\n    return MewConnectCommon.checkBrowser();\n  }\n\n  static checkWebRTCAvailable() {\n    return MewConnectCommon.checkWebRTCAvailable();\n  }\n\n  // Returns a boolean indicating whether the socket connection exists and is active\n  getSocketConnectionState() {\n    return this.socketV1Connected || this.socketV2Connected;\n  }\n\n  // Returns a boolean indicating whether the WebRTC connection exists and is active\n  getConnectonState() {\n    return this.connected;\n  }\n\n  // can be used to listen to specific events, especially those that pass data\n  uiCommunicator(event, data) {\n    debug('MewConnectInitiator event emitted', event);\n    this.emit(event, data);\n    this.emitStatus(event);\n  }\n\n  // special status emitter to allow simple listening of various statuses in one listener\n  emitStatus(event) {\n    this.emit('status', event);\n  }\n\n  // Emit/Provide the details used in creating the QR Code\n  displayCode(privateKey) {\n    try {\n      if (privateKey instanceof Buffer) {\n        privateKey = privateKey.toString('hex');\n      }\n      let dapp = 'example';\n      if (typeof window !== 'undefined') {\n        dapp = window.location.hostname;\n      }\n      debug('handshake', privateKey);\n      this.socketKey = privateKey;\n      const separator = this.jsonDetails.connectionCodeSeparator;\n      let qrCodeString =\n        this.version + separator + privateKey + separator + this.connId + ':name=' + dapp.replace(/^www\\./, '');\n      if(dapp.includes('myetherwallet.com')){\n        qrCodeString =\n          this.version + separator + privateKey + separator + this.connId;\n      } else if(dapp.includes('mewbuilds.com')){\n        qrCodeString =\n          this.version + separator + privateKey + separator + this.connId;\n      }\n\n\n      debug(qrCodeString);\n      if (this.showPopup) {\n        if (this.popupCreator.popupWindowOpen) {\n          this.popupCreator.updateQrCode(qrCodeString);\n        } else {\n          this.popupCreator.refreshQrcode = this.initiatorStart.bind(this);\n          this.popupCreator.openPopupWindow(qrCodeString);\n          this.popupCreator.popupWindow.addEventListener('beforeunload', () => {\n            if (!this.connected) {\n              // eslint-disable-next-line no-console\n              debug('popup window closed');\n              this.uiCommunicator('popup_window_closed');\n              MewConnectInitiator.setConnectionState();\n              this.socketDisconnect();\n              this.emit(this.lifeCycle.AuthRejected);\n              this.refreshCheck();\n            }\n          });\n        }\n      } else {\n        this.uiCommunicator(this.lifeCycle.codeDisplay, qrCodeString);\n        this.uiCommunicator(this.lifeCycle.checkNumber, privateKey);\n        this.uiCommunicator(this.lifeCycle.ConnectionId, this.connId);\n      }\n    } catch (e) {\n      debug('displayCode error:', e);\n    }\n  }\n\n  /*\n===================================================================================\nKeys\n===================================================================================\n\n\n*/\n\n  /* Set the public and private keys, connId, and signed that will be used\n   * for the duration of the pairing process. The receiver will need to have access\n   * to this information as well, however, the initiator creates the credentials to be\n   * shared with the receiver.\n   */\n  generateKeys(testPrivate) {\n    if (!this.mewCrypto) this.mewCrypto = MewConnectCrypto.create();\n    let keys = {};\n    if (testPrivate) {\n      keys = this.mewCrypto.setPrivate(testPrivate);\n    } else {\n      keys = this.mewCrypto.generateKeys();\n    }\n    this.publicKey = keys.publicKey;\n    this.privateKey = keys.privateKey;\n    this.connId = this.mewCrypto.generateConnId(this.publicKey);\n    this.signed = this.mewCrypto.signMessageSync(\n      this.privateKey,\n      this.privateKey\n    );\n    debug('this.signed', this.signed);\n  }\n\n  async refreshCode() {\n    this.initiatorStart();\n  }\n\n  refreshCheck() {\n    if (this.refreshTimer !== null) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n  }\n\n  // TODO change this to use supplied urls at time point\n  async initiatorStart(url, testPrivate) {\n    // this.refreshTimer = setTimeout(() => {\n    //   this.refreshCode();\n    // }, this.refreshDelay);\n    if (this.socketV1Connected) {\n      this.V1.socketDisconnect();\n    }\n    if (this.socketV2Connected) {\n      this.V2.socketDisconnect();\n    }\n    this.generateKeys(testPrivate);\n    this.displayCode(this.privateKey);\n    this.webRtcCommunication.once(\n      this.lifeCycle.disconnected,\n      this.uiCommunicator.bind(this, this.lifeCycle.RtcClosedEvent)\n    );\n    const options = {\n      stunServers: this.stunServers,\n      turnTest: this.turnTest,\n      version: this.optionVersion,\n      uiCommunicator: this.uiCommunicator.bind(this),\n      webRtcCommunication: this.webRtcCommunication,\n      crypto: this.mewCrypto\n    };\n    this.webRtcCommunication.on('data', this.dataReceived.bind(this));\n    try {\n      this.V2 = new MewConnectInitiatorV2({ url: V2endpoint, ...options });\n      await this.V2.initiatorStart(V2endpoint, this.mewCrypto, {\n        signed: this.signed,\n        connId: this.connId\n      });\n\n      this.V2.on('sendingOffer', () => {\n        this.refreshCheck();\n      });\n\n      this.V2.on('retryingViaTurn', () => {\n        this.refreshCheck();\n      });\n    } catch (e) {\n      // eslint-disable-next-line\n      console.error(e);\n      this.V2 = {};\n    }\n\n    try {\n      this.V1 = new MewConnectInitiatorV1({ url: V1endpoint, ...options });\n      await this.V1.initiatorStart(V1endpoint, this.mewCrypto, {\n        signed: this.signed,\n        connId: this.connId\n      });\n    } catch (e) {\n      // eslint-disable-next-line\n      console.error(e);\n      this.V1 = {};\n    }\n    this.webRtcCommunication.setActiveInitiatorId(this.V2.initiatorId);\n\n    if (this.V1.on) {\n      this.V1.on('socketPaired', () => {\n        if (this.V2.socketDisconnect) this.V2.socketDisconnect();\n        this.socketV1Connected = true;\n      });\n    }\n\n    if (this.V2.on) {\n      this.V2.on('socketPaired', () => {\n        if (this.V1.socketDisconnect) this.V1.socketDisconnect();\n        this.socketV2Connected = true;\n      });\n    }\n\n    this.webRtcCommunication.on(\n      this.jsonDetails.lifeCycle.RtcConnectedEvent,\n      () => {\n        this.refreshCheck();\n        this.connected = true;\n        this.popupCreator.removeWindowClosedListener();\n        this.popupCreator.closePopupWindow();\n        MewConnectInitiator.setConnectionState('connected');\n      }\n    );\n  }\n\n  socketDisconnect() {\n    this.V2.socketDisconnect();\n    this.V1.socketDisconnect();\n    this.refreshCheck();\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.webRtcCommunication.disconnectRTC();\n    this.instance = null;\n  }\n\n  async rtcSend(arg) {\n    await this.webRtcCommunication.rtcSend(arg);\n  }\n\n  sendRtcMessage(type, data) {\n    const id = uuid();\n    this.requestIds.push(id);\n    debug('MESSAGE IDS KNOWN', this.requestIds)\n    this.webRtcCommunication.sendRtcMessage(type, data, id);\n  }\n\n  dataReceived(data) {\n    debug('dataReceived', data);\n    if(data.id){\n      debug('MESSAGE ID RECEIVED', data.id);\n      if (this.requestIds.includes(data.id)) {\n        this.uiCommunicator(data.type, data.data);\n        const idx = this.requestIds.findIndex(item => item === id);\n        this.requestIds.splice(idx, 1);\n        debug('MESSAGE IDS KNOWN', this.requestIds)\n      } else {\n        debug('**NO MESSAGE ID RECEIVED : field present**');\n        this.uiCommunicator(data.type, data.data);\n      }\n    } else {\n      debug('**NO MESSAGE ID RECEIVED : field absent**');\n      this.uiCommunicator(data.type, data.data);\n    }\n  }\n\n  testV1Turn() {\n    this.V1.disconnectRTC();\n  }\n\n  testV2Turn() {\n    this.V2.disconnectRTC();\n    this.V2.emit(this.lifeCycle);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}