{"ast":null,"code":"'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar Schnorr = require('../crypto/schnorr');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar Interpreter = require('../script/interpreter');\n\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff'; // By default, we sign with sighash_forkid\n\nvar DEFAULT_SIGN_FLAGS = Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID;\n\nvar sighashForForkId = function (transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(satoshisBN instanceof BN, 'For ForkId=0 signatures, satoshis or complete input must be provided');\n\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  }\n\n  ;\n\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter();\n\n    _.each(tx.inputs, function (input) {\n      writer.writeReverse(input.prevTxId);\n      writer.writeUInt32LE(input.outputIndex);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter();\n\n    _.each(tx.inputs, function (input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter();\n\n    if (_.isUndefined(n)) {\n      _.each(tx.outputs, function (output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n\n  function getHash(w) {\n    var buf = w.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n\n  ;\n  var writer = new BufferWriter(); // Version\n\n  writer.writeInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n  writer.write(hashPrevouts);\n  writer.write(hashSequence); //  outpoint (32-byte hash + 4-byte little endian)\n\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex); // scriptCode of the input (serialized as scripts inside CTxOuts)\n\n  writer.writeVarintNum(subscript.toBuffer().length);\n  writer.write(subscript.toBuffer()); // value of the output spent by this input (8-byte little endian)\n\n  writer.writeUInt64LEBN(satoshisBN); // nSequence of the input (4-byte little endian) \n\n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n  writer.write(hashOutputs); // Locktime\n\n  writer.writeUInt32LE(transaction.nLockTime); // sighashType \n\n  writer.writeUInt32LE(sighashType >>> 0);\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} input's amount (for  ForkId signatures)\n *\n */\n\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {\n  var Transaction = require('./transaction');\n\n  var Input = require('./input');\n\n  if (_.isUndefined(flags)) {\n    flags = DEFAULT_SIGN_FLAGS;\n  } // Copy transaction\n\n\n  var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n  subscript = new Script(subscript);\n\n  if (flags & Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION) {\n    // Legacy chain's value for fork id must be of the form 0xffxxxx.\n    // By xoring with 0xdead, we ensure that the value will be different\n    // from the original one, even if it already starts with 0xff.\n    var forkValue = sighashType >> 8;\n    var newForkValue = 0xff0000 | forkValue ^ 0xdead;\n    sighashType = newForkValue << 8 | sighashType & 0xff;\n  }\n\n  if (sighashType & Signature.SIGHASH_FORKID && flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  } // For no ForkId sighash, separators need to be removed.\n\n\n  subscript.removeCodeseparators();\n  var i;\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @param {signingMethod} signingMethod \"ecdsa\" or \"schnorr\" to sign a tx\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN, flags, signingMethod) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN, flags);\n  signingMethod = signingMethod || \"ecdsa\";\n  let sig;\n\n  if (signingMethod === \"schnorr\") {\n    sig = Schnorr.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  } else if (signingMethod === \"ecdsa\") {\n    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @param {flags} verification flags\n * @param {signingMethod} signingMethod \"ecdsa\" or \"schnorr\" to sign a tx\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN, flags, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN, flags);\n  signingMethod = signingMethod || \"ecdsa\";\n\n  if (signingMethod === \"schnorr\") {\n    return Schnorr.verify(hashbuf, signature, publicKey, 'little');\n  } else if (signingMethod === \"ecdsa\") {\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitcore-lib-cash/lib/transaction/sighash.js"],"names":["buffer","require","Signature","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","Schnorr","$","BufferUtil","Interpreter","_","SIGHASH_SINGLE_BUG","BITS_64_ON","DEFAULT_SIGN_FLAGS","SCRIPT_ENABLE_SIGHASH_FORKID","sighashForForkId","transaction","sighashType","inputNumber","subscript","satoshisBN","input","inputs","checkArgument","GetForkId","GetPrevoutHash","tx","writer","each","writeReverse","prevTxId","writeUInt32LE","outputIndex","buf","toBuffer","ret","sha256sha256","GetSequenceHash","sequenceNumber","GetOutputsHash","n","isUndefined","outputs","output","toBufferWriter","hashPrevouts","emptyBuffer","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","length","getHash","w","readReverse","writeInt32LE","version","write","writeVarintNum","writeUInt64LEBN","nLockTime","sighash","flags","Transaction","Input","txcopy","shallowCopy","SCRIPT_ENABLE_REPLAY_PROTECTION","forkValue","newForkValue","SIGHASH_FORKID","removeCodeseparators","i","setScript","empty","Buffer","from","satoshis","fromBuffer","script","sign","privateKey","inputIndex","signingMethod","hashbuf","sig","set","nhashtype","verify","signature","publicKey","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar Schnorr = require('../crypto/schnorr');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar Interpreter = require('../script/interpreter');\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n// By default, we sign with sighash_forkid\nvar DEFAULT_SIGN_FLAGS = Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID;\n\n\nvar sighashForForkId = function(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(\n    satoshisBN instanceof BN, \n    'For ForkId=0 signatures, satoshis or complete input must be provided'\n  );\n\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  };\n\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter()\n\n    _.each(tx.inputs, function(input) {\n        writer.writeReverse(input.prevTxId);\n        writer.writeUInt32LE(input.outputIndex);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter()\n\n    _.each(tx.inputs, function(input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter()\n\n    if ( _.isUndefined(n)) {\n      _.each(tx.outputs, function(output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n   \n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n    (sighashType & 31) != Signature.SIGHASH_SINGLE &&\n    (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n\n\nfunction getHash (w) {\n\n  var buf = w.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};  \n\n\n\n  var writer = new BufferWriter()\n\n  // Version\n  writer.writeInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  //  outpoint (32-byte hash + 4-byte little endian)\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex);\n\n  // scriptCode of the input (serialized as scripts inside CTxOuts)\n  writer.writeVarintNum(subscript.toBuffer().length)\n  writer.write(subscript.toBuffer());\n\n  // value of the output spent by this input (8-byte little endian)\n  writer.writeUInt64LEBN(satoshisBN);\n  \n  // nSequence of the input (4-byte little endian) \n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // sighashType \n  writer.writeUInt32LE(sighashType >>>0);\n\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n}\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} input's amount (for  ForkId signatures)\n *\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n  \n  if (_.isUndefined(flags)){\n    flags = DEFAULT_SIGN_FLAGS;\n  }\n\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n\n  if (flags & Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION) {\n    // Legacy chain's value for fork id must be of the form 0xffxxxx.\n    // By xoring with 0xdead, we ensure that the value will be different\n    // from the original one, even if it already starts with 0xff.\n    var forkValue = sighashType >> 8;\n    var newForkValue =  0xff0000 | ( forkValue ^ 0xdead);\n    sighashType =  (newForkValue << 8) | (sighashType & 0xff)\n  }\n\n  if ( ( sighashType & Signature.SIGHASH_FORKID)  && (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) ) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  }\n\n  // For no ForkId sighash, separators need to be removed.\n  subscript.removeCodeseparators();\n\n  var i;\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n  \n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @param {signingMethod} signingMethod \"ecdsa\" or \"schnorr\" to sign a tx\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN, flags, signingMethod) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN, flags);\n\n  signingMethod = signingMethod || \"ecdsa\";\n  let sig;\n\n  if (signingMethod === \"schnorr\") {\n    sig = Schnorr.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  } else if (signingMethod === \"ecdsa\") {\n    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @param {flags} verification flags\n * @param {signingMethod} signingMethod \"ecdsa\" or \"schnorr\" to sign a tx\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN, flags, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN, flags);\n  \n  signingMethod = signingMethod || \"ecdsa\";\n\n  if (signingMethod === \"schnorr\") {\n    return Schnorr.verify(hashbuf, signature, publicKey, 'little')\n  } else if(signingMethod === \"ecdsa\") {\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"]},"metadata":{},"sourceType":"script"}