{"ast":null,"code":"var baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar ecdsa = require('./ecdsa');\n\nvar randomBytes = require('randombytes');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar wif = require('wif');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ecurve = require('ecurve');\n\nvar curve = ecurve.getCurveByName('secp256k1');\nvar secp256k1 = ecdsa.__curve;\n\nvar fastcurve = require('./fastcurve');\n\nfunction ECPair(d, Q, options) {\n  if (options) {\n    typeforce({\n      compressed: types.maybe(types.Boolean),\n      network: types.maybe(types.Network)\n    }, options);\n  }\n\n  options = options || {};\n\n  if (d) {\n    if (d.signum() <= 0) throw new Error('Private key must be greater than 0');\n    if (d.compareTo(secp256k1.n) >= 0) throw new Error('Private key must be less than the curve order');\n    if (Q) throw new TypeError('Unexpected publicKey parameter');\n    this.d = d;\n  } else {\n    typeforce(types.ECPoint, Q);\n    this.__Q = Q;\n  }\n\n  this.compressed = options.compressed === undefined ? true : options.compressed;\n  this.network = options.network || NETWORKS.bitcoin;\n}\n\nObject.defineProperty(ECPair.prototype, 'Q', {\n  get: function () {\n    if (!this.__Q && this.d) {\n      const qBuf = fastcurve.publicKeyCreate(this.d.toBuffer(32), false);\n      this.__Q = qBuf ? ecurve.Point.decodeFrom(curve, qBuf) : secp256k1.G.multiply(this.d);\n    }\n\n    return this.__Q;\n  }\n});\n\nECPair.fromPublicKeyBuffer = function (buffer, network) {\n  var Q = ecurve.Point.decodeFrom(secp256k1, buffer);\n  return new ECPair(null, Q, {\n    compressed: Q.compressed,\n    network: network\n  });\n};\n\nECPair.fromWIF = function (string, network) {\n  var decoded = wif.decode(string);\n  var version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  var d = BigInteger.fromBuffer(decoded.privateKey);\n  return new ECPair(d, null, {\n    compressed: decoded.compressed,\n    network: network\n  });\n};\n\nECPair.makeRandom = function (options) {\n  options = options || {};\n  var rng = options.rng || randomBytes;\n  var d;\n\n  do {\n    var buffer = rng(32);\n    typeforce(types.Buffer256bit, buffer);\n    d = BigInteger.fromBuffer(buffer);\n  } while (d.signum() <= 0 || d.compareTo(secp256k1.n) >= 0);\n\n  return new ECPair(d, null, options);\n};\n\nECPair.prototype.getAddress = function () {\n  return baddress.toBase58Check(bcrypto.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash);\n};\n\nECPair.prototype.getNetwork = function () {\n  return this.network;\n};\n\nECPair.prototype.getPublicKeyBuffer = function () {\n  return this.Q.getEncoded(this.compressed);\n};\n\nECPair.prototype.sign = function (hash) {\n  if (!this.d) throw new Error('Missing private key');\n  var sig = fastcurve.sign(hash, this.d);\n  if (sig !== undefined) return sig;\n  return ecdsa.sign(hash, this.d);\n};\n\nECPair.prototype.toWIF = function () {\n  if (!this.d) throw new Error('Missing private key');\n  return wif.encode(this.network.wif, this.d.toBuffer(32), this.compressed);\n};\n\nECPair.prototype.verify = function (hash, signature) {\n  var fastsig = fastcurve.verify(hash, signature, this.getPublicKeyBuffer());\n  if (fastsig !== undefined) return fastsig;\n  return ecdsa.verify(hash, signature, this.Q);\n};\n/**\n * @deprecated\n * Use {@see keyutil.privateKeyBufferToECPair} instead\n * Will be removed in next major version (BLOCK-267)\n */\n\n\nECPair.fromPrivateKeyBuffer = function (buffer, network) {\n  // toplevel import unavailable due to circular dependency\n  var keyutil = require('./bitgo/keyutil');\n\n  return keyutil.privateKeyBufferToECPair(buffer, network);\n};\n/**\n * @deprecated\n * Use {@see keyutil.privateKeyBufferFromECPair} instead\n * Will be removed in next major version (BLOCK-267)\n */\n\n\nECPair.prototype.getPrivateKeyBuffer = function () {\n  // toplevel import unavailable due to circular dependency\n  var keyutil = require('./bitgo/keyutil');\n\n  return keyutil.privateKeyBufferFromECPair(this);\n};\n\nmodule.exports = ECPair;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitgo-utxo-lib/src/ecpair.js"],"names":["baddress","require","bcrypto","ecdsa","randomBytes","typeforce","types","wif","NETWORKS","BigInteger","ecurve","curve","getCurveByName","secp256k1","__curve","fastcurve","ECPair","d","Q","options","compressed","maybe","Boolean","network","Network","signum","Error","compareTo","n","TypeError","ECPoint","__Q","undefined","bitcoin","Object","defineProperty","prototype","get","qBuf","publicKeyCreate","toBuffer","Point","decodeFrom","G","multiply","fromPublicKeyBuffer","buffer","fromWIF","string","decoded","decode","version","Array","filter","x","pop","fromBuffer","privateKey","makeRandom","rng","Buffer256bit","getAddress","toBase58Check","hash160","getPublicKeyBuffer","getNetwork","pubKeyHash","getEncoded","sign","hash","sig","toWIF","encode","verify","signature","fastsig","fromPrivateKeyBuffer","keyutil","privateKeyBufferToECPair","getPrivateKeyBuffer","privateKeyBufferFromECPair","module","exports"],"mappings":"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","sourcesContent":["var baddress = require('./address')\nvar bcrypto = require('./crypto')\nvar ecdsa = require('./ecdsa')\nvar randomBytes = require('randombytes')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar wif = require('wif')\n\nvar NETWORKS = require('./networks')\nvar BigInteger = require('bigi')\n\nvar ecurve = require('ecurve')\nvar curve = ecurve.getCurveByName('secp256k1')\nvar secp256k1 = ecdsa.__curve\n\nvar fastcurve = require('./fastcurve')\n\nfunction ECPair (d, Q, options) {\n  if (options) {\n    typeforce({\n      compressed: types.maybe(types.Boolean),\n      network: types.maybe(types.Network)\n    }, options)\n  }\n\n  options = options || {}\n\n  if (d) {\n    if (d.signum() <= 0) throw new Error('Private key must be greater than 0')\n    if (d.compareTo(secp256k1.n) >= 0) throw new Error('Private key must be less than the curve order')\n    if (Q) throw new TypeError('Unexpected publicKey parameter')\n\n    this.d = d\n  } else {\n    typeforce(types.ECPoint, Q)\n\n    this.__Q = Q\n  }\n\n  this.compressed = options.compressed === undefined ? true : options.compressed\n  this.network = options.network || NETWORKS.bitcoin\n}\n\nObject.defineProperty(ECPair.prototype, 'Q', {\n  get: function () {\n    if (!this.__Q && this.d) {\n      const qBuf = fastcurve.publicKeyCreate(this.d.toBuffer(32), false)\n      this.__Q = qBuf ? ecurve.Point.decodeFrom(curve, qBuf) : secp256k1.G.multiply(this.d)\n    }\n\n    return this.__Q\n  }\n})\n\nECPair.fromPublicKeyBuffer = function (buffer, network) {\n  var Q = ecurve.Point.decodeFrom(secp256k1, buffer)\n\n  return new ECPair(null, Q, {\n    compressed: Q.compressed,\n    network: network\n  })\n}\nECPair.fromWIF = function (string, network) {\n  var decoded = wif.decode(string)\n  var version = decoded.version\n\n  // list of networks?\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif\n    }).pop()\n\n    if (!network) throw new Error('Unknown network version')\n\n  // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin\n\n    if (version !== network.wif) throw new Error('Invalid network version')\n  }\n\n  var d = BigInteger.fromBuffer(decoded.privateKey)\n\n  return new ECPair(d, null, {\n    compressed: decoded.compressed,\n    network: network\n  })\n}\n\nECPair.makeRandom = function (options) {\n  options = options || {}\n\n  var rng = options.rng || randomBytes\n\n  var d\n  do {\n    var buffer = rng(32)\n    typeforce(types.Buffer256bit, buffer)\n\n    d = BigInteger.fromBuffer(buffer)\n  } while (d.signum() <= 0 || d.compareTo(secp256k1.n) >= 0)\n\n  return new ECPair(d, null, options)\n}\n\nECPair.prototype.getAddress = function () {\n  return baddress.toBase58Check(bcrypto.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash)\n}\n\nECPair.prototype.getNetwork = function () {\n  return this.network\n}\n\nECPair.prototype.getPublicKeyBuffer = function () {\n  return this.Q.getEncoded(this.compressed)\n}\n\nECPair.prototype.sign = function (hash) {\n  if (!this.d) throw new Error('Missing private key')\n\n  var sig = fastcurve.sign(hash, this.d)\n  if (sig !== undefined) return sig\n  return ecdsa.sign(hash, this.d)\n}\n\nECPair.prototype.toWIF = function () {\n  if (!this.d) throw new Error('Missing private key')\n\n  return wif.encode(this.network.wif, this.d.toBuffer(32), this.compressed)\n}\n\nECPair.prototype.verify = function (hash, signature) {\n  var fastsig = fastcurve.verify(hash, signature, this.getPublicKeyBuffer())\n  if (fastsig !== undefined) return fastsig\n  return ecdsa.verify(hash, signature, this.Q)\n}\n\n/**\n * @deprecated\n * Use {@see keyutil.privateKeyBufferToECPair} instead\n * Will be removed in next major version (BLOCK-267)\n */\nECPair.fromPrivateKeyBuffer = function (buffer, network) {\n  // toplevel import unavailable due to circular dependency\n  var keyutil = require('./bitgo/keyutil')\n  return keyutil.privateKeyBufferToECPair(buffer, network)\n}\n\n/**\n * @deprecated\n * Use {@see keyutil.privateKeyBufferFromECPair} instead\n * Will be removed in next major version (BLOCK-267)\n */\nECPair.prototype.getPrivateKeyBuffer = function () {\n  // toplevel import unavailable due to circular dependency\n  var keyutil = require('./bitgo/keyutil')\n  return keyutil.privateKeyBufferFromECPair(this)\n}\n\nmodule.exports = ECPair\n"]},"metadata":{},"sourceType":"script"}