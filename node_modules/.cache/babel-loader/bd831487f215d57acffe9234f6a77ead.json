{"ast":null,"code":"'use strict'; // Important references for schnorr implementation\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-11-15-schnorrmultisig.md#wallet-implementation-guidelines\n\nvar BN = require('./bn');\n\nvar Point = require('./point');\n\nvar Signature = require('./signature');\n\nvar PublicKey = require('../publickey');\n\nvar Random = require('./random');\n\nvar Hash = require('./hash');\n\nvar BufferUtil = require('../util/buffer');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar Schnorr = function Schnorr(obj) {\n  if (!(this instanceof Schnorr)) {\n    return new Schnorr(obj);\n  }\n\n  if (obj) {\n    this.set(obj);\n  }\n};\n/**\n   * Function written to ensure r part of signature is at least 32 bytes, when converting \n   * from a BN to type Buffer.\n   * The BN type naturally cuts off leading zeros, e.g.\n   * <BN: 4f92d8094f710bc11b93935ac157730dda26c5c2a856650dbd8ebcd730d2d4> 31 bytes\n   * Buffer <00 4f 92 d8 09 4f 71 0b c1 1b 93 93 5a c1 57 73 0d da 26 c5 c2 a8 56 65 0d bd 8e bc d7 30 d2 d4> 32 bytes\n   * Both types are equal, however Schnorr signatures must be a minimum of 64 bytes.\n   * In a previous implementation of this schnorr module, was resulting in 63 byte signatures. \n   * (Although it would have been verified, it's proper to ensure the min requirement)\n   * @param {*} s BN\n   * @return {Buffer}\n   */\n\n\nfunction getrBuffer(r) {\n  let rNaturalLength = r.toBuffer().length;\n\n  if (rNaturalLength < 32) {\n    return r.toBuffer({\n      size: 32\n    });\n  }\n\n  return r.toBuffer();\n}\n/**\n * Function written to ensure s part of signature is at least 32 bytes, when converting \n * from a BN to type Buffer.\n * The BN type naturally cuts off leading zeros, e.g.\n * <BN: 4f92d8094f710bc11b93935ac157730dda26c5c2a856650dbd8ebcd730d2d4> 31 bytes\n * Buffer <00 4f 92 d8 09 4f 71 0b c1 1b 93 93 5a c1 57 73 0d da 26 c5 c2 a8 56 65 0d bd 8e bc d7 30 d2 d4> 32 bytes\n * Both types are equal, however Schnorr signatures must be a minimum of 64 bytes.\n * In a previous implementation of this schnorr module, was resulting in 63 byte signatures. \n * (Although it would have been verified, it's proper to ensure the min requirement)\n * @param {*} s BN\n * @return {Buffer}\n */\n\n\nfunction getsBuffer(s) {\n  let sNaturalLength = s.toBuffer().length;\n\n  if (sNaturalLength < 32) {\n    return s.toBuffer({\n      size: 32\n    });\n  }\n\n  return s.toBuffer();\n}\n/* jshint maxcomplexity: 9 */\n\n\nSchnorr.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; // the endianness of hashbuf\n\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nSchnorr.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nSchnorr.prototype.toPublicKey = function () {\n  return this.privkey.toPublicKey();\n};\n\nSchnorr.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n\n  obj.compressed = this.pubkey.compressed;\n  obj.isSchnorr = true;\n  this.sig = new Signature(obj);\n  return this;\n};\n/**\n * Schnorr implementation used from bitcoinabc at https://reviews.bitcoinabc.org/D2501\n */\n\n\nSchnorr.prototype._findSignature = function (d, e) {\n  // d is the private key;\n  // e is the message to be signed\n  let n = Point.getN();\n  let G = Point.getG();\n  $.checkState(!d.lte(new BN(0)), new Error('privkey out of field of curve'));\n  $.checkState(!d.gte(n), new Error('privkey out of field of curve'));\n  let k = this.nonceFunctionRFC6979(d.toBuffer({\n    size: 32\n  }), e.toBuffer({\n    size: 32\n  }));\n  let P = G.mul(d);\n  let R = G.mul(k); // Find deterministic k\n\n  if (R.hasSquare()) {\n    k = k;\n  } else {\n    k = n.sub(k);\n  }\n\n  let r = R.getX();\n  let e0 = BN.fromBuffer(Hash.sha256(Buffer.concat([getrBuffer(r), Point.pointToCompressed(P), e.toBuffer({\n    size: 32\n  })])));\n  let s = e0.mul(d).add(k).mod(n);\n  return {\n    r: r,\n    s: s\n  };\n};\n\nSchnorr.prototype.sigError = function () {\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  let sigLength = getrBuffer(this.sig.r).length + getsBuffer(this.sig.s).length;\n\n  if (!(sigLength === 64 || sigLength === 65)) {\n    return 'signature must be a 64 byte or 65 byte array';\n  }\n\n  let hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  let P = this.pubkey.point;\n  let G = Point.getG();\n  if (P.isInfinity()) return true;\n  let r = this.sig.r;\n  let s = this.sig.s;\n  let p = new BN('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F', 'hex');\n  let n = Point.getN();\n\n  if (r.gte(p) || s.gte(n)) {\n    // (\"Failed >= condition\") \n    return true;\n  }\n\n  let Br = getrBuffer(this.sig.r);\n  let Bp = Point.pointToCompressed(P);\n  let hash = Hash.sha256(Buffer.concat([Br, Bp, hashbuf]));\n  let e = BN.fromBuffer(hash, 'big').umod(n);\n  let sG = G.mul(s);\n  let eP = P.mul(n.sub(e));\n  let R = sG.add(eP);\n\n  if (R.isInfinity() || !R.hasSquare() || !R.getX().eq(r)) {\n    return true;\n  }\n\n  return false;\n};\n\nSchnorr.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n\n  return this;\n};\n/**\n * RFC6979 deterministic nonce generation used from https://reviews.bitcoinabc.org/D2501\n * @param {Buffer} privkeybuf \n * @param {Buffer} msgbuf \n * @return k {BN}\n */\n\n\nSchnorr.prototype.nonceFunctionRFC6979 = function (privkey, msgbuf) {\n  let V = Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\", \"hex\");\n  let K = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  let blob = Buffer.concat([privkey, msgbuf, Buffer.from(\"\", \"ascii\"), Buffer.from(\"Schnorr+SHA256  \", \"ascii\")]);\n  K = Hash.sha256hmac(Buffer.concat([V, Buffer.from('00', 'hex'), blob]), K);\n  V = Hash.sha256hmac(V, K);\n  K = Hash.sha256hmac(Buffer.concat([V, Buffer.from('01', 'hex'), blob]), K);\n  V = Hash.sha256hmac(V, K);\n  let k = new BN(0);\n  let T;\n\n  while (true) {\n    V = Hash.sha256hmac(V, K);\n    T = BN.fromBuffer(V);\n    k = T;\n    $.checkState(V.length >= 32, \"V length should be >= 32\");\n\n    if (k.gt(new BN(0)) && k.lt(Point.getN())) {\n      break;\n    }\n\n    K = Hash.sha256hmac(Buffer.concat([V, Buffer.from(\"00\", 'hex')]), K);\n    V = Hash.hmac(Hash.sha256, V, K);\n  }\n\n  return k;\n};\n\nSchnorr.sign = function (hashbuf, privkey, endian) {\n  return Schnorr().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\n\nSchnorr.verify = function (hashbuf, sig, pubkey, endian) {\n  return Schnorr().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\n\nmodule.exports = Schnorr;","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitcore-lib-cash/lib/crypto/schnorr.js"],"names":["BN","require","Point","Signature","PublicKey","Random","Hash","BufferUtil","_","$","Schnorr","obj","set","getrBuffer","r","rNaturalLength","toBuffer","length","size","getsBuffer","s","sNaturalLength","prototype","hashbuf","endian","privkey","pubkey","publicKey","sig","verified","privkey2pubkey","toPublicKey","sign","d","bn","checkState","Error","isBuffer","e","fromBuffer","undefined","_findSignature","compressed","isSchnorr","n","getN","G","getG","lte","gte","k","nonceFunctionRFC6979","P","mul","R","hasSquare","sub","getX","e0","sha256","Buffer","concat","pointToCompressed","add","mod","sigError","sigLength","reverse","point","isInfinity","p","Br","Bp","hash","umod","sG","eP","eq","verify","msgbuf","V","from","K","blob","sha256hmac","T","gt","lt","hmac","module","exports"],"mappings":"AAAA,a,CAEA;AACA;AACA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAhB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAvB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIK,IAAI,GAAGL,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAIM,UAAU,GAAGN,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAIO,CAAC,GAAGP,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIQ,CAAC,GAAGR,OAAO,CAAC,uBAAD,CAAf;;AAEA,IAAIS,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAClC,MAAI,EAAE,gBAAgBD,OAAlB,CAAJ,EAAgC;AAC9B,WAAO,IAAIA,OAAJ,CAAYC,GAAZ,CAAP;AACD;;AACD,MAAIA,GAAJ,EAAS;AACP,SAAKC,GAAL,CAASD,GAAT;AACD;AACF,CAPD;AASA;;;;;;;;;;;;;;AAYE,SAASE,UAAT,CAAoBC,CAApB,EAAuB;AAErB,MAAIC,cAAc,GAAGD,CAAC,CAACE,QAAF,GAAaC,MAAlC;;AAGA,MAAIF,cAAc,GAAG,EAArB,EAAyB;AACvB,WAAOD,CAAC,CAACE,QAAF,CAAW;AAACE,MAAAA,IAAI,EAAE;AAAP,KAAX,CAAP;AACD;;AACD,SAAOJ,CAAC,CAACE,QAAF,EAAP;AACD;AAED;;;;;;;;;;;;;;AAYA,SAASG,UAAT,CAAoBC,CAApB,EAAuB;AACrB,MAAIC,cAAc,GAAGD,CAAC,CAACJ,QAAF,GAAaC,MAAlC;;AAGA,MAAII,cAAc,GAAG,EAArB,EAAyB;AACvB,WAAOD,CAAC,CAACJ,QAAF,CAAW;AAACE,MAAAA,IAAI,EAAE;AAAP,KAAX,CAAP;AACD;;AACD,SAAOE,CAAC,CAACJ,QAAF,EAAP;AACD;AAEH;;;AACAN,OAAO,CAACY,SAAR,CAAkBV,GAAlB,GAAwB,UAASD,GAAT,EAAc;AAClC,OAAKY,OAAL,GAAeZ,GAAG,CAACY,OAAJ,IAAe,KAAKA,OAAnC;AACA,OAAKC,MAAL,GAAcb,GAAG,CAACa,MAAJ,IAAc,KAAKA,MAAjC,CAFkC,CAEO;;AACzC,OAAKC,OAAL,GAAed,GAAG,CAACc,OAAJ,IAAe,KAAKA,OAAnC;AACA,OAAKC,MAAL,GAAcf,GAAG,CAACe,MAAJ,KAAe,KAAKD,OAAL,GAAe,KAAKA,OAAL,CAAaE,SAA5B,GAAwC,KAAKD,MAA5D,CAAd;AACA,OAAKE,GAAL,GAAWjB,GAAG,CAACiB,GAAJ,IAAW,KAAKA,GAA3B;AACA,OAAKC,QAAL,GAAgBlB,GAAG,CAACkB,QAAJ,IAAgB,KAAKA,QAArC;AACA,SAAO,IAAP;AACH,CARD;;AAUAnB,OAAO,CAACY,SAAR,CAAkBQ,cAAlB,GAAmC,YAAW;AAC1C,OAAKJ,MAAL,GAAc,KAAKD,OAAL,CAAaM,WAAb,EAAd;AACH,CAFD;;AAIArB,OAAO,CAACY,SAAR,CAAkBS,WAAlB,GAAgC,YAAW;AACzC,SAAO,KAAKN,OAAL,CAAaM,WAAb,EAAP;AACD,CAFD;;AAIArB,OAAO,CAACY,SAAR,CAAkBU,IAAlB,GAAyB,YAAW;AAChC,MAAIT,OAAO,GAAG,KAAKA,OAAnB;AACA,MAAIE,OAAO,GAAG,KAAKA,OAAnB;AACA,MAAIQ,CAAC,GAAGR,OAAO,CAACS,EAAhB;AAEAzB,EAAAA,CAAC,CAAC0B,UAAF,CAAaZ,OAAO,IAAIE,OAAX,IAAsBQ,CAAnC,EAAsC,IAAIG,KAAJ,CAAU,oBAAV,CAAtC;AACA3B,EAAAA,CAAC,CAAC0B,UAAF,CAAa5B,UAAU,CAAC8B,QAAX,CAAoBd,OAApB,KAAgCA,OAAO,CAACN,MAAR,KAAmB,EAAhE,EAAoE,IAAImB,KAAJ,CAAU,kCAAV,CAApE;AAEA,MAAIE,CAAC,GAAGtC,EAAE,CAACuC,UAAH,CAAchB,OAAd,EAAuB,KAAKC,MAAL,GAAc;AAC3CA,IAAAA,MAAM,EAAE,KAAKA;AAD8B,GAAd,GAE3BgB,SAFI,CAAR;;AAIA,MAAI7B,GAAG,GAAG,KAAK8B,cAAL,CAAoBR,CAApB,EAAuBK,CAAvB,CAAV;;AACA3B,EAAAA,GAAG,CAAC+B,UAAJ,GAAiB,KAAKhB,MAAL,CAAYgB,UAA7B;AACA/B,EAAAA,GAAG,CAACgC,SAAJ,GAAgB,IAAhB;AAEA,OAAKf,GAAL,GAAW,IAAIzB,SAAJ,CAAcQ,GAAd,CAAX;AACA,SAAO,IAAP;AACH,CAlBD;AAoBA;;;;;AAGAD,OAAO,CAACY,SAAR,CAAkBmB,cAAlB,GAAmC,UAASR,CAAT,EAAYK,CAAZ,EAAe;AAC9C;AACA;AAEA,MAAIM,CAAC,GAAG1C,KAAK,CAAC2C,IAAN,EAAR;AACA,MAAIC,CAAC,GAAG5C,KAAK,CAAC6C,IAAN,EAAR;AAEAtC,EAAAA,CAAC,CAAC0B,UAAF,CAAa,CAACF,CAAC,CAACe,GAAF,CAAM,IAAIhD,EAAJ,CAAO,CAAP,CAAN,CAAd,EAAgC,IAAIoC,KAAJ,CAAU,+BAAV,CAAhC;AACA3B,EAAAA,CAAC,CAAC0B,UAAF,CAAa,CAACF,CAAC,CAACgB,GAAF,CAAML,CAAN,CAAd,EAAwB,IAAIR,KAAJ,CAAU,+BAAV,CAAxB;AAGA,MAAIc,CAAC,GAAG,KAAKC,oBAAL,CAA0BlB,CAAC,CAACjB,QAAF,CAAW;AAAEE,IAAAA,IAAI,EAAE;AAAR,GAAX,CAA1B,EAAoDoB,CAAC,CAACtB,QAAF,CAAW;AAAEE,IAAAA,IAAI,EAAE;AAAR,GAAX,CAApD,CAAR;AAEA,MAAIkC,CAAC,GAAGN,CAAC,CAACO,GAAF,CAAMpB,CAAN,CAAR;AACA,MAAIqB,CAAC,GAAGR,CAAC,CAACO,GAAF,CAAMH,CAAN,CAAR,CAd8C,CAgB9C;;AACA,MAAGI,CAAC,CAACC,SAAF,EAAH,EAAkB;AAChBL,IAAAA,CAAC,GAAGA,CAAJ;AACD,GAFD,MAEO;AACLA,IAAAA,CAAC,GAAGN,CAAC,CAACY,GAAF,CAAMN,CAAN,CAAJ;AACD;;AAED,MAAIpC,CAAC,GAAGwC,CAAC,CAACG,IAAF,EAAR;AACA,MAAIC,EAAE,GAAG1D,EAAE,CAACuC,UAAH,CAAcjC,IAAI,CAACqD,MAAL,CAAYC,MAAM,CAACC,MAAP,CAAc,CAAChD,UAAU,CAACC,CAAD,CAAX,EAAgBZ,KAAK,CAAC4D,iBAAN,CAAwBV,CAAxB,CAAhB,EAA4Cd,CAAC,CAACtB,QAAF,CAAW;AAAEE,IAAAA,IAAI,EAAE;AAAR,GAAX,CAA5C,CAAd,CAAZ,CAAd,CAAT;AAEA,MAAIE,CAAC,GAAKsC,EAAE,CAACL,GAAH,CAAOpB,CAAP,CAAD,CAAY8B,GAAZ,CAAgBb,CAAhB,CAAD,CAAqBc,GAArB,CAAyBpB,CAAzB,CAAR;AAEA,SAAO;AACL9B,IAAAA,CAAC,EAAEA,CADE;AAELM,IAAAA,CAAC,EAAEA;AAFE,GAAP;AAID,CAhCH;;AAmCEV,OAAO,CAACY,SAAR,CAAkB2C,QAAlB,GAA6B,YAAW;AACtC,MAAI,CAAC1D,UAAU,CAAC8B,QAAX,CAAoB,KAAKd,OAAzB,CAAD,IAAsC,KAAKA,OAAL,CAAaN,MAAb,KAAwB,EAAlE,EAAsE;AACpE,WAAO,kCAAP;AACD;;AAED,MAAIiD,SAAS,GAAGrD,UAAU,CAAC,KAAKe,GAAL,CAASd,CAAV,CAAV,CAAuBG,MAAvB,GAAgCE,UAAU,CAAC,KAAKS,GAAL,CAASR,CAAV,CAAV,CAAuBH,MAAvE;;AAEA,MAAG,EAAEiD,SAAS,KAAK,EAAd,IAAoBA,SAAS,KAAK,EAApC,CAAH,EAA4C;AAC1C,WAAO,8CAAP;AACD;;AAED,MAAI3C,OAAO,GAAG,KAAKC,MAAL,KAAgB,QAAhB,GAA2BjB,UAAU,CAAC4D,OAAX,CAAmB,KAAK5C,OAAxB,CAA3B,GAA8D,KAAKA,OAAjF;AAEA,MAAI6B,CAAC,GAAG,KAAK1B,MAAL,CAAY0C,KAApB;AACA,MAAItB,CAAC,GAAG5C,KAAK,CAAC6C,IAAN,EAAR;AAEA,MAAGK,CAAC,CAACiB,UAAF,EAAH,EAAmB,OAAO,IAAP;AAEnB,MAAIvD,CAAC,GAAG,KAAKc,GAAL,CAASd,CAAjB;AACA,MAAIM,CAAC,GAAG,KAAKQ,GAAL,CAASR,CAAjB;AAEA,MAAIkD,CAAC,GAAG,IAAItE,EAAJ,CAAO,kEAAP,EAA2E,KAA3E,CAAR;AACA,MAAI4C,CAAC,GAAG1C,KAAK,CAAC2C,IAAN,EAAR;;AAEA,MAAG/B,CAAC,CAACmC,GAAF,CAAMqB,CAAN,KAAYlD,CAAC,CAAC6B,GAAF,CAAML,CAAN,CAAf,EAAyB;AACvB;AACA,WAAO,IAAP;AACD;;AAED,MAAI2B,EAAE,GAAG1D,UAAU,CAAC,KAAKe,GAAL,CAASd,CAAV,CAAnB;AACA,MAAI0D,EAAE,GAAGtE,KAAK,CAAC4D,iBAAN,CAAwBV,CAAxB,CAAT;AAEA,MAAIqB,IAAI,GAAGnE,IAAI,CAACqD,MAAL,CAAYC,MAAM,CAACC,MAAP,CAAc,CAACU,EAAD,EAAKC,EAAL,EAASjD,OAAT,CAAd,CAAZ,CAAX;AACA,MAAIe,CAAC,GAAGtC,EAAE,CAACuC,UAAH,CAAckC,IAAd,EAAoB,KAApB,EAA2BC,IAA3B,CAAgC9B,CAAhC,CAAR;AAEA,MAAI+B,EAAE,GAAG7B,CAAC,CAACO,GAAF,CAAMjC,CAAN,CAAT;AACA,MAAIwD,EAAE,GAAGxB,CAAC,CAACC,GAAF,CAAMT,CAAC,CAACY,GAAF,CAAMlB,CAAN,CAAN,CAAT;AACA,MAAIgB,CAAC,GAAGqB,EAAE,CAACZ,GAAH,CAAOa,EAAP,CAAR;;AAEA,MAAGtB,CAAC,CAACe,UAAF,MAAkB,CAACf,CAAC,CAACC,SAAF,EAAnB,IAAoC,CAACD,CAAC,CAACG,IAAF,GAASoB,EAAT,CAAY/D,CAAZ,CAAxC,EAAwD;AACtD,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD,CA3CD;;AA6CAJ,OAAO,CAACY,SAAR,CAAkBwD,MAAlB,GAA2B,YAAW;AAEpC,MAAI,CAAC,KAAKb,QAAL,EAAL,EAAsB;AACpB,SAAKpC,QAAL,GAAgB,IAAhB;AACD,GAFD,MAEO;AACL,SAAKA,QAAL,GAAgB,KAAhB;AACD;;AACD,SAAO,IAAP;AACD,CARD;AAUA;;;;;;;;AAMAnB,OAAO,CAACY,SAAR,CAAkB6B,oBAAlB,GAAyC,UAAS1B,OAAT,EAAkBsD,MAAlB,EAA0B;AACjE,MAAIC,CAAC,GAAGpB,MAAM,CAACqB,IAAP,CAAY,kEAAZ,EAA+E,KAA/E,CAAR;AACA,MAAIC,CAAC,GAAGtB,MAAM,CAACqB,IAAP,CAAY,kEAAZ,EAA+E,KAA/E,CAAR;AAEA,MAAIE,IAAI,GAAGvB,MAAM,CAACC,MAAP,CAAc,CAACpC,OAAD,EAAUsD,MAAV,EAAkBnB,MAAM,CAACqB,IAAP,CAAY,EAAZ,EAAgB,OAAhB,CAAlB,EAA4CrB,MAAM,CAACqB,IAAP,CAAY,kBAAZ,EAAgC,OAAhC,CAA5C,CAAd,CAAX;AAEAC,EAAAA,CAAC,GAAG5E,IAAI,CAAC8E,UAAL,CAAgBxB,MAAM,CAACC,MAAP,CAAc,CAACmB,CAAD,EAAIpB,MAAM,CAACqB,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAJ,EAA8BE,IAA9B,CAAd,CAAhB,EAAoED,CAApE,CAAJ;AACAF,EAAAA,CAAC,GAAG1E,IAAI,CAAC8E,UAAL,CAAgBJ,CAAhB,EAAkBE,CAAlB,CAAJ;AAEAA,EAAAA,CAAC,GAAG5E,IAAI,CAAC8E,UAAL,CAAgBxB,MAAM,CAACC,MAAP,CAAc,CAACmB,CAAD,EAAGpB,MAAM,CAACqB,IAAP,CAAY,IAAZ,EAAiB,KAAjB,CAAH,EAA4BE,IAA5B,CAAd,CAAhB,EAAkED,CAAlE,CAAJ;AACAF,EAAAA,CAAC,GAAG1E,IAAI,CAAC8E,UAAL,CAAgBJ,CAAhB,EAAkBE,CAAlB,CAAJ;AAEA,MAAIhC,CAAC,GAAG,IAAIlD,EAAJ,CAAO,CAAP,CAAR;AACA,MAAIqF,CAAJ;;AACA,SAAO,IAAP,EAAa;AACXL,IAAAA,CAAC,GAAG1E,IAAI,CAAC8E,UAAL,CAAgBJ,CAAhB,EAAkBE,CAAlB,CAAJ;AACAG,IAAAA,CAAC,GAAGrF,EAAE,CAACuC,UAAH,CAAcyC,CAAd,CAAJ;AAEA9B,IAAAA,CAAC,GAAGmC,CAAJ;AACA5E,IAAAA,CAAC,CAAC0B,UAAF,CAAa6C,CAAC,CAAC/D,MAAF,IAAY,EAAzB,EAA6B,0BAA7B;;AACA,QAAIiC,CAAC,CAACoC,EAAF,CAAK,IAAItF,EAAJ,CAAO,CAAP,CAAL,KAAmBkD,CAAC,CAACqC,EAAF,CAAKrF,KAAK,CAAC2C,IAAN,EAAL,CAAvB,EAA2C;AACzC;AACD;;AACDqC,IAAAA,CAAC,GAAG5E,IAAI,CAAC8E,UAAL,CAAgBxB,MAAM,CAACC,MAAP,CAAc,CAACmB,CAAD,EAAIpB,MAAM,CAACqB,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAJ,CAAd,CAAhB,EAA8DC,CAA9D,CAAJ;AACAF,IAAAA,CAAC,GAAG1E,IAAI,CAACkF,IAAL,CAAUlF,IAAI,CAACqD,MAAf,EAAuBqB,CAAvB,EAA0BE,CAA1B,CAAJ;AACD;;AACD,SAAOhC,CAAP;AACD,CA3BD;;AA6BAxC,OAAO,CAACsB,IAAR,GAAe,UAAST,OAAT,EAAkBE,OAAlB,EAA2BD,MAA3B,EAAmC;AAChD,SAAOd,OAAO,GAAGE,GAAV,CAAc;AACnBW,IAAAA,OAAO,EAAEA,OADU;AAEnBC,IAAAA,MAAM,EAAEA,MAFW;AAGnBC,IAAAA,OAAO,EAAEA;AAHU,GAAd,EAIJO,IAJI,GAIGJ,GAJV;AAKD,CAND;;AAQAlB,OAAO,CAACoE,MAAR,GAAiB,UAASvD,OAAT,EAAkBK,GAAlB,EAAuBF,MAAvB,EAA+BF,MAA/B,EAAuC;AACtD,SAAOd,OAAO,GAAGE,GAAV,CAAc;AACnBW,IAAAA,OAAO,EAAEA,OADU;AAEnBC,IAAAA,MAAM,EAAEA,MAFW;AAGnBI,IAAAA,GAAG,EAAEA,GAHc;AAInBF,IAAAA,MAAM,EAAEA;AAJW,GAAd,EAKJoD,MALI,GAKKjD,QALZ;AAMD,CAPD;;AASA4D,MAAM,CAACC,OAAP,GAAiBhF,OAAjB","sourcesContent":["'use strict';\n\n// Important references for schnorr implementation\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-11-15-schnorrmultisig.md#wallet-implementation-guidelines\n\nvar BN = require('./bn');\nvar Point = require('./point');\nvar Signature = require('./signature');\nvar PublicKey = require('../publickey');\nvar Random = require('./random');\nvar Hash = require('./hash');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\n\nvar Schnorr = function Schnorr(obj) {\n  if (!(this instanceof Schnorr)) {\n    return new Schnorr(obj);\n  }\n  if (obj) {\n    this.set(obj);\n  }\n};\n\n/**\n   * Function written to ensure r part of signature is at least 32 bytes, when converting \n   * from a BN to type Buffer.\n   * The BN type naturally cuts off leading zeros, e.g.\n   * <BN: 4f92d8094f710bc11b93935ac157730dda26c5c2a856650dbd8ebcd730d2d4> 31 bytes\n   * Buffer <00 4f 92 d8 09 4f 71 0b c1 1b 93 93 5a c1 57 73 0d da 26 c5 c2 a8 56 65 0d bd 8e bc d7 30 d2 d4> 32 bytes\n   * Both types are equal, however Schnorr signatures must be a minimum of 64 bytes.\n   * In a previous implementation of this schnorr module, was resulting in 63 byte signatures. \n   * (Although it would have been verified, it's proper to ensure the min requirement)\n   * @param {*} s BN\n   * @return {Buffer}\n   */\n  function getrBuffer(r) {\n\n    let rNaturalLength = r.toBuffer().length;\n\n\n    if (rNaturalLength < 32) {\n      return r.toBuffer({size: 32});\n    }\n    return r.toBuffer();\n  }\n\n  /**\n   * Function written to ensure s part of signature is at least 32 bytes, when converting \n   * from a BN to type Buffer.\n   * The BN type naturally cuts off leading zeros, e.g.\n   * <BN: 4f92d8094f710bc11b93935ac157730dda26c5c2a856650dbd8ebcd730d2d4> 31 bytes\n   * Buffer <00 4f 92 d8 09 4f 71 0b c1 1b 93 93 5a c1 57 73 0d da 26 c5 c2 a8 56 65 0d bd 8e bc d7 30 d2 d4> 32 bytes\n   * Both types are equal, however Schnorr signatures must be a minimum of 64 bytes.\n   * In a previous implementation of this schnorr module, was resulting in 63 byte signatures. \n   * (Although it would have been verified, it's proper to ensure the min requirement)\n   * @param {*} s BN\n   * @return {Buffer}\n   */\n  function getsBuffer(s) {\n    let sNaturalLength = s.toBuffer().length;\n\n\n    if (sNaturalLength < 32) {\n      return s.toBuffer({size: 32});\n    }\n    return s.toBuffer();\n  }\n\n/* jshint maxcomplexity: 9 */\nSchnorr.prototype.set = function(obj) {\n    this.hashbuf = obj.hashbuf || this.hashbuf;\n    this.endian = obj.endian || this.endian; // the endianness of hashbuf\n    this.privkey = obj.privkey || this.privkey;\n    this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n    this.sig = obj.sig || this.sig;\n    this.verified = obj.verified || this.verified;\n    return this;\n};\n\nSchnorr.prototype.privkey2pubkey = function() {\n    this.pubkey = this.privkey.toPublicKey();\n};\n\nSchnorr.prototype.toPublicKey = function() {\n  return this.privkey.toPublicKey();\n}\n\nSchnorr.prototype.sign = function() {\n    var hashbuf = this.hashbuf;\n    var privkey = this.privkey;\n    var d = privkey.bn;\n  \n    $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n    $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n\n    var e = BN.fromBuffer(hashbuf, this.endian ? {\n      endian: this.endian\n    } : undefined);\n    \n    var obj = this._findSignature(d, e);\n    obj.compressed = this.pubkey.compressed;\n    obj.isSchnorr = true;\n    \n    this.sig = new Signature(obj);\n    return this;\n};\n\n/**\n * Schnorr implementation used from bitcoinabc at https://reviews.bitcoinabc.org/D2501\n */\nSchnorr.prototype._findSignature = function(d, e) {\n    // d is the private key;\n    // e is the message to be signed\n\n    let n = Point.getN();\n    let G = Point.getG();\n\n    $.checkState(!d.lte(new BN(0)), new Error('privkey out of field of curve'));\n    $.checkState(!d.gte(n), new Error('privkey out of field of curve'));\n  \n    \n    let k = this.nonceFunctionRFC6979(d.toBuffer({ size: 32 }), e.toBuffer({ size: 32 }));\n\n    let P = G.mul(d);\n    let R = G.mul(k);\n\n    // Find deterministic k\n    if(R.hasSquare()) {\n      k = k;\n    } else {\n      k = n.sub(k);\n    }\n    \n    let r = R.getX();\n    let e0 = BN.fromBuffer(Hash.sha256(Buffer.concat([getrBuffer(r), Point.pointToCompressed(P), e.toBuffer({ size: 32 })])));\n    \n    let s = ((e0.mul(d)).add(k)).mod(n);\n\n    return {\n      r: r,\n      s: s\n    };\n  };\n  \n\n  Schnorr.prototype.sigError = function() {\n    if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n      return 'hashbuf must be a 32 byte buffer';\n    }\n\n    let sigLength = getrBuffer(this.sig.r).length + getsBuffer(this.sig.s).length;\n    \n    if(!(sigLength === 64 || sigLength === 65)) {\n      return 'signature must be a 64 byte or 65 byte array';\n    } \n\n    let hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf\n    \n    let P = this.pubkey.point;\n    let G = Point.getG();\n\n    if(P.isInfinity()) return true;\n    \n    let r = this.sig.r;\n    let s = this.sig.s;\n\n    let p = new BN('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F', 'hex');\n    let n = Point.getN();\n\n    if(r.gte(p) || s.gte(n)) {\n      // (\"Failed >= condition\") \n      return true;\n    }\n    \n    let Br = getrBuffer(this.sig.r);\n    let Bp = Point.pointToCompressed(P);\n    \n    let hash = Hash.sha256(Buffer.concat([Br, Bp, hashbuf]));\n    let e = BN.fromBuffer(hash, 'big').umod(n);\n    \n    let sG = G.mul(s);\n    let eP = P.mul(n.sub(e));\n    let R = sG.add(eP);\n    \n    if(R.isInfinity() || !R.hasSquare() || !R.getX().eq(r)) {\n      return true;\n    } \n    return false;\n  };\n\n  Schnorr.prototype.verify = function() {\n\n    if (!this.sigError()) {\n      this.verified = true;\n    } else {\n      this.verified = false;\n    }\n    return this;\n  };\n\n  /**\n   * RFC6979 deterministic nonce generation used from https://reviews.bitcoinabc.org/D2501\n   * @param {Buffer} privkeybuf \n   * @param {Buffer} msgbuf \n   * @return k {BN}\n   */\n  Schnorr.prototype.nonceFunctionRFC6979 = function(privkey, msgbuf) {\n    let V = Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\",\"hex\");\n    let K = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\",\"hex\");\n\n    let blob = Buffer.concat([privkey, msgbuf, Buffer.from(\"\", \"ascii\"), Buffer.from(\"Schnorr+SHA256  \", \"ascii\")]);\n\n    K = Hash.sha256hmac(Buffer.concat([V, Buffer.from('00', 'hex'), blob]), K);\n    V = Hash.sha256hmac(V,K); \n\n    K = Hash.sha256hmac(Buffer.concat([V,Buffer.from('01','hex'), blob]), K);\n    V = Hash.sha256hmac(V,K);\n\n    let k = new BN(0);\n    let T;\n    while (true) {\n      V = Hash.sha256hmac(V,K);\n      T = BN.fromBuffer(V);\n\n      k = T;\n      $.checkState(V.length >= 32, \"V length should be >= 32\");\n      if (k.gt(new BN(0)) && k.lt(Point.getN())) {\n        break;\n      }\n      K = Hash.sha256hmac(Buffer.concat([V, Buffer.from(\"00\", 'hex')]), K);\n      V = Hash.hmac(Hash.sha256, V, K);\n    }\n    return k;\n  }\n\n  Schnorr.sign = function(hashbuf, privkey, endian) {\n    return Schnorr().set({\n      hashbuf: hashbuf,\n      endian: endian,\n      privkey: privkey\n    }).sign().sig;\n  };\n  \n  Schnorr.verify = function(hashbuf, sig, pubkey, endian) {\n    return Schnorr().set({\n      hashbuf: hashbuf,\n      endian: endian,\n      sig: sig,\n      pubkey: pubkey\n    }).verify().verified;\n  };\n\n  module.exports = Schnorr;"]},"metadata":{},"sourceType":"script"}