{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Transaction = require('../transaction');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar Sighash = require('../sighash');\n\nvar PublicKey = require('../../publickey');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar TransactionSignature = require('../signature');\n/**\n * @constructor\n */\n\n\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else {\n    this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script), 'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n\n  this.threshold = threshold; // Empty array of signatures\n\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\n\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa';\n  var self = this;\n  var results = [];\n\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, signingMethod),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], \"Signature Undefined\"), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n  this._updateScript();\n\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function () {\n  this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures()));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function () {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), // Future signature types may need refactor of toDER\n  function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\n\nMultiSigInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, signingMethod);\n};\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @returns {TransactionSignature[]}\n */\n\n\nMultiSigInput.normalizeSignatures = function (transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script, signingMethod);\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function () {\n  return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitcore-lib/lib/transaction/input/multisig.js"],"names":["_","require","inherits","Transaction","Input","Output","$","Script","Signature","Sighash","PublicKey","BufferUtil","TransactionSignature","MultiSigInput","input","pubkeys","threshold","signatures","opts","apply","arguments","self","publicKeys","noSorting","sortBy","publicKey","toString","checkState","buildMultisigOut","equals","output","script","publicKeyIndex","each","index","_deserializeSignatures","Array","length","prototype","toObject","obj","map","_serializeSignatures","signature","undefined","getSignatures","transaction","privateKey","sigtype","hashData","signingMethod","SIGHASH_ALL","results","push","prevTxId","outputIndex","inputIndex","sign","addSignature","isFullySigned","checkArgument","isUndefined","isValidSignature","_updateScript","setScript","buildMultisigIn","_createSignatures","filter","concat","toDER","integerAsSingleByteBuffer","clearSignatures","countSignatures","countMissingSignatures","reduce","sum","publicKeysWithoutSignature","nhashtype","verify","normalizeSignatures","pubKey","signatureMatch","signatureBuffer","fromTxFormat","isMatch","OPCODES_SIZE","SIGNATURE_SIZE","_estimateSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Transaction = require('../transaction');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar PublicKey = require('../../publickey');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa';\n\n  var self = this;\n  var results = [];\n  _.each(this.publicKeys, function(publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, signingMethod),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], \"Signature Undefined\"),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function() {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures()\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    // Future signature types may need refactor of toDER\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script,\n    signingMethod\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script,\n          signingMethod\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n"]},"metadata":{},"sourceType":"script"}