{"ast":null,"code":"import createLogger from 'logging';\nimport eccrypto from 'eccrypto';\nimport ethUtils from 'ethereumjs-util';\nimport crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\nconst logger = createLogger('MewCrypto');\nexport default class MewConnectCrypto {\n  static create() {\n    return new MewConnectCrypto();\n  }\n\n  setPrivate(pvtKey) {\n    this.prvt = Buffer.from(pvtKey, 'hex');\n    this.pub = this.generatePublic(this.prvt);\n    return {\n      publicKey: this.pub,\n      privateKey: this.prvt\n    };\n  }\n\n  generateMessage() {\n    return crypto.randomBytes(32).toString('hex');\n  } // Not for the Address, but generate them for the connection check\n\n\n  prepareKey() {\n    this.prvt = this.generatePrivate();\n    this.pub = this.generatePublic(this.prvt);\n    return {\n      pub: this.pub,\n      pvt: this.prvt\n    };\n  }\n\n  generateKeys() {\n    this.prvt = this.generatePrivate();\n    this.pub = this.generatePublic(this.prvt);\n    return {\n      publicKey: this.pub,\n      privateKey: this.prvt\n    };\n  }\n\n  generatePrivate() {\n    let privKey;\n\n    do {\n      privKey = crypto.randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privKey));\n\n    return privKey;\n  }\n\n  generatePublic(privKey) {\n    const pvt = Buffer.from(privKey, 'hex');\n    this.prvt = pvt;\n    return secp256k1.publicKeyCreate(pvt);\n  }\n\n  encrypt(dataToSend) {\n    const publicKeyA = eccrypto.getPublic(this.prvt);\n    return new Promise((resolve, reject) => {\n      eccrypto.encrypt(publicKeyA, Buffer.from(dataToSend)).then(_initial => {\n        resolve(_initial);\n      }).catch(error => {\n        reject(error);\n      });\n    });\n  }\n\n  decrypt(dataToSee) {\n    return new Promise((resolve, reject) => {\n      eccrypto.decrypt(this.prvt, {\n        ciphertext: Buffer.from(dataToSee.ciphertext),\n        ephemPublicKey: Buffer.from(dataToSee.ephemPublicKey),\n        iv: Buffer.from(dataToSee.iv),\n        mac: Buffer.from(dataToSee.mac)\n      }).then(_initial => {\n        let result;\n\n        try {\n          if (this.isJSON(_initial)) {\n            const humanRadable = JSON.parse(_initial);\n\n            if (Array.isArray(humanRadable)) {\n              result = humanRadable[0];\n            } else {\n              result = humanRadable;\n            }\n          } else {\n            result = _initial.toString();\n          }\n        } catch (e) {\n          logger.error(e);\n        }\n\n        resolve(JSON.stringify(result));\n      }).catch(error => {\n        reject(error);\n      });\n    });\n  }\n\n  signMessage(msgToSign) {\n    return new Promise((resolve, reject) => {\n      try {\n        const msg = ethUtils.hashPersonalMessage(ethUtils.toBuffer(msgToSign));\n        const signed = ethUtils.ecsign(Buffer.from(msg), Buffer.from(this.prvt, 'hex'));\n        const combined = Buffer.concat([Buffer.from([signed.v]), Buffer.from(signed.r), Buffer.from(signed.s)]);\n        const combinedHex = combined.toString('hex');\n        resolve(combinedHex);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  signMessageSync(msgToSign) {\n    msgToSign = this.bufferToString(msgToSign);\n    const msg = ethUtils.hashPersonalMessage(ethUtils.toBuffer(msgToSign));\n    const signed = ethUtils.ecsign(Buffer.from(msg), Buffer.from(this.prvt, 'hex'));\n    const combined = Buffer.concat([Buffer.from([signed.v]), Buffer.from(signed.r), Buffer.from(signed.s)]);\n    return combined.toString('hex');\n  }\n\n  bufferToConnId(buf) {\n    return buf.toString('hex').slice(0, 32);\n  }\n\n  generateConnId(buf) {\n    if (buf instanceof Buffer) {\n      return buf.toString('hex').slice(0, 32);\n    }\n\n    return Buffer.from(buf).toString('hex').slice(0, 32);\n  }\n\n  isJSON(arg) {\n    try {\n      JSON.parse(arg);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  toBuffer(buf) {\n    if (buf instanceof Buffer) {\n      return buf;\n    }\n\n    return Buffer.from(buf, 'hex');\n  }\n\n  bufferToString(buf) {\n    if (buf instanceof Buffer) {\n      return buf.toString('hex');\n    }\n\n    return buf;\n  }\n\n}","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/@myetherwallet/mewconnect-web-client/src/connectClient/MewConnectCrypto.js"],"names":["createLogger","eccrypto","ethUtils","crypto","secp256k1","logger","MewConnectCrypto","create","setPrivate","pvtKey","prvt","Buffer","from","pub","generatePublic","publicKey","privateKey","generateMessage","randomBytes","toString","prepareKey","generatePrivate","pvt","generateKeys","privKey","privateKeyVerify","publicKeyCreate","encrypt","dataToSend","publicKeyA","getPublic","Promise","resolve","reject","then","_initial","catch","error","decrypt","dataToSee","ciphertext","ephemPublicKey","iv","mac","result","isJSON","humanRadable","JSON","parse","Array","isArray","e","stringify","signMessage","msgToSign","msg","hashPersonalMessage","toBuffer","signed","ecsign","combined","concat","v","r","s","combinedHex","signMessageSync","bufferToString","bufferToConnId","buf","slice","generateConnId","arg"],"mappings":"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","sourcesContent":["import createLogger from 'logging';\n\nimport eccrypto from 'eccrypto';\nimport ethUtils from 'ethereumjs-util';\nimport crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\n\nconst logger = createLogger('MewCrypto');\n\nexport default class MewConnectCrypto {\n  static create() {\n    return new MewConnectCrypto();\n  }\n\n  setPrivate(pvtKey) {\n    this.prvt = Buffer.from(pvtKey, 'hex');\n    this.pub = this.generatePublic(this.prvt);\n    return { publicKey: this.pub, privateKey: this.prvt };\n  }\n\n  generateMessage() {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  // Not for the Address, but generate them for the connection check\n  prepareKey() {\n    this.prvt = this.generatePrivate();\n    this.pub = this.generatePublic(this.prvt);\n    return { pub: this.pub, pvt: this.prvt };\n  }\n\n  generateKeys() {\n    this.prvt = this.generatePrivate();\n    this.pub = this.generatePublic(this.prvt);\n    return { publicKey: this.pub, privateKey: this.prvt };\n  }\n\n  generatePrivate() {\n    let privKey;\n    do {\n      privKey = crypto.randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privKey));\n    return privKey;\n  }\n\n  generatePublic(privKey) {\n    const pvt = Buffer.from(privKey, 'hex');\n    this.prvt = pvt;\n    return secp256k1.publicKeyCreate(pvt);\n  }\n\n  encrypt(dataToSend) {\n    const publicKeyA = eccrypto.getPublic(this.prvt);\n    return new Promise((resolve, reject) => {\n      eccrypto\n        .encrypt(publicKeyA, Buffer.from(dataToSend))\n        .then(_initial => {\n          resolve(_initial);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  }\n\n  decrypt(dataToSee) {\n    return new Promise((resolve, reject) => {\n      eccrypto\n        .decrypt(this.prvt, {\n          ciphertext: Buffer.from(dataToSee.ciphertext),\n          ephemPublicKey: Buffer.from(dataToSee.ephemPublicKey),\n          iv: Buffer.from(dataToSee.iv),\n          mac: Buffer.from(dataToSee.mac)\n        })\n        .then(_initial => {\n          let result;\n          try {\n            if (this.isJSON(_initial)) {\n              const humanRadable = JSON.parse(_initial);\n              if (Array.isArray(humanRadable)) {\n                result = humanRadable[0];\n              } else {\n                result = humanRadable;\n              }\n            } else {\n              result = _initial.toString();\n            }\n          } catch (e) {\n            logger.error(e);\n          }\n          resolve(JSON.stringify(result));\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  }\n\n  signMessage(msgToSign) {\n    return new Promise((resolve, reject) => {\n      try {\n        const msg = ethUtils.hashPersonalMessage(ethUtils.toBuffer(msgToSign));\n        const signed = ethUtils.ecsign(\n          Buffer.from(msg),\n          Buffer.from(this.prvt, 'hex')\n        );\n        const combined = Buffer.concat([\n          Buffer.from([signed.v]),\n          Buffer.from(signed.r),\n          Buffer.from(signed.s)\n        ]);\n        const combinedHex = combined.toString('hex');\n        resolve(combinedHex);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  signMessageSync(msgToSign) {\n    msgToSign = this.bufferToString(msgToSign);\n\n    const msg = ethUtils.hashPersonalMessage(ethUtils.toBuffer(msgToSign));\n    const signed = ethUtils.ecsign(\n      Buffer.from(msg),\n      Buffer.from(this.prvt, 'hex')\n    );\n    const combined = Buffer.concat([\n      Buffer.from([signed.v]),\n      Buffer.from(signed.r),\n      Buffer.from(signed.s)\n    ]);\n    return combined.toString('hex');\n  }\n\n  bufferToConnId(buf) {\n    return buf.toString('hex').slice(0, 32);\n  }\n\n  generateConnId(buf) {\n    if (buf instanceof Buffer) {\n      return buf.toString('hex').slice(0, 32);\n    }\n    return Buffer.from(buf)\n      .toString('hex')\n      .slice(0, 32);\n  }\n\n  isJSON(arg) {\n    try {\n      JSON.parse(arg);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  toBuffer(buf) {\n    if (buf instanceof Buffer) {\n      return buf;\n    }\n    return Buffer.from(buf, 'hex');\n  }\n\n  bufferToString(buf) {\n    if (buf instanceof Buffer) {\n      return buf.toString('hex');\n    }\n    return buf;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}