{"ast":null,"code":"'use strict';\n\nlet ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'; // pre-compute lookup table\n\nlet ALPHABET_MAP = {};\n\nfor (let z = 0; z < ALPHABET.length; z++) {\n  let x = ALPHABET.charAt(z);\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');\n  ALPHABET_MAP[x] = z;\n}\n\nfunction polymodStep(pre) {\n  let b = pre >> 25;\n  return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;\n}\n\nfunction prefixChk(prefix) {\n  let chk = 1;\n\n  for (let i = 0; i < prefix.length; ++i) {\n    let c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error('Invalid prefix (' + prefix + ')');\n    chk = polymodStep(chk) ^ c >> 5;\n  }\n\n  chk = polymodStep(chk);\n\n  for (let i = 0; i < prefix.length; ++i) {\n    let v = prefix.charCodeAt(i);\n    chk = polymodStep(chk) ^ v & 0x1f;\n  }\n\n  return chk;\n}\n\nfunction encode(prefix, words) {\n  // too long?\n  if (prefix.length + 7 + words.length > 90) throw new TypeError('Exceeds Bech32 maximum length');\n  prefix = prefix.toLowerCase(); // determine chk mod\n\n  let chk = prefixChk(prefix);\n  let result = prefix + '1';\n\n  for (let i = 0; i < words.length; ++i) {\n    let x = words[i];\n    if (x >> 5 !== 0) throw new Error('Non 5-bit word');\n    chk = polymodStep(chk) ^ x;\n    result += ALPHABET.charAt(x);\n  }\n\n  for (let i = 0; i < 6; ++i) {\n    chk = polymodStep(chk);\n  }\n\n  chk ^= 1;\n\n  for (let i = 0; i < 6; ++i) {\n    let v = chk >> (5 - i) * 5 & 0x1f;\n    result += ALPHABET.charAt(v);\n  }\n\n  return result;\n}\n\nfunction decode(str) {\n  if (str.length < 8) throw new TypeError(str + ' too short');\n  if (str.length > 90) throw new TypeError(str + ' too long'); // don't allow mixed case\n\n  let lowered = str.toLowerCase();\n  let uppered = str.toUpperCase();\n  if (str !== lowered && str !== uppered) throw new Error('Mixed-case string ' + str);\n  str = lowered;\n  let split = str.lastIndexOf('1');\n  if (split === 0) throw new Error('Missing prefix for ' + str);\n  let prefix = str.slice(0, split);\n  let wordChars = str.slice(split + 1);\n  if (wordChars.length < 6) throw new Error('Data too short');\n  let chk = prefixChk(prefix);\n  let words = [];\n\n  for (let i = 0; i < wordChars.length; ++i) {\n    let c = wordChars.charAt(i);\n    let v = ALPHABET_MAP[c];\n    if (v === undefined) throw new Error('Unknown character ' + c);\n    chk = polymodStep(chk) ^ v; // not in the checksum?\n\n    if (i + 6 >= wordChars.length) continue;\n    words.push(v);\n  }\n\n  if (chk !== 1) throw new Error('Invalid checksum for ' + str);\n  return {\n    prefix,\n    words\n  };\n}\n\nfunction convert(data, inBits, outBits, pad) {\n  let value = 0;\n  let bits = 0;\n  let maxV = (1 << outBits) - 1;\n  let result = [];\n\n  for (let i = 0; i < data.length; ++i) {\n    value = value << inBits | data[i];\n    bits += inBits;\n\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push(value >> bits & maxV);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push(value << outBits - bits & maxV);\n    }\n  } else {\n    if (bits >= inBits) throw new Error('Excess padding');\n    if (value << outBits - bits & maxV) throw new Error('Non-zero padding');\n  }\n\n  return result;\n}\n\nfunction toWords(bytes) {\n  return convert(bytes, 8, 5, true);\n}\n\nfunction fromWords(words) {\n  return convert(words, 5, 8, false);\n}\n\nmodule.exports = {\n  decode,\n  encode,\n  toWords,\n  fromWords\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitgo-utxo-lib/node_modules/bech32/index.js"],"names":["ALPHABET","ALPHABET_MAP","z","length","x","charAt","undefined","TypeError","polymodStep","pre","b","prefixChk","prefix","chk","i","c","charCodeAt","Error","v","encode","words","toLowerCase","result","decode","str","lowered","uppered","toUpperCase","split","lastIndexOf","slice","wordChars","push","convert","data","inBits","outBits","pad","value","bits","maxV","toWords","bytes","fromWords","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nlet ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nlet ALPHABET_MAP = {}\nfor (let z = 0; z < ALPHABET.length; z++) {\n  let x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  let b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  let chk = 1\n  for (let i = 0; i < prefix.length; ++i) {\n    let c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) throw new Error('Invalid prefix (' + prefix + ')')\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (let i = 0; i < prefix.length; ++i) {\n    let v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words) {\n  // too long?\n  if ((prefix.length + 7 + words.length) > 90) throw new TypeError('Exceeds Bech32 maximum length')\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  let chk = prefixChk(prefix)\n  let result = prefix + '1'\n  for (let i = 0; i < words.length; ++i) {\n    let x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (let i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (let i = 0; i < 6; ++i) {\n    let v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction decode (str) {\n  if (str.length < 8) throw new TypeError(str + ' too short')\n  if (str.length > 90) throw new TypeError(str + ' too long')\n\n  // don't allow mixed case\n  let lowered = str.toLowerCase()\n  let uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) throw new Error('Mixed-case string ' + str)\n  str = lowered\n\n  let split = str.lastIndexOf('1')\n  if (split === 0) throw new Error('Missing prefix for ' + str)\n\n  let prefix = str.slice(0, split)\n  let wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) throw new Error('Data too short')\n\n  let chk = prefixChk(prefix)\n  let words = []\n  for (let i = 0; i < wordChars.length; ++i) {\n    let c = wordChars.charAt(i)\n    let v = ALPHABET_MAP[c]\n    if (v === undefined) throw new Error('Unknown character ' + c)\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) throw new Error('Invalid checksum for ' + str)\n  return { prefix, words }\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  let value = 0\n  let bits = 0\n  let maxV = (1 << outBits) - 1\n\n  let result = []\n  for (let i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) throw new Error('Excess padding')\n    if ((value << (outBits - bits)) & maxV) throw new Error('Non-zero padding')\n  }\n\n  return result\n}\n\nfunction toWords (bytes) {\n  return convert(bytes, 8, 5, true)\n}\n\nfunction fromWords (words) {\n  return convert(words, 5, 8, false)\n}\n\nmodule.exports = { decode, encode, toWords, fromWords }\n"]},"metadata":{},"sourceType":"script"}