{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar bufferutils = require('./bufferutils');\n\nvar varuint = require('varuint-bitcoin');\n\nvar networks = require('./networks');\n\nvar coins = require('./coins');\n\nvar Transaction = require('./transaction');\n\nfunction Block(network) {\n  typeforce(types.maybe(types.Network), network);\n  network = network || networks.bitcoin;\n  this.version = 1;\n  this.prevHash = null;\n  this.merkleRoot = null;\n  this.timestamp = 0;\n  this.bits = 0;\n  this.nonce = 0;\n  this.network = network;\n\n  if (coins.isZcash(network)) {\n    this.finalSaplingRoot = null;\n    this.solutionSize = 0;\n    this.solution = null;\n  }\n}\n\nBlock.HEADER_BYTE_SIZE = 80;\nBlock.ZCASH_HEADER_BYTE_SIZE = 1487;\n\nBlock.fromBuffer = function (buffer, network) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n  network = network || networks.bitcoin;\n  const bufferReader = new bufferutils.BufferReader(buffer);\n  var block = new Block(network);\n  block.version = bufferReader.readInt32();\n  block.prevHash = bufferReader.readSlice(32);\n  block.merkleRoot = bufferReader.readSlice(32);\n\n  if (coins.isZcash(network)) {\n    block.finalSaplingRoot = bufferReader.readSlice(32);\n  }\n\n  block.timestamp = bufferReader.readUInt32();\n  block.bits = bufferReader.readUInt32();\n\n  if (coins.isZcash(network)) {\n    block.nonce = bufferReader.readSlice(32);\n    block.solutionSize = bufferReader.readVarInt();\n    block.solution = bufferReader.readSlice(1344);\n  } else {\n    // Not sure sure why the nonce is read as UInt 32 and not as a slice\n    block.nonce = bufferReader.readUInt32();\n  }\n\n  if (bufferReader.buffer.length === 80) return block;\n\n  function readTransaction() {\n    var tx = Transaction.fromBuffer(buffer.slice(bufferReader.offset), network, true);\n    bufferReader.offset += tx.byteLength();\n    return tx;\n  }\n\n  var nTransactions = bufferReader.readVarInt();\n  block.transactions = [];\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction();\n    block.transactions.push(tx);\n  }\n\n  return block;\n};\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (coins.isZcash(this.network)) {\n    if (headersOnly) {\n      return Block.ZCASH_HEADER_BYTE_SIZE;\n    }\n\n    return Block.ZCASH_HEADER_BYTE_SIZE + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n      return a + x.byteLength();\n    }, 0);\n  }\n\n  if (headersOnly || !this.transactions) return Block.HEADER_BYTE_SIZE;\n  return Block.HEADER_BYTE_SIZE + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength();\n  }, 0);\n};\n\nBlock.fromHex = function (hex, network) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true));\n};\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex');\n};\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0); // epoch\n\n  date.setUTCSeconds(this.timestamp);\n  return date;\n}; // TODO: buffer, offset compatibility\n\n\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n  var bufferWriter = new bufferutils.BufferWriter(buffer);\n  bufferWriter.writeInt32(this.version);\n  bufferWriter.writeSlice(this.prevHash);\n  bufferWriter.writeSlice(this.merkleRoot);\n\n  if (coins.isZcash(this.network)) {\n    bufferWriter.writeSlice(this.finalSaplingRoot);\n  }\n\n  bufferWriter.writeUInt32(this.timestamp);\n  bufferWriter.writeUInt32(this.bits);\n\n  if (coins.isZcash(this.network)) {\n    bufferWriter.writeSlice(this.nonce); // TODO: use writeVarInt\n\n    varuint.encode(this.solutionSize, bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    bufferWriter.writeSlice(this.solution);\n  } else {\n    // Not sure sure why the nonce is interpreted as UInt 32 and not a slice in bitcoin\n    bufferWriter.writeUInt32(this.nonce);\n  }\n\n  if (headersOnly || !this.transactions) return buffer; // TODO: use writeVarInt\n\n  varuint.encode(this.transactions.length, bufferWriter.buffer, bufferWriter.offset);\n  bufferWriter.offset += varuint.encode.bytes; // TODO: use writeVarInt\n\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n    tx.toBuffer(bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += txSize;\n  });\n  return buffer;\n};\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex');\n};\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3;\n  var mantissa = bits & 0x007fffff;\n  var target = Buffer.alloc(32, 0);\n\n  if (exponent < 0) {\n    // If it is negative, we will overflow the target buffer so we have to slice the mantissa to fit\n    mantissa = mantissa >> 8 * Math.abs(exponent);\n    target.writeUInt32BE(mantissa, 28);\n  } else if (exponent > 28) {\n    // If it is greater than 28, we need to shift the mantissa since the offset cannot be greater than 32 - 4\n    // (safe-buffer restriction)\n    mantissa <<= 8 * (exponent - 28);\n    target.writeUInt32BE(mantissa, 0);\n  } else {\n    target.writeUInt32BE(mantissa, 28 - exponent);\n  }\n\n  return target;\n};\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{\n    getHash: types.Function\n  }], transactions);\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions');\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash();\n  });\n  return fastMerkleRoot(hashes, bcrypto.hash256);\n};\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false;\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n  return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse();\n  var target = Block.calculateTarget(this.bits);\n  return hash.compare(target) <= 0;\n};\n\nmodule.exports = Block;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitgo-utxo-lib/src/block.js"],"names":["Buffer","require","bcrypto","fastMerkleRoot","typeforce","types","bufferutils","varuint","networks","coins","Transaction","Block","network","maybe","Network","bitcoin","version","prevHash","merkleRoot","timestamp","bits","nonce","isZcash","finalSaplingRoot","solutionSize","solution","HEADER_BYTE_SIZE","ZCASH_HEADER_BYTE_SIZE","fromBuffer","buffer","length","Error","bufferReader","BufferReader","block","readInt32","readSlice","readUInt32","readVarInt","readTransaction","tx","slice","offset","byteLength","nTransactions","transactions","i","push","prototype","headersOnly","encodingLength","reduce","a","x","fromHex","hex","from","getHash","hash256","toBuffer","getId","reverse","toString","getUTCDate","date","Date","setUTCSeconds","allocUnsafe","bufferWriter","BufferWriter","writeInt32","writeSlice","writeUInt32","encode","bytes","forEach","txSize","toHex","calculateTarget","exponent","mantissa","target","alloc","Math","abs","writeUInt32BE","calculateMerkleRoot","Function","TypeError","hashes","map","transaction","checkMerkleRoot","actualMerkleRoot","compare","checkProofOfWork","hash","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar bcrypto = require('./crypto')\nvar fastMerkleRoot = require('merkle-lib/fastRoot')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar bufferutils = require('./bufferutils')\nvar varuint = require('varuint-bitcoin')\nvar networks = require('./networks')\nvar coins = require('./coins')\n\nvar Transaction = require('./transaction')\n\nfunction Block (network) {\n  typeforce(types.maybe(types.Network), network)\n  network = network || networks.bitcoin\n  this.version = 1\n  this.prevHash = null\n  this.merkleRoot = null\n  this.timestamp = 0\n  this.bits = 0\n  this.nonce = 0\n  this.network = network\n  if (coins.isZcash(network)) {\n    this.finalSaplingRoot = null\n    this.solutionSize = 0\n    this.solution = null\n  }\n}\n\nBlock.HEADER_BYTE_SIZE = 80\nBlock.ZCASH_HEADER_BYTE_SIZE = 1487\n\nBlock.fromBuffer = function (buffer, network) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)')\n  network = network || networks.bitcoin\n\n  const bufferReader = new bufferutils.BufferReader(buffer)\n\n  var block = new Block(network)\n  block.version = bufferReader.readInt32()\n  block.prevHash = bufferReader.readSlice(32)\n  block.merkleRoot = bufferReader.readSlice(32)\n  if (coins.isZcash(network)) {\n    block.finalSaplingRoot = bufferReader.readSlice(32)\n  }\n  block.timestamp = bufferReader.readUInt32()\n  block.bits = bufferReader.readUInt32()\n  if (coins.isZcash(network)) {\n    block.nonce = bufferReader.readSlice(32)\n    block.solutionSize = bufferReader.readVarInt()\n    block.solution = bufferReader.readSlice(1344)\n  } else {\n    // Not sure sure why the nonce is read as UInt 32 and not as a slice\n    block.nonce = bufferReader.readUInt32()\n  }\n\n  if (bufferReader.buffer.length === 80) return block\n\n  function readTransaction () {\n    var tx = Transaction.fromBuffer(buffer.slice(bufferReader.offset), network, true)\n    bufferReader.offset += tx.byteLength()\n    return tx\n  }\n\n  var nTransactions = bufferReader.readVarInt()\n  block.transactions = []\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction()\n    block.transactions.push(tx)\n  }\n\n  return block\n}\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (coins.isZcash(this.network)) {\n    if (headersOnly) {\n      return Block.ZCASH_HEADER_BYTE_SIZE\n    }\n    return Block.ZCASH_HEADER_BYTE_SIZE +\n      varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n        return a + x.byteLength()\n      }, 0)\n  }\n\n  if (headersOnly || !this.transactions) return Block.HEADER_BYTE_SIZE\n\n  return Block.HEADER_BYTE_SIZE +\n    varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n      return a + x.byteLength()\n    }, 0)\n}\n\nBlock.fromHex = function (hex, network) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'), network)\n}\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true))\n}\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex')\n}\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0) // epoch\n  date.setUTCSeconds(this.timestamp)\n\n  return date\n}\n\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly))\n  var bufferWriter = new bufferutils.BufferWriter(buffer)\n\n  bufferWriter.writeInt32(this.version)\n  bufferWriter.writeSlice(this.prevHash)\n  bufferWriter.writeSlice(this.merkleRoot)\n  if (coins.isZcash(this.network)) {\n    bufferWriter.writeSlice(this.finalSaplingRoot)\n  }\n  bufferWriter.writeUInt32(this.timestamp)\n  bufferWriter.writeUInt32(this.bits)\n  if (coins.isZcash(this.network)) {\n    bufferWriter.writeSlice(this.nonce)\n    // TODO: use writeVarInt\n    varuint.encode(this.solutionSize, bufferWriter.buffer, bufferWriter.offset)\n    bufferWriter.offset += varuint.encode.bytes\n    bufferWriter.writeSlice(this.solution)\n  } else {\n    // Not sure sure why the nonce is interpreted as UInt 32 and not a slice in bitcoin\n    bufferWriter.writeUInt32(this.nonce)\n  }\n\n  if (headersOnly || !this.transactions) return buffer\n\n  // TODO: use writeVarInt\n  varuint.encode(this.transactions.length, bufferWriter.buffer, bufferWriter.offset)\n  bufferWriter.offset += varuint.encode.bytes\n\n  // TODO: use writeVarInt\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength() // TODO: extract from toBuffer?\n    tx.toBuffer(bufferWriter.buffer, bufferWriter.offset)\n    bufferWriter.offset += txSize\n  })\n\n  return buffer\n}\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex')\n}\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3\n  var mantissa = bits & 0x007fffff\n  var target = Buffer.alloc(32, 0)\n  if (exponent < 0) {\n    // If it is negative, we will overflow the target buffer so we have to slice the mantissa to fit\n    mantissa = mantissa >> (8 * Math.abs(exponent))\n    target.writeUInt32BE(mantissa, 28)\n  } else if (exponent > 28) {\n    // If it is greater than 28, we need to shift the mantissa since the offset cannot be greater than 32 - 4\n    // (safe-buffer restriction)\n    mantissa <<= 8 * (exponent - 28)\n    target.writeUInt32BE(mantissa, 0)\n  } else {\n    target.writeUInt32BE(mantissa, 28 - exponent)\n  }\n  return target\n}\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{ getHash: types.Function }], transactions)\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions')\n\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash()\n  })\n\n  return fastMerkleRoot(hashes, bcrypto.hash256)\n}\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false\n\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions)\n  return this.merkleRoot.compare(actualMerkleRoot) === 0\n}\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse()\n  var target = Block.calculateTarget(this.bits)\n\n  return hash.compare(target) <= 0\n}\n\nmodule.exports = Block\n"]},"metadata":{},"sourceType":"script"}