{"ast":null,"code":"import * as Sentry from \"@sentry/react\";\nimport Web3 from \"web3\";\nimport GatewayJS from \"@renproject/gateway\"; // import Box from '3box'\n\nimport Web3Modal from \"web3modal\";\nimport MEWconnect from \"@myetherwallet/mewconnect-web-client\";\nimport ELA from \"../assets/ela-1.png\";\nimport ETH from \"../assets/eth.png\";\nimport TRX from \"../assets/tron.png\";\nimport USDT from \"../assets/usdt.png\";\nimport { getStore } from \"../services/storeService\";\n// used for montoring balances\nlet walletDataInterval = null; // export const ASSETS = [\"BTC\", \"WBTC\"];\n// Top level bridge selection options\n\nexport const BRIDGE_SYMBOL_MAP = {\n  ela: \"ELA\",\n  eth: \"ETH\",\n  trx: \"TRX\"\n};\nexport const BRIDGE_NAME_MAP = {\n  ela: \"Elastos\",\n  eth: \"Ethereum\",\n  trx: \"Tron\"\n};\nexport const BRIDGE_ICON_MAP = {\n  ela: ELA,\n  eth: ETH,\n  trx: TRX\n}; /////////////////////////////////////\n\nexport const NAME_MAP = {\n  ela: \"Elastos\",\n  eth: \"Ethereum\",\n  usdt: \"Tether\",\n  wela: \"Wrapped Elastos\",\n  weth: \"Wrapped Ethereum\",\n  wusdt: \"Wrapped Tether\"\n};\nexport const SYMBOL_MAP = {\n  ela: \"ELA\",\n  eth: \"ETH\",\n  usdt: \"USDT\",\n  wela: \"wELA\",\n  weth: \"wETH\",\n  wusdt: \"wUSDT\"\n};\nexport const CONVERT_MAP = {\n  ela: \"wela\",\n  eth: \"weth\",\n  usdt: \"wusdt\",\n  wela: \"ela\",\n  weth: \"eth\",\n  wusdt: \"usdt\"\n};\nexport const NETWORK_MAP = {\n  ela: \"Elastos\",\n  eth: \"Ethereum\",\n  usdt: \"Ethereum\",\n  wela: \"Ethereum\",\n  weth: \"Elastos\",\n  wusdt: \"Elastos\"\n};\nexport const MINI_ICON_MAP = {\n  ela: ELA,\n  eth: ETH,\n  usdt: USDT,\n  wela: ELA,\n  weth: ETH,\n  wusdt: USDT\n};\nexport const SUPPORTED_NETWORKS = {\n  1: 'MAINNET',\n  3: 'ROPSTEN',\n  4: 'RINKEBY',\n  42: 'KOVAN'\n};\nexport const abbreviateAddress = function (walletAddress) {\n  if (!walletAddress || typeof walletAddress !== \"string\") {\n    return \"\";\n  } else {\n    return walletAddress.slice(0, 5) + \"...\" + walletAddress.slice(walletAddress.length - 5);\n  }\n};\nexport const updateMarketData = async function () {\n  const store = getStore();\n\n  try {\n    const eth = await fetch(`https://api.coincap.io/v2/assets/ethereum`, {\n      method: \"GET\"\n    });\n    store.set(\"ethusd\", (await eth.json()).data.priceUsd);\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"updating market data\");\n      Sentry.captureException(e);\n    });\n  }\n\n  try {\n    const ela = await fetch(`https://api.coincap.io/v2/assets/elastos`, {\n      method: \"GET\"\n    });\n    store.set(\"elausd\", (await ela.json()).data.priceUsd);\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"updating market data\");\n      Sentry.captureException(e);\n    });\n  }\n\n  try {\n    const usdt = await fetch(`https://api.coincap.io/v2/assets/tether`, {\n      method: \"GET\"\n    });\n    store.set(\"usdtusd\", (await usdt.json()).data.priceUsd);\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"updating market data\");\n      Sentry.captureException(e);\n    });\n  }\n};\nexport const updateBalance = async function () {\n  console.log('Update Balances');\n  const store = getStore();\n  const web3 = store.get(\"localWeb3\");\n  const walletAddress = store.get(\"localWeb3Address\");\n  const USDTAddress = store.get(\"USDTAddress\");\n  console.log(web3);\n  console.log(walletAddress);\n\n  if (!web3 || !walletAddress) {\n    return;\n  } // const usdt = new web3.eth.Contract(erc20ABI, USDTAddress);\n  // const usdtBal = await usdt.methods.balanceOf(walletAddress).call();\n\n\n  const ethBal = await web3.eth.getBalance(walletAddress);\n  console.log('ETH BALANACE', ethBal);\n  store.set(\"ETHBalance\", Number(web3.utils.fromWei(ethBal)).toFixed(4)); // store.set(\"USDTBalance\", Number(parseInt(usdtBal.toString()) / 10 ** 8).toFixed(8));\n\n  store.set(\"loadingBalances\", false);\n  updateMarketData();\n};\nexport const watchWalletData = async function () {\n  const store = getStore();\n\n  if (walletDataInterval) {\n    clearInterval(walletDataInterval);\n  } // await updateAllowance()\n\n\n  await updateBalance();\n  walletDataInterval = setInterval(async () => {\n    // await updateAllowance()\n    await updateBalance();\n  }, 10 * 1000);\n};\nexport const initDataWeb3 = async function () {\n  const store = getStore();\n  const network = store.get(\"selectedNetwork\");\n  store.set(\"dataWeb3\", new Web3(`https://${network === \"testnet\" ? \"rinkeby\" : \"mainnet\"}.infura.io/v3/bd80ce1ca1f94da48e151bb6868bb150`));\n};\n/**\n * Connecting to Local Web3 Wallet\n */\n\nexport const initLocalWeb3 = async function (type) {\n  console.log(\"Init Local Web3\");\n  const store = getStore();\n  store.set(\"walletConnecting\", true); // already connected\n\n  if (store.get(\"localWeb3Address\")) {\n    return;\n  }\n\n  store.set(\"spaceError\", false);\n  const selectedNetwork = store.get(\"selectedNetwork\");\n  let web3;\n  let currentProvider;\n  let accounts = [];\n  let network = \"\";\n\n  try {\n    if (type === \"injected\" || !type) {\n      const providerOptions = {};\n      const web3Modal = new Web3Modal({\n        network: selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\",\n        cacheProvider: false,\n        providerOptions\n      });\n      const web3Provider = await web3Modal.connect();\n      web3 = new Web3(web3Provider);\n      currentProvider = web3.currentProvider;\n      if (typeof currentProvider === \"string\") return;\n      if (!currentProvider) return;\n      accounts = await web3.eth.getAccounts();\n      const netId = await web3.eth.net.getId();\n\n      if (netId === 1) {\n        network = \"mainnet\";\n      } else if (netId === 4) {\n        network = \"mainnet\"; //testnet\n      } else {\n        network = \"mainnet\";\n      }\n    } else if (type === \"mew-connect\") {\n      const chainId = selectedNetwork === \"testnet\" ? 42 : 1;\n      const jsonRpcUrl = `wss://${selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\"}.infura.io/ws/v3/7117ca7a3c7b4b94b24944c1ef0ecec9`;\n      const mewConnect = new MEWconnect.Provider({\n        windowClosedError: true\n      });\n      const web3Provider = mewConnect.makeWeb3Provider(chainId, jsonRpcUrl, true);\n      web3 = new Web3(web3Provider);\n      currentProvider = web3.currentProvider;\n      if (typeof currentProvider === \"string\") return;\n      if (!currentProvider) return;\n      accounts = await web3Provider.enable();\n      network = selectedNetwork;\n    } else {\n      console.error(\"Invalid wallet type.\");\n      store.set(\"spaceError\", true);\n      store.set(\"spaceRequesting\", false);\n      store.set(\"walletConnecting\", false);\n      return;\n    }\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"web3 init\");\n      Sentry.captureException(e);\n    });\n    store.set(\"spaceError\", true);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n    return;\n  }\n\n  const address = accounts[0];\n  const addressLowerCase = address.toLowerCase();\n  const db = store.get(\"db\");\n  const fns = store.get(\"fns\");\n\n  if (selectedNetwork !== network) {\n    store.set(\"showNetworkModal\", true);\n    store.set(\"spaceError\", true);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n    return;\n  } // try {\n  //     ///////////////////////////////////////////////////////\n  //     // Firebase Sign In or Sign Up\n  //     //////////////////////////////////////////////////////\n  //     let signature = \"\";\n  //     let rawSig = \"\";\n  //     // get from local storage if user has signed in already\n  //     const localSigMap = localStorage.getItem(\"sigMap\");\n  //     const localRawSigMap = JSON.parse(\n  //         localStorage.getItem(\"rawSigMap\") || \"{}\"\n  //     );\n  //     const localSigMapData = localSigMap ? JSON.parse(localSigMap) : {};\n  //     if (localSigMapData[addressLowerCase] && localRawSigMap[addressLowerCase]) {\n  //         signature = localSigMapData[addressLowerCase];\n  //         rawSig = localRawSigMap[addressLowerCase];\n  //     } else {\n  //         // get unique wallet signature for firebase backup\n  //         // @ts-ignore\n  //         rawSig = await web3.eth.personal.sign(\n  //             web3.utils.utf8ToHex(\"Signing in to RenBridge\"),\n  //             addressLowerCase\n  //         );\n  //         signature = web3.utils.sha3(rawSig)!;\n  //         localSigMapData[addressLowerCase] = signature;\n  //         localStorage.setItem(\"sigMap\", JSON.stringify(localSigMapData));\n  //         localRawSigMap[addressLowerCase] = rawSig;\n  //         localStorage.setItem(\"rawSigMap\", JSON.stringify(localRawSigMap));\n  //     }\n  //     store.set(\"fsSignature\", signature);\n  //     let token: string | null = null;\n  //     try {\n  //         const res = await fns.httpsCallable(\"authenticate\")({\n  //             signed: rawSig,\n  //             account: addressLowerCase,\n  //         });\n  //         token = res.data.token;\n  //         if (!token) {\n  //             throw new Error(\"missing token\");\n  //         }\n  //     } catch (e) {\n  //         console.log(\"No token auth, falling back to email / sig\");\n  //     }\n  //     // auth with firestore\n  //     const bridgeId = `${addressLowerCase}@renproject.io`;\n  //     const currentFsUser = firebase.auth().currentUser;\n  //     let fsUser;\n  //     if (!currentFsUser || currentFsUser.email !== bridgeId) {\n  //         try {\n  //             fsUser = token\n  //                 ? (await firebase.auth().signInWithCustomToken(token)).user\n  //                 : (\n  //                     await firebase\n  //                         .auth()\n  //                         .signInWithEmailAndPassword(bridgeId, signature)\n  //                 ).user;\n  //         } catch (e) {\n  //             console.error(e);\n  //             // We can register this user as they do not exist\n  //             if (e.message.includes(\"There is no user record\")) {\n  //                 fsUser = (\n  //                     await firebase\n  //                         .auth()\n  //                         .createUserWithEmailAndPassword(bridgeId, signature)\n  //                 ).user;\n  //             } else {\n  //                 console.error(e);\n  //                 Sentry.withScope(function(scope) {\n  //                     scope.setTag(\"error-hint\", \"web3 init\");\n  //                     Sentry.captureException(e);\n  //                 });\n  //             }\n  //         }\n  //     } else {\n  //         fsUser = currentFsUser;\n  //     }\n  //     store.set(\"fsUser\", fsUser);\n  //     if (fsUser) {\n  //         // update user collection\n  //         const doc = await db.collection(\"users\").doc(fsUser.uid);\n  //         const docData = await doc.get();\n  //         if (docData.exists) {\n  //             const data = docData.data();\n  //             if (data.signatures.indexOf(signature) < 0) {\n  //                 // add a new signature if needed\n  //                 await doc.update({\n  //                     signatures: data.signatures.concat([signature]),\n  //                     updated: firebase.firestore.Timestamp.fromDate(\n  //                         new Date(Date.now())\n  //                     ),\n  //                 });\n  //             }\n  //         } else {\n  //             // create user\n  //             await doc.set({\n  //                 uid: fsUser.uid,\n  //                 updated: firebase.firestore.Timestamp.fromDate(new Date(Date.now())),\n  //                 signatures: [signature],\n  //             });\n  //         }\n  //     }\n  //     store.set(\"fsEnabled\", true);\n  ///////////////////////////////////////////////////////\n  // Recover Transactions\n  //////////////////////////////////////////////////////\n\n\n  store.set(\"localWeb3\", web3);\n  store.set(\"localWeb3Address\", accounts[0]);\n  store.set(\"localWeb3Network\", network);\n  store.set(\"spaceRequesting\", false);\n  store.set(\"walletConnecting\", false);\n  updateBalance();\n  if ((!currentProvider).on) return; // FIXME: provide propper provider type\n\n  const listeningProvider = currentProvider;\n\n  if (listeningProvider.on) {\n    // listen for changes\n    listeningProvider.on(\"accountsChanged\", async () => {\n      window.location.reload();\n    });\n    listeningProvider.on(\"chainChanged\", async () => {\n      window.location.reload();\n    }); // listeningProvider.on(\"networkChanged\", async () => {\n    //     window.location.reload();\n    // });\n\n    listeningProvider.on(\"disconnected\", async () => {\n      window.location.reload();\n    });\n  } // } catch (e) {\n  //     console.error(e);\n  //     Sentry.withScope(function(scope) {\n  //         scope.setTag(\"error-hint\", \"main initialization\");\n  //         Sentry.captureException(e);\n  //     });\n  //     store.set(\"spaceError\", true);\n  //     store.set(\"spaceRequesting\", false);\n  //     store.set(\"walletConnecting\", false);\n  // }\n\n\n  return;\n};\nexport const setAddresses = async function () {\n  const store = getStore();\n  const network = store.get(\"selectedNetwork\");\n\n  if (network === \"testnet\") {// store.set(\"renELAAddress\", RENELA_TEST);\n  } else {// store.set(\"renELAAddress\", RENELA_MAIN);\n    }\n};\nexport const setBridge = async function (bridge, pair) {\n  const store = getStore();\n  store.set(\"selectedBridge\", bridge);\n  store.set(\"selectedPair\", pair);\n};\nexport const setNetwork = async function (network) {\n  const store = getStore();\n  console.log('NETWORK CONNECTION');\n  store.set(\"selectedNetwork\", network);\n\n  if (network === \"mainnet\") {\n    store.set(\"selectedNetworkName\", \"Ethereum\");\n  } else if (network === \"testnet\") {\n    store.set(\"selectedNetworkName\", \"Rinkeby\");\n  } else if (network === \"private\") {\n    store.set(\"selectedNetworkName\", \"Elastos\");\n  } else {\n    store.set(\"selectedNetworkName\", \"No Network\");\n  }\n\n  store.set(\"gjs\", new GatewayJS(network, {// If we want to test against gatewayjs staging, we should change the endpoint\n    // manually in a PR, which does not get merged, and check the preview build\n    // endpoint: \"https://ren-gatewayjs-staging.netlify.app/\",\n  })); // @ts-ignore\n\n  setAddresses.bind(this)();\n}; // export async function getEthereumNetwork() {\n// \tif (!window.web3) return { name: 'MAINNET', networkId: 1 };\n// \tlet networkId = 1;\n// \ttry {\n// \t\tif (window.web3?.eth?.net) {\n// \t\t\tnetworkId = await window.web3.eth.net.getId();\n// \t\t\treturn { name: SUPPORTED_NETWORKS[networkId], networkId: Number(networkId) };\n// \t\t} else if (window.web3?.version?.network) {\n// \t\t\tnetworkId = Number(window.web3.version.network);\n// \t\t\treturn { name: SUPPORTED_NETWORKS[networkId], networkId };\n// \t\t} else if (window.ethereum?.networkVersion) {\n// \t\t\tnetworkId = Number(window.ethereum?.networkVersion);\n// \t\t\treturn { name: SUPPORTED_NETWORKS[networkId], networkId };\n// \t\t}\n// \t\treturn { name: 'MAINNET', networkId };\n// \t} catch (e) {\n// \t\tconsole.log(e);\n// \t\treturn { name: 'MAINNET', networkId };\n// \t}\n// }\n\nexport default {};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/src/utils/walletUtils.ts"],"names":["Sentry","Web3","GatewayJS","Web3Modal","MEWconnect","ELA","ETH","TRX","USDT","getStore","walletDataInterval","BRIDGE_SYMBOL_MAP","ela","eth","trx","BRIDGE_NAME_MAP","BRIDGE_ICON_MAP","NAME_MAP","usdt","wela","weth","wusdt","SYMBOL_MAP","CONVERT_MAP","NETWORK_MAP","MINI_ICON_MAP","SUPPORTED_NETWORKS","abbreviateAddress","walletAddress","slice","length","updateMarketData","store","fetch","method","set","json","data","priceUsd","e","console","error","withScope","scope","setTag","captureException","updateBalance","log","web3","get","USDTAddress","ethBal","getBalance","Number","utils","fromWei","toFixed","watchWalletData","clearInterval","setInterval","initDataWeb3","network","initLocalWeb3","type","selectedNetwork","currentProvider","accounts","providerOptions","web3Modal","cacheProvider","web3Provider","connect","getAccounts","netId","net","getId","chainId","jsonRpcUrl","mewConnect","Provider","windowClosedError","makeWeb3Provider","enable","address","addressLowerCase","toLowerCase","db","fns","on","listeningProvider","window","location","reload","setAddresses","setBridge","bridge","pair","setNetwork","bind"],"mappings":"AAAA,OAAO,KAAKA,MAAZ,MAAwB,eAAxB;AAEA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,SAAP,MAAsB,qBAAtB,C,CACA;;AACA,OAAOC,SAAP,MAAsB,WAAtB;AAEA,OAAOC,UAAP,MAAuB,sCAAvB;AAEA,OAAOC,GAAP,MAAgB,qBAAhB;AACA,OAAOC,GAAP,MAAgB,mBAAhB;AACA,OAAOC,GAAP,MAAgB,oBAAhB;AACA,OAAOC,IAAP,MAAiB,oBAAjB;AAEA,SAASC,QAAT,QAAyB,0BAAzB;AAMA;AACA,IAAIC,kBAAuB,GAAG,IAA9B,C,CAEA;AAEA;;AACA,OAAO,MAAMC,iBAA8C,GAAG;AAC1DC,EAAAA,GAAG,EAAE,KADqD;AAE1DC,EAAAA,GAAG,EAAE,KAFqD;AAG1DC,EAAAA,GAAG,EAAE;AAHqD,CAAvD;AAKP,OAAO,MAAMC,eAA4C,GAAG;AACxDH,EAAAA,GAAG,EAAE,SADmD;AAExDC,EAAAA,GAAG,EAAE,UAFmD;AAGxDC,EAAAA,GAAG,EAAE;AAHmD,CAArD;AAKP,OAAO,MAAME,eAA4C,GAAG;AACxDJ,EAAAA,GAAG,EAAEP,GADmD;AAExDQ,EAAAA,GAAG,EAAEP,GAFmD;AAGxDQ,EAAAA,GAAG,EAAEP;AAHmD,CAArD,C,CAKP;;AAEA,OAAO,MAAMU,QAAQ,GAAG;AACpBL,EAAAA,GAAG,EAAE,SADe;AAEpBC,EAAAA,GAAG,EAAE,UAFe;AAGpBK,EAAAA,IAAI,EAAE,QAHc;AAIpBC,EAAAA,IAAI,EAAE,iBAJc;AAKpBC,EAAAA,IAAI,EAAE,kBALc;AAMpBC,EAAAA,KAAK,EAAE;AANa,CAAjB;AASP,OAAO,MAAMC,UAAU,GAAG;AACtBV,EAAAA,GAAG,EAAE,KADiB;AAEtBC,EAAAA,GAAG,EAAE,KAFiB;AAGtBK,EAAAA,IAAI,EAAE,MAHgB;AAItBC,EAAAA,IAAI,EAAE,MAJgB;AAKtBC,EAAAA,IAAI,EAAE,MALgB;AAMtBC,EAAAA,KAAK,EAAE;AANe,CAAnB;AASP,OAAO,MAAME,WAAW,GAAG;AACvBX,EAAAA,GAAG,EAAE,MADkB;AAEvBC,EAAAA,GAAG,EAAE,MAFkB;AAGvBK,EAAAA,IAAI,EAAE,OAHiB;AAIvBC,EAAAA,IAAI,EAAE,KAJiB;AAKvBC,EAAAA,IAAI,EAAE,KALiB;AAMvBC,EAAAA,KAAK,EAAE;AANgB,CAApB;AASP,OAAO,MAAMG,WAAW,GAAG;AACvBZ,EAAAA,GAAG,EAAE,SADkB;AAEvBC,EAAAA,GAAG,EAAE,UAFkB;AAGvBK,EAAAA,IAAI,EAAE,UAHiB;AAIvBC,EAAAA,IAAI,EAAE,UAJiB;AAKvBC,EAAAA,IAAI,EAAE,SALiB;AAMvBC,EAAAA,KAAK,EAAE;AANgB,CAApB;AASP,OAAO,MAAMI,aAA0C,GAAG;AACtDb,EAAAA,GAAG,EAAEP,GADiD;AAEtDQ,EAAAA,GAAG,EAAEP,GAFiD;AAGtDY,EAAAA,IAAI,EAAEV,IAHgD;AAItDW,EAAAA,IAAI,EAAEd,GAJgD;AAKtDe,EAAAA,IAAI,EAAEd,GALgD;AAMtDe,EAAAA,KAAK,EAAEb;AAN+C,CAAnD;AASP,OAAO,MAAMkB,kBAAkB,GAAG;AAC9B,KAAG,SAD2B;AAE9B,KAAG,SAF2B;AAG9B,KAAG,SAH2B;AAI9B,MAAI;AAJ0B,CAA3B;AAOP,OAAO,MAAMC,iBAAiB,GAAG,UAASC,aAAT,EAAgC;AAC7D,MAAI,CAACA,aAAD,IAAkB,OAAOA,aAAP,KAAyB,QAA/C,EAAyD;AACrD,WAAO,EAAP;AACH,GAFD,MAEO;AACH,WACIA,aAAa,CAACC,KAAd,CAAoB,CAApB,EAAuB,CAAvB,IACA,KADA,GAEAD,aAAa,CAACC,KAAd,CAAoBD,aAAa,CAACE,MAAd,GAAuB,CAA3C,CAHJ;AAKH;AACJ,CAVM;AAYP,OAAO,MAAMC,gBAAgB,GAAG,kBAAiB;AAC7C,QAAMC,KAAK,GAAGvB,QAAQ,EAAtB;;AAEA,MAAI;AACA,UAAMI,GAAG,GAAG,MAAMoB,KAAK,CAAE,2CAAF,EAA8C;AACjEC,MAAAA,MAAM,EAAE;AADyD,KAA9C,CAAvB;AAIAF,IAAAA,KAAK,CAACG,GAAN,CAAU,QAAV,EAAoB,CAAC,MAAMtB,GAAG,CAACuB,IAAJ,EAAP,EAAmBC,IAAnB,CAAwBC,QAA5C;AACH,GAND,CAME,OAAOC,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvC,IAAAA,MAAM,CAAC0C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,sBAA3B;AACA5C,MAAAA,MAAM,CAAC6C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIH;;AAED,MAAI;AACA,UAAM3B,GAAG,GAAG,MAAMqB,KAAK,CAAE,0CAAF,EAA6C;AAChEC,MAAAA,MAAM,EAAE;AADwD,KAA7C,CAAvB;AAIAF,IAAAA,KAAK,CAACG,GAAN,CAAU,QAAV,EAAoB,CAAC,MAAMvB,GAAG,CAACwB,IAAJ,EAAP,EAAmBC,IAAnB,CAAwBC,QAA5C;AACH,GAND,CAME,OAAOC,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvC,IAAAA,MAAM,CAAC0C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,sBAA3B;AACA5C,MAAAA,MAAM,CAAC6C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIH;;AAED,MAAI;AACA,UAAMrB,IAAI,GAAG,MAAMe,KAAK,CAAE,yCAAF,EAA4C;AAChEC,MAAAA,MAAM,EAAE;AADwD,KAA5C,CAAxB;AAIAF,IAAAA,KAAK,CAACG,GAAN,CAAU,SAAV,EAAqB,CAAC,MAAMjB,IAAI,CAACkB,IAAL,EAAP,EAAoBC,IAApB,CAAyBC,QAA9C;AACH,GAND,CAME,OAAOC,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvC,IAAAA,MAAM,CAAC0C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,sBAA3B;AACA5C,MAAAA,MAAM,CAAC6C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIH;AACJ,CA5CM;AA8CP,OAAO,MAAMO,aAAa,GAAG,kBAAiB;AAC1CN,EAAAA,OAAO,CAACO,GAAR,CAAY,iBAAZ;AACA,QAAMf,KAAK,GAAGvB,QAAQ,EAAtB;AAEA,QAAMuC,IAAI,GAAGhB,KAAK,CAACiB,GAAN,CAAU,WAAV,CAAb;AACA,QAAMrB,aAAa,GAAGI,KAAK,CAACiB,GAAN,CAAU,kBAAV,CAAtB;AACA,QAAMC,WAAW,GAAGlB,KAAK,CAACiB,GAAN,CAAU,aAAV,CAApB;AAEAT,EAAAA,OAAO,CAACO,GAAR,CAAYC,IAAZ;AACAR,EAAAA,OAAO,CAACO,GAAR,CAAYnB,aAAZ;;AAEA,MAAI,CAACoB,IAAD,IAAS,CAACpB,aAAd,EAA6B;AACzB;AACH,GAbyC,CAe1C;AACA;;;AAEA,QAAMuB,MAAM,GAAG,MAAMH,IAAI,CAACnC,GAAL,CAASuC,UAAT,CAAoBxB,aAApB,CAArB;AACAY,EAAAA,OAAO,CAACO,GAAR,CAAY,cAAZ,EAA4BI,MAA5B;AAGAnB,EAAAA,KAAK,CAACG,GAAN,CAAU,YAAV,EAAwBkB,MAAM,CAACL,IAAI,CAACM,KAAL,CAAWC,OAAX,CAAmBJ,MAAnB,CAAD,CAAN,CAAmCK,OAAnC,CAA2C,CAA3C,CAAxB,EAtB0C,CAuB1C;;AACAxB,EAAAA,KAAK,CAACG,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AAEAJ,EAAAA,gBAAgB;AACnB,CA3BM;AA6BP,OAAO,MAAM0B,eAAe,GAAG,kBAAiB;AAC5C,QAAMzB,KAAK,GAAGvB,QAAQ,EAAtB;;AACA,MAAIC,kBAAJ,EAAwB;AACpBgD,IAAAA,aAAa,CAAChD,kBAAD,CAAb;AACH,GAJ2C,CAK5C;;;AACA,QAAMoC,aAAa,EAAnB;AACApC,EAAAA,kBAAkB,GAAGiD,WAAW,CAAC,YAAY;AACzC;AACA,UAAMb,aAAa,EAAnB;AACH,GAH+B,EAG7B,KAAK,IAHwB,CAAhC;AAIH,CAXM;AAaP,OAAO,MAAMc,YAAY,GAAG,kBAAiB;AACzC,QAAM5B,KAAK,GAAGvB,QAAQ,EAAtB;AACA,QAAMoD,OAAO,GAAG7B,KAAK,CAACiB,GAAN,CAAU,iBAAV,CAAhB;AACAjB,EAAAA,KAAK,CAACG,GAAN,CACI,UADJ,EAEI,IAAIlC,IAAJ,CACK,WACD4D,OAAO,KAAK,SAAZ,GAAwB,SAAxB,GAAoC,SACnC,gDAHL,CAFJ;AASH,CAZM;AAcP;;;;AAGA,OAAO,MAAMC,aAAa,GAAG,gBAAeC,IAAf,EAA0B;AACnDvB,EAAAA,OAAO,CAACO,GAAR,CAAY,iBAAZ;AACA,QAAMf,KAAK,GAAGvB,QAAQ,EAAtB;AACAuB,EAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B,IAA9B,EAHmD,CAKnD;;AACA,MAAIH,KAAK,CAACiB,GAAN,CAAU,kBAAV,CAAJ,EAAmC;AAC/B;AACH;;AAEDjB,EAAAA,KAAK,CAACG,GAAN,CAAU,YAAV,EAAwB,KAAxB;AACA,QAAM6B,eAAe,GAAGhC,KAAK,CAACiB,GAAN,CAAU,iBAAV,CAAxB;AAEA,MAAID,IAAJ;AACA,MAAIiB,eAAJ;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIL,OAAO,GAAG,EAAd;;AAEA,MAAI;AACA,QAAIE,IAAI,KAAK,UAAT,IAAuB,CAACA,IAA5B,EAAkC;AAC9B,YAAMI,eAAe,GAAG,EAAxB;AACA,YAAMC,SAAS,GAAG,IAAIjE,SAAJ,CAAc;AAC5B0D,QAAAA,OAAO,EAAEG,eAAe,KAAK,SAApB,GAAgC,SAAhC,GAA4C,SADzB;AAE5BK,QAAAA,aAAa,EAAE,KAFa;AAG5BF,QAAAA;AAH4B,OAAd,CAAlB;AAKA,YAAMG,YAAY,GAAG,MAAMF,SAAS,CAACG,OAAV,EAA3B;AAEAvB,MAAAA,IAAI,GAAG,IAAI/C,IAAJ,CAASqE,YAAT,CAAP;AACAL,MAAAA,eAAe,GAAGjB,IAAI,CAACiB,eAAvB;AACA,UAAI,OAAOA,eAAP,KAA2B,QAA/B,EAAyC;AACzC,UAAI,CAACA,eAAL,EAAsB;AACtBC,MAAAA,QAAQ,GAAG,MAAMlB,IAAI,CAACnC,GAAL,CAAS2D,WAAT,EAAjB;AACA,YAAMC,KAAK,GAAG,MAAMzB,IAAI,CAACnC,GAAL,CAAS6D,GAAT,CAAaC,KAAb,EAApB;;AACA,UAAIF,KAAK,KAAK,CAAd,EAAiB;AACbZ,QAAAA,OAAO,GAAG,SAAV;AACH,OAFD,MAEO,IAAIY,KAAK,KAAK,CAAd,EAAiB;AACpBZ,QAAAA,OAAO,GAAG,SAAV,CADoB,CACC;AACxB,OAFM,MAEA;AACHA,QAAAA,OAAO,GAAG,SAAV;AACH;AACJ,KAtBD,MAsBO,IAAIE,IAAI,KAAK,aAAb,EAA4B;AAC/B,YAAMa,OAAO,GAAGZ,eAAe,KAAK,SAApB,GAAgC,EAAhC,GAAqC,CAArD;AACA,YAAMa,UAAU,GAAI,SAChBb,eAAe,KAAK,SAApB,GAAgC,SAAhC,GAA4C,SAC3C,mDAFL;AAIA,YAAMc,UAAU,GAAG,IAAI1E,UAAU,CAAC2E,QAAf,CAAwB;AACvCC,QAAAA,iBAAiB,EAAE;AADoB,OAAxB,CAAnB;AAGA,YAAMV,YAAY,GAAGQ,UAAU,CAACG,gBAAX,CACjBL,OADiB,EAEjBC,UAFiB,EAGjB,IAHiB,CAArB;AAMA7B,MAAAA,IAAI,GAAG,IAAI/C,IAAJ,CAASqE,YAAT,CAAP;AACAL,MAAAA,eAAe,GAAGjB,IAAI,CAACiB,eAAvB;AAEA,UAAI,OAAOA,eAAP,KAA2B,QAA/B,EAAyC;AACzC,UAAI,CAACA,eAAL,EAAsB;AAEtBC,MAAAA,QAAQ,GAAG,MAAMI,YAAY,CAACY,MAAb,EAAjB;AACArB,MAAAA,OAAO,GAAGG,eAAV;AACH,KAvBM,MAuBA;AACHxB,MAAAA,OAAO,CAACC,KAAR,CAAc,sBAAd;AACAT,MAAAA,KAAK,CAACG,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAH,MAAAA,KAAK,CAACG,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAH,MAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACA;AACH;AACJ,GArDD,CAqDE,OAAOI,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvC,IAAAA,MAAM,CAAC0C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,WAA3B;AACA5C,MAAAA,MAAM,CAAC6C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIAP,IAAAA,KAAK,CAACG,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAH,IAAAA,KAAK,CAACG,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAH,IAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACA;AACH;;AAED,QAAMgD,OAAO,GAAGjB,QAAQ,CAAC,CAAD,CAAxB;AACA,QAAMkB,gBAAgB,GAAGD,OAAO,CAACE,WAAR,EAAzB;AACA,QAAMC,EAAE,GAAGtD,KAAK,CAACiB,GAAN,CAAU,IAAV,CAAX;AACA,QAAMsC,GAAG,GAAGvD,KAAK,CAACiB,GAAN,CAAU,KAAV,CAAZ;;AAEA,MAAIe,eAAe,KAAKH,OAAxB,EAAiC;AAC7B7B,IAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B,IAA9B;AACAH,IAAAA,KAAK,CAACG,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAH,IAAAA,KAAK,CAACG,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAH,IAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACA;AACH,GA9FkD,CAgGnD;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;;AAEAH,EAAAA,KAAK,CAACG,GAAN,CAAU,WAAV,EAAuBa,IAAvB;AACAhB,EAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B+B,QAAQ,CAAC,CAAD,CAAtC;AACAlC,EAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B0B,OAA9B;AACA7B,EAAAA,KAAK,CAACG,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAH,EAAAA,KAAK,CAACG,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AAEAW,EAAAA,aAAa;AAEb,MAAI,CAAC,CAACmB,eAAF,EAA0BuB,EAA9B,EAAkC,OA9NiB,CA+NnD;;AACA,QAAMC,iBAAsB,GAAGxB,eAA/B;;AACA,MAAIwB,iBAAiB,CAACD,EAAtB,EAA0B;AACtB;AACAC,IAAAA,iBAAiB,CAACD,EAAlB,CAAqB,iBAArB,EAAwC,YAAY;AAChDE,MAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,KAFD;AAIAH,IAAAA,iBAAiB,CAACD,EAAlB,CAAqB,cAArB,EAAqC,YAAY;AAC7CE,MAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,KAFD,EANsB,CAUtB;AACA;AACA;;AAEAH,IAAAA,iBAAiB,CAACD,EAAlB,CAAqB,cAArB,EAAqC,YAAY;AAC7CE,MAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,KAFD;AAGH,GAlPkD,CAmPnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACH,CA/PM;AAiQP,OAAO,MAAMC,YAAY,GAAG,kBAAiB;AACzC,QAAM7D,KAAK,GAAGvB,QAAQ,EAAtB;AACA,QAAMoD,OAAO,GAAG7B,KAAK,CAACiB,GAAN,CAAU,iBAAV,CAAhB;;AACA,MAAIY,OAAO,KAAK,SAAhB,EAA2B,CACvB;AACH,GAFD,MAEO,CACH;AACH;AACJ,CARM;AAUP,OAAO,MAAMiC,SAAS,GAAG,gBAAeC,MAAf,EAA4BC,IAA5B,EAAuC;AAC5D,QAAMhE,KAAK,GAAGvB,QAAQ,EAAtB;AACAuB,EAAAA,KAAK,CAACG,GAAN,CAAU,gBAAV,EAA4B4D,MAA5B;AACA/D,EAAAA,KAAK,CAACG,GAAN,CAAU,cAAV,EAA0B6D,IAA1B;AACH,CAJM;AAMP,OAAO,MAAMC,UAAU,GAAG,gBAAepC,OAAf,EAA6B;AACnD,QAAM7B,KAAK,GAAGvB,QAAQ,EAAtB;AACA+B,EAAAA,OAAO,CAACO,GAAR,CAAY,oBAAZ;AACAf,EAAAA,KAAK,CAACG,GAAN,CAAU,iBAAV,EAA6B0B,OAA7B;;AAEA,MAAIA,OAAO,KAAK,SAAhB,EAA2B;AACvB7B,IAAAA,KAAK,CAACG,GAAN,CAAU,qBAAV,EAAiC,UAAjC;AACH,GAFD,MAEO,IAAI0B,OAAO,KAAK,SAAhB,EAA2B;AAC9B7B,IAAAA,KAAK,CAACG,GAAN,CAAU,qBAAV,EAAiC,SAAjC;AACH,GAFM,MAEA,IAAI0B,OAAO,KAAK,SAAhB,EAA2B;AAC9B7B,IAAAA,KAAK,CAACG,GAAN,CAAU,qBAAV,EAAiC,SAAjC;AACH,GAFM,MAEA;AACHH,IAAAA,KAAK,CAACG,GAAN,CAAU,qBAAV,EAAiC,YAAjC;AACH;;AAEDH,EAAAA,KAAK,CAACG,GAAN,CACI,KADJ,EAEI,IAAIjC,SAAJ,CAAc2D,OAAd,EAAuB,CACnB;AACA;AACA;AAHmB,GAAvB,CAFJ,EAfmD,CAuBnD;;AACAgC,EAAAA,YAAY,CAACK,IAAb,CAAkB,IAAlB;AACH,CAzBM,C,CA2BP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,EAAf","sourcesContent":["import * as Sentry from \"@sentry/react\";\n\nimport Web3 from \"web3\";\nimport GatewayJS from \"@renproject/gateway\";\n// import Box from '3box'\nimport Web3Modal from \"web3modal\";\nimport firebase from \"firebase\";\nimport MEWconnect from \"@myetherwallet/mewconnect-web-client\";\n\nimport ELA from \"../assets/ela-1.png\"\nimport ETH from \"../assets/eth.png\";\nimport TRX from \"../assets/tron.png\";\nimport USDT from \"../assets/usdt.png\";\n\nimport { getStore } from \"../services/storeService\";\nimport erc20ABI from \"./erc20ABI.json\";\nimport {\n    USDT_ADDRESS_TEST,\n} from \"./web3Utils\";\n\n// used for montoring balances\nlet walletDataInterval: any = null;\n\n// export const ASSETS = [\"BTC\", \"WBTC\"];\n\n// Top level bridge selection options\nexport const BRIDGE_SYMBOL_MAP: { [key in string]: string } = {\n    ela: \"ELA\",\n    eth: \"ETH\",\n    trx: \"TRX\"\n}\nexport const BRIDGE_NAME_MAP: { [key in string]: string } = {\n    ela: \"Elastos\",\n    eth: \"Ethereum\",\n    trx: \"Tron\"\n}\nexport const BRIDGE_ICON_MAP: { [key in string]: string } = {\n    ela: ELA,\n    eth: ETH,\n    trx: TRX\n}\n/////////////////////////////////////\n\nexport const NAME_MAP = {\n    ela: \"Elastos\",\n    eth: \"Ethereum\",\n    usdt: \"Tether\",\n    wela: \"Wrapped Elastos\",\n    weth: \"Wrapped Ethereum\",\n    wusdt: \"Wrapped Tether\",\n};\n\nexport const SYMBOL_MAP = {\n    ela: \"ELA\",\n    eth: \"ETH\",\n    usdt: \"USDT\",\n    wela: \"wELA\",\n    weth: \"wETH\",\n    wusdt: \"wUSDT\",\n};\n\nexport const CONVERT_MAP = {\n    ela: \"wela\",\n    eth: \"weth\",\n    usdt: \"wusdt\",\n    wela: \"ela\",\n    weth: \"eth\",\n    wusdt: \"usdt\",\n};\n\nexport const NETWORK_MAP = {\n    ela: \"Elastos\",\n    eth: \"Ethereum\",\n    usdt: \"Ethereum\",\n    wela: \"Ethereum\",\n    weth: \"Elastos\",\n    wusdt: \"Elastos\",\n};\n\nexport const MINI_ICON_MAP: { [key in string]: string } = {\n    ela: ELA,\n    eth: ETH,\n    usdt: USDT,\n    wela: ELA,\n    weth: ETH,\n    wusdt: USDT,\n};\n\nexport const SUPPORTED_NETWORKS = {\n    1: 'MAINNET',\n    3: 'ROPSTEN',\n    4: 'RINKEBY',\n    42: 'KOVAN',\n};\n\nexport const abbreviateAddress = function(walletAddress: string) {\n    if (!walletAddress || typeof walletAddress !== \"string\") {\n        return \"\";\n    } else {\n        return (\n            walletAddress.slice(0, 5) +\n            \"...\" +\n            walletAddress.slice(walletAddress.length - 5)\n        );\n    }\n};\n\nexport const updateMarketData = async function() {\n    const store = getStore();\n\n    try {\n        const eth = await fetch(`https://api.coincap.io/v2/assets/ethereum`, {\n            method: \"GET\",\n        });\n\n        store.set(\"ethusd\", (await eth.json()).data.priceUsd);\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"updating market data\");\n            Sentry.captureException(e);\n        });\n    }\n\n    try {\n        const ela = await fetch(`https://api.coincap.io/v2/assets/elastos`, {\n            method: \"GET\",\n        });\n\n        store.set(\"elausd\", (await ela.json()).data.priceUsd);\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"updating market data\");\n            Sentry.captureException(e);\n        });\n    }\n\n    try {\n        const usdt = await fetch(`https://api.coincap.io/v2/assets/tether`, {\n            method: \"GET\",\n        });\n\n        store.set(\"usdtusd\", (await usdt.json()).data.priceUsd);\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"updating market data\");\n            Sentry.captureException(e);\n        });\n    }\n};\n\nexport const updateBalance = async function() {\n    console.log('Update Balances')\n    const store = getStore();\n\n    const web3 = store.get(\"localWeb3\");\n    const walletAddress = store.get(\"localWeb3Address\");\n    const USDTAddress = store.get(\"USDTAddress\");\n\n    console.log(web3)\n    console.log(walletAddress)\n\n    if (!web3 || !walletAddress) {\n        return;\n    }\n\n    // const usdt = new web3.eth.Contract(erc20ABI, USDTAddress);\n    // const usdtBal = await usdt.methods.balanceOf(walletAddress).call();\n\n    const ethBal = await web3.eth.getBalance(walletAddress);\n    console.log('ETH BALANACE', ethBal)\n\n\n    store.set(\"ETHBalance\", Number(web3.utils.fromWei(ethBal)).toFixed(4));\n    // store.set(\"USDTBalance\", Number(parseInt(usdtBal.toString()) / 10 ** 8).toFixed(8));\n    store.set(\"loadingBalances\", false);\n\n    updateMarketData();\n};\n\nexport const watchWalletData = async function() {\n    const store = getStore();\n    if (walletDataInterval) {\n        clearInterval(walletDataInterval);\n    }\n    // await updateAllowance()\n    await updateBalance();\n    walletDataInterval = setInterval(async () => {\n        // await updateAllowance()\n        await updateBalance();\n    }, 10 * 1000);\n};\n\nexport const initDataWeb3 = async function() {\n    const store = getStore();\n    const network = store.get(\"selectedNetwork\");\n    store.set(\n        \"dataWeb3\",\n        new Web3(\n            `https://${\n            network === \"testnet\" ? \"rinkeby\" : \"mainnet\"\n            }.infura.io/v3/bd80ce1ca1f94da48e151bb6868bb150`\n        )\n    );\n\n};\n\n/**\n * Connecting to Local Web3 Wallet\n */\nexport const initLocalWeb3 = async function(type: any) {\n    console.log(\"Init Local Web3\")\n    const store = getStore();\n    store.set(\"walletConnecting\", true);\n\n    // already connected\n    if (store.get(\"localWeb3Address\")) {\n        return;\n    }\n\n    store.set(\"spaceError\", false);\n    const selectedNetwork = store.get(\"selectedNetwork\");\n\n    let web3;\n    let currentProvider;\n    let accounts = [];\n    let network = \"\";\n\n    try {\n        if (type === \"injected\" || !type) {\n            const providerOptions = {};\n            const web3Modal = new Web3Modal({\n                network: selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\",\n                cacheProvider: false,\n                providerOptions,\n            });\n            const web3Provider = await web3Modal.connect();\n\n            web3 = new Web3(web3Provider);\n            currentProvider = web3.currentProvider;\n            if (typeof currentProvider === \"string\") return;\n            if (!currentProvider) return;\n            accounts = await web3.eth.getAccounts();\n            const netId = await web3.eth.net.getId();\n            if (netId === 1) {\n                network = \"mainnet\";\n            } else if (netId === 4) {\n                network = \"mainnet\"; //testnet\n            } else {\n                network = \"mainnet\";\n            }\n        } else if (type === \"mew-connect\") {\n            const chainId = selectedNetwork === \"testnet\" ? 42 : 1;\n            const jsonRpcUrl = `wss://${\n                selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\"\n                }.infura.io/ws/v3/7117ca7a3c7b4b94b24944c1ef0ecec9`;\n\n            const mewConnect = new MEWconnect.Provider({\n                windowClosedError: true,\n            });\n            const web3Provider = mewConnect.makeWeb3Provider(\n                chainId,\n                jsonRpcUrl,\n                true\n            );\n\n            web3 = new Web3(web3Provider);\n            currentProvider = web3.currentProvider;\n\n            if (typeof currentProvider === \"string\") return;\n            if (!currentProvider) return;\n\n            accounts = await web3Provider.enable();\n            network = selectedNetwork;\n        } else {\n            console.error(\"Invalid wallet type.\");\n            store.set(\"spaceError\", true);\n            store.set(\"spaceRequesting\", false);\n            store.set(\"walletConnecting\", false);\n            return;\n        }\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"web3 init\");\n            Sentry.captureException(e);\n        });\n        store.set(\"spaceError\", true);\n        store.set(\"spaceRequesting\", false);\n        store.set(\"walletConnecting\", false);\n        return;\n    }\n\n    const address = accounts[0];\n    const addressLowerCase = address.toLowerCase();\n    const db = store.get(\"db\");\n    const fns = store.get(\"fns\");\n\n    if (selectedNetwork !== network) {\n        store.set(\"showNetworkModal\", true);\n        store.set(\"spaceError\", true);\n        store.set(\"spaceRequesting\", false);\n        store.set(\"walletConnecting\", false);\n        return;\n    }\n\n    // try {\n    //     ///////////////////////////////////////////////////////\n    //     // Firebase Sign In or Sign Up\n    //     //////////////////////////////////////////////////////\n\n    //     let signature = \"\";\n    //     let rawSig = \"\";\n\n    //     // get from local storage if user has signed in already\n    //     const localSigMap = localStorage.getItem(\"sigMap\");\n    //     const localRawSigMap = JSON.parse(\n    //         localStorage.getItem(\"rawSigMap\") || \"{}\"\n    //     );\n    //     const localSigMapData = localSigMap ? JSON.parse(localSigMap) : {};\n    //     if (localSigMapData[addressLowerCase] && localRawSigMap[addressLowerCase]) {\n    //         signature = localSigMapData[addressLowerCase];\n    //         rawSig = localRawSigMap[addressLowerCase];\n    //     } else {\n    //         // get unique wallet signature for firebase backup\n    //         // @ts-ignore\n    //         rawSig = await web3.eth.personal.sign(\n    //             web3.utils.utf8ToHex(\"Signing in to RenBridge\"),\n    //             addressLowerCase\n    //         );\n    //         signature = web3.utils.sha3(rawSig)!;\n    //         localSigMapData[addressLowerCase] = signature;\n    //         localStorage.setItem(\"sigMap\", JSON.stringify(localSigMapData));\n\n    //         localRawSigMap[addressLowerCase] = rawSig;\n    //         localStorage.setItem(\"rawSigMap\", JSON.stringify(localRawSigMap));\n    //     }\n\n    //     store.set(\"fsSignature\", signature);\n\n    //     let token: string | null = null;\n    //     try {\n    //         const res = await fns.httpsCallable(\"authenticate\")({\n    //             signed: rawSig,\n    //             account: addressLowerCase,\n    //         });\n\n    //         token = res.data.token;\n    //         if (!token) {\n    //             throw new Error(\"missing token\");\n    //         }\n    //     } catch (e) {\n    //         console.log(\"No token auth, falling back to email / sig\");\n    //     }\n\n    //     // auth with firestore\n    //     const bridgeId = `${addressLowerCase}@renproject.io`;\n    //     const currentFsUser = firebase.auth().currentUser;\n    //     let fsUser;\n\n    //     if (!currentFsUser || currentFsUser.email !== bridgeId) {\n    //         try {\n    //             fsUser = token\n    //                 ? (await firebase.auth().signInWithCustomToken(token)).user\n    //                 : (\n    //                     await firebase\n    //                         .auth()\n    //                         .signInWithEmailAndPassword(bridgeId, signature)\n    //                 ).user;\n    //         } catch (e) {\n    //             console.error(e);\n    //             // We can register this user as they do not exist\n    //             if (e.message.includes(\"There is no user record\")) {\n    //                 fsUser = (\n    //                     await firebase\n    //                         .auth()\n    //                         .createUserWithEmailAndPassword(bridgeId, signature)\n    //                 ).user;\n    //             } else {\n    //                 console.error(e);\n    //                 Sentry.withScope(function(scope) {\n    //                     scope.setTag(\"error-hint\", \"web3 init\");\n    //                     Sentry.captureException(e);\n    //                 });\n    //             }\n    //         }\n    //     } else {\n    //         fsUser = currentFsUser;\n    //     }\n\n    //     store.set(\"fsUser\", fsUser);\n\n    //     if (fsUser) {\n    //         // update user collection\n    //         const doc = await db.collection(\"users\").doc(fsUser.uid);\n    //         const docData = await doc.get();\n\n    //         if (docData.exists) {\n    //             const data = docData.data();\n    //             if (data.signatures.indexOf(signature) < 0) {\n    //                 // add a new signature if needed\n    //                 await doc.update({\n    //                     signatures: data.signatures.concat([signature]),\n    //                     updated: firebase.firestore.Timestamp.fromDate(\n    //                         new Date(Date.now())\n    //                     ),\n    //                 });\n    //             }\n    //         } else {\n    //             // create user\n    //             await doc.set({\n    //                 uid: fsUser.uid,\n    //                 updated: firebase.firestore.Timestamp.fromDate(new Date(Date.now())),\n    //                 signatures: [signature],\n    //             });\n    //         }\n    //     }\n\n    //     store.set(\"fsEnabled\", true);\n\n    ///////////////////////////////////////////////////////\n    // Recover Transactions\n    //////////////////////////////////////////////////////\n\n    store.set(\"localWeb3\", web3);\n    store.set(\"localWeb3Address\", accounts[0]);\n    store.set(\"localWeb3Network\", network);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n\n    updateBalance();\n\n    if ((!currentProvider as any).on) return;\n    // FIXME: provide propper provider type\n    const listeningProvider: any = currentProvider;\n    if (listeningProvider.on) {\n        // listen for changes\n        listeningProvider.on(\"accountsChanged\", async () => {\n            window.location.reload();\n        });\n\n        listeningProvider.on(\"chainChanged\", async () => {\n            window.location.reload();\n        });\n\n        // listeningProvider.on(\"networkChanged\", async () => {\n        //     window.location.reload();\n        // });\n\n        listeningProvider.on(\"disconnected\", async () => {\n            window.location.reload();\n        });\n    }\n    // } catch (e) {\n    //     console.error(e);\n    //     Sentry.withScope(function(scope) {\n    //         scope.setTag(\"error-hint\", \"main initialization\");\n    //         Sentry.captureException(e);\n    //     });\n    //     store.set(\"spaceError\", true);\n    //     store.set(\"spaceRequesting\", false);\n    //     store.set(\"walletConnecting\", false);\n    // }\n\n    return;\n};\n\nexport const setAddresses = async function() {\n    const store = getStore();\n    const network = store.get(\"selectedNetwork\");\n    if (network === \"testnet\") {\n        // store.set(\"renELAAddress\", RENELA_TEST);\n    } else {\n        // store.set(\"renELAAddress\", RENELA_MAIN);\n    }\n};\n\nexport const setBridge = async function(bridge: any, pair: any) {\n    const store = getStore();\n    store.set(\"selectedBridge\", bridge);\n    store.set(\"selectedPair\", pair);\n}\n\nexport const setNetwork = async function(network: any) {\n    const store = getStore();\n    console.log('NETWORK CONNECTION')\n    store.set(\"selectedNetwork\", network);\n\n    if (network === \"mainnet\") {\n        store.set(\"selectedNetworkName\", \"Ethereum\");\n    } else if (network === \"testnet\") {\n        store.set(\"selectedNetworkName\", \"Rinkeby\");\n    } else if (network === \"private\") {\n        store.set(\"selectedNetworkName\", \"Elastos\");\n    } else {\n        store.set(\"selectedNetworkName\", \"No Network\");\n    }\n\n    store.set(\n        \"gjs\",\n        new GatewayJS(network, {\n            // If we want to test against gatewayjs staging, we should change the endpoint\n            // manually in a PR, which does not get merged, and check the preview build\n            // endpoint: \"https://ren-gatewayjs-staging.netlify.app/\",\n        })\n    );\n    // @ts-ignore\n    setAddresses.bind(this)();\n};\n\n// export async function getEthereumNetwork() {\n// \tif (!window.web3) return { name: 'MAINNET', networkId: 1 };\n// \tlet networkId = 1;\n// \ttry {\n// \t\tif (window.web3?.eth?.net) {\n// \t\t\tnetworkId = await window.web3.eth.net.getId();\n// \t\t\treturn { name: SUPPORTED_NETWORKS[networkId], networkId: Number(networkId) };\n// \t\t} else if (window.web3?.version?.network) {\n// \t\t\tnetworkId = Number(window.web3.version.network);\n// \t\t\treturn { name: SUPPORTED_NETWORKS[networkId], networkId };\n// \t\t} else if (window.ethereum?.networkVersion) {\n// \t\t\tnetworkId = Number(window.ethereum?.networkVersion);\n// \t\t\treturn { name: SUPPORTED_NETWORKS[networkId], networkId };\n// \t\t}\n// \t\treturn { name: 'MAINNET', networkId };\n// \t} catch (e) {\n// \t\tconsole.log(e);\n// \t\treturn { name: 'MAINNET', networkId };\n// \t}\n// }\n\nexport default {};\n"]},"metadata":{},"sourceType":"module"}