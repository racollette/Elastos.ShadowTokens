{"ast":null,"code":"var bip66 = require('bip66');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nfunction ECSignature(r, s) {\n  typeforce(types.tuple(types.BigInt, types.BigInt), arguments);\n  this.r = r;\n  this.s = s;\n}\n\nECSignature.parseCompact = function (buffer) {\n  typeforce(types.BufferN(65), buffer);\n  var flagByte = buffer.readUInt8(0) - 27;\n  if (flagByte !== (flagByte & 7)) throw new Error('Invalid signature parameter');\n  var compressed = !!(flagByte & 4);\n  var recoveryParam = flagByte & 3;\n  var signature = ECSignature.fromRSBuffer(buffer.slice(1));\n  return {\n    compressed: compressed,\n    i: recoveryParam,\n    signature: signature\n  };\n};\n\nECSignature.fromRSBuffer = function (buffer) {\n  typeforce(types.BufferN(64), buffer);\n  var r = BigInteger.fromBuffer(buffer.slice(0, 32));\n  var s = BigInteger.fromBuffer(buffer.slice(32, 64));\n  return new ECSignature(r, s);\n};\n\nECSignature.fromDER = function (buffer) {\n  var decode = bip66.decode(buffer);\n  var r = BigInteger.fromDERInteger(decode.r);\n  var s = BigInteger.fromDERInteger(decode.s);\n  return new ECSignature(r, s);\n}; // BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n\n\nECSignature.parseScriptSignature = function (buffer) {\n  var hashType = buffer.readUInt8(buffer.length - 1);\n  var hashTypeMod = hashType & ~0xc0;\n  if (hashTypeMod <= 0x00 || hashTypeMod >= 0x04) throw new Error('Invalid hashType ' + hashType);\n  return {\n    signature: ECSignature.fromDER(buffer.slice(0, -1)),\n    hashType: hashType\n  };\n};\n\nECSignature.prototype.toCompact = function (i, compressed) {\n  if (compressed) {\n    i += 4;\n  }\n\n  i += 27;\n  var buffer = Buffer.alloc(65);\n  buffer.writeUInt8(i, 0);\n  this.toRSBuffer(buffer, 1);\n  return buffer;\n};\n\nECSignature.prototype.toDER = function () {\n  var r = Buffer.from(this.r.toDERInteger());\n  var s = Buffer.from(this.s.toDERInteger());\n  return bip66.encode(r, s);\n};\n\nECSignature.prototype.toRSBuffer = function (buffer, offset) {\n  buffer = buffer || Buffer.alloc(64);\n  this.r.toBuffer(32).copy(buffer, offset);\n  this.s.toBuffer(32).copy(buffer, offset + 32);\n  return buffer;\n};\n\nECSignature.prototype.toScriptSignature = function (hashType) {\n  var hashTypeMod = hashType & ~0xc0;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  var hashTypeBuffer = Buffer.alloc(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  return Buffer.concat([this.toDER(), hashTypeBuffer]);\n};\n\nmodule.exports = ECSignature;","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitgo-utxo-lib/src/ecsignature.js"],"names":["bip66","require","typeforce","types","BigInteger","ECSignature","r","s","tuple","BigInt","arguments","parseCompact","buffer","BufferN","flagByte","readUInt8","Error","compressed","recoveryParam","signature","fromRSBuffer","slice","i","fromBuffer","fromDER","decode","fromDERInteger","parseScriptSignature","hashType","length","hashTypeMod","prototype","toCompact","Buffer","alloc","writeUInt8","toRSBuffer","toDER","from","toDERInteger","encode","offset","toBuffer","copy","toScriptSignature","hashTypeBuffer","concat","module","exports"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,SAAD,CAAnB;;AAEA,IAAIG,UAAU,GAAGH,OAAO,CAAC,MAAD,CAAxB;;AAEA,SAASI,WAAT,CAAsBC,CAAtB,EAAyBC,CAAzB,EAA4B;AAC1BL,EAAAA,SAAS,CAACC,KAAK,CAACK,KAAN,CAAYL,KAAK,CAACM,MAAlB,EAA0BN,KAAK,CAACM,MAAhC,CAAD,EAA0CC,SAA1C,CAAT;AAEA,OAAKJ,CAAL,GAASA,CAAT;AACA,OAAKC,CAAL,GAASA,CAAT;AACD;;AAEDF,WAAW,CAACM,YAAZ,GAA2B,UAAUC,MAAV,EAAkB;AAC3CV,EAAAA,SAAS,CAACC,KAAK,CAACU,OAAN,CAAc,EAAd,CAAD,EAAoBD,MAApB,CAAT;AAEA,MAAIE,QAAQ,GAAGF,MAAM,CAACG,SAAP,CAAiB,CAAjB,IAAsB,EAArC;AACA,MAAID,QAAQ,MAAMA,QAAQ,GAAG,CAAjB,CAAZ,EAAiC,MAAM,IAAIE,KAAJ,CAAU,6BAAV,CAAN;AAEjC,MAAIC,UAAU,GAAG,CAAC,EAAEH,QAAQ,GAAG,CAAb,CAAlB;AACA,MAAII,aAAa,GAAGJ,QAAQ,GAAG,CAA/B;AACA,MAAIK,SAAS,GAAGd,WAAW,CAACe,YAAZ,CAAyBR,MAAM,CAACS,KAAP,CAAa,CAAb,CAAzB,CAAhB;AAEA,SAAO;AACLJ,IAAAA,UAAU,EAAEA,UADP;AAELK,IAAAA,CAAC,EAAEJ,aAFE;AAGLC,IAAAA,SAAS,EAAEA;AAHN,GAAP;AAKD,CAfD;;AAiBAd,WAAW,CAACe,YAAZ,GAA2B,UAAUR,MAAV,EAAkB;AAC3CV,EAAAA,SAAS,CAACC,KAAK,CAACU,OAAN,CAAc,EAAd,CAAD,EAAoBD,MAApB,CAAT;AAEA,MAAIN,CAAC,GAAGF,UAAU,CAACmB,UAAX,CAAsBX,MAAM,CAACS,KAAP,CAAa,CAAb,EAAgB,EAAhB,CAAtB,CAAR;AACA,MAAId,CAAC,GAAGH,UAAU,CAACmB,UAAX,CAAsBX,MAAM,CAACS,KAAP,CAAa,EAAb,EAAiB,EAAjB,CAAtB,CAAR;AACA,SAAO,IAAIhB,WAAJ,CAAgBC,CAAhB,EAAmBC,CAAnB,CAAP;AACD,CAND;;AAQAF,WAAW,CAACmB,OAAZ,GAAsB,UAAUZ,MAAV,EAAkB;AACtC,MAAIa,MAAM,GAAGzB,KAAK,CAACyB,MAAN,CAAab,MAAb,CAAb;AACA,MAAIN,CAAC,GAAGF,UAAU,CAACsB,cAAX,CAA0BD,MAAM,CAACnB,CAAjC,CAAR;AACA,MAAIC,CAAC,GAAGH,UAAU,CAACsB,cAAX,CAA0BD,MAAM,CAAClB,CAAjC,CAAR;AAEA,SAAO,IAAIF,WAAJ,CAAgBC,CAAhB,EAAmBC,CAAnB,CAAP;AACD,CAND,C,CAQA;;;AACAF,WAAW,CAACsB,oBAAZ,GAAmC,UAAUf,MAAV,EAAkB;AACnD,MAAIgB,QAAQ,GAAGhB,MAAM,CAACG,SAAP,CAAiBH,MAAM,CAACiB,MAAP,GAAgB,CAAjC,CAAf;AACA,MAAIC,WAAW,GAAGF,QAAQ,GAAG,CAAC,IAA9B;AAEA,MAAIE,WAAW,IAAI,IAAf,IAAuBA,WAAW,IAAI,IAA1C,EAAgD,MAAM,IAAId,KAAJ,CAAU,sBAAsBY,QAAhC,CAAN;AAEhD,SAAO;AACLT,IAAAA,SAAS,EAAEd,WAAW,CAACmB,OAAZ,CAAoBZ,MAAM,CAACS,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAApB,CADN;AAELO,IAAAA,QAAQ,EAAEA;AAFL,GAAP;AAID,CAVD;;AAYAvB,WAAW,CAAC0B,SAAZ,CAAsBC,SAAtB,GAAkC,UAAUV,CAAV,EAAaL,UAAb,EAAyB;AACzD,MAAIA,UAAJ,EAAgB;AACdK,IAAAA,CAAC,IAAI,CAAL;AACD;;AAEDA,EAAAA,CAAC,IAAI,EAAL;AAEA,MAAIV,MAAM,GAAGqB,MAAM,CAACC,KAAP,CAAa,EAAb,CAAb;AACAtB,EAAAA,MAAM,CAACuB,UAAP,CAAkBb,CAAlB,EAAqB,CAArB;AACA,OAAKc,UAAL,CAAgBxB,MAAhB,EAAwB,CAAxB;AACA,SAAOA,MAAP;AACD,CAXD;;AAaAP,WAAW,CAAC0B,SAAZ,CAAsBM,KAAtB,GAA8B,YAAY;AACxC,MAAI/B,CAAC,GAAG2B,MAAM,CAACK,IAAP,CAAY,KAAKhC,CAAL,CAAOiC,YAAP,EAAZ,CAAR;AACA,MAAIhC,CAAC,GAAG0B,MAAM,CAACK,IAAP,CAAY,KAAK/B,CAAL,CAAOgC,YAAP,EAAZ,CAAR;AAEA,SAAOvC,KAAK,CAACwC,MAAN,CAAalC,CAAb,EAAgBC,CAAhB,CAAP;AACD,CALD;;AAOAF,WAAW,CAAC0B,SAAZ,CAAsBK,UAAtB,GAAmC,UAAUxB,MAAV,EAAkB6B,MAAlB,EAA0B;AAC3D7B,EAAAA,MAAM,GAAGA,MAAM,IAAIqB,MAAM,CAACC,KAAP,CAAa,EAAb,CAAnB;AACA,OAAK5B,CAAL,CAAOoC,QAAP,CAAgB,EAAhB,EAAoBC,IAApB,CAAyB/B,MAAzB,EAAiC6B,MAAjC;AACA,OAAKlC,CAAL,CAAOmC,QAAP,CAAgB,EAAhB,EAAoBC,IAApB,CAAyB/B,MAAzB,EAAiC6B,MAAM,GAAG,EAA1C;AACA,SAAO7B,MAAP;AACD,CALD;;AAOAP,WAAW,CAAC0B,SAAZ,CAAsBa,iBAAtB,GAA0C,UAAUhB,QAAV,EAAoB;AAC5D,MAAIE,WAAW,GAAGF,QAAQ,GAAG,CAAC,IAA9B;AACA,MAAIE,WAAW,IAAI,CAAf,IAAoBA,WAAW,IAAI,CAAvC,EAA0C,MAAM,IAAId,KAAJ,CAAU,sBAAsBY,QAAhC,CAAN;AAE1C,MAAIiB,cAAc,GAAGZ,MAAM,CAACC,KAAP,CAAa,CAAb,CAArB;AACAW,EAAAA,cAAc,CAACV,UAAf,CAA0BP,QAA1B,EAAoC,CAApC;AAEA,SAAOK,MAAM,CAACa,MAAP,CAAc,CAAC,KAAKT,KAAL,EAAD,EAAeQ,cAAf,CAAd,CAAP;AACD,CARD;;AAUAE,MAAM,CAACC,OAAP,GAAiB3C,WAAjB","sourcesContent":["var bip66 = require('bip66')\nvar typeforce = require('typeforce')\nvar types = require('./types')\n\nvar BigInteger = require('bigi')\n\nfunction ECSignature (r, s) {\n  typeforce(types.tuple(types.BigInt, types.BigInt), arguments)\n\n  this.r = r\n  this.s = s\n}\n\nECSignature.parseCompact = function (buffer) {\n  typeforce(types.BufferN(65), buffer)\n\n  var flagByte = buffer.readUInt8(0) - 27\n  if (flagByte !== (flagByte & 7)) throw new Error('Invalid signature parameter')\n\n  var compressed = !!(flagByte & 4)\n  var recoveryParam = flagByte & 3\n  var signature = ECSignature.fromRSBuffer(buffer.slice(1))\n\n  return {\n    compressed: compressed,\n    i: recoveryParam,\n    signature: signature\n  }\n}\n\nECSignature.fromRSBuffer = function (buffer) {\n  typeforce(types.BufferN(64), buffer)\n\n  var r = BigInteger.fromBuffer(buffer.slice(0, 32))\n  var s = BigInteger.fromBuffer(buffer.slice(32, 64))\n  return new ECSignature(r, s)\n}\n\nECSignature.fromDER = function (buffer) {\n  var decode = bip66.decode(buffer)\n  var r = BigInteger.fromDERInteger(decode.r)\n  var s = BigInteger.fromDERInteger(decode.s)\n\n  return new ECSignature(r, s)\n}\n\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nECSignature.parseScriptSignature = function (buffer) {\n  var hashType = buffer.readUInt8(buffer.length - 1)\n  var hashTypeMod = hashType & ~0xc0\n\n  if (hashTypeMod <= 0x00 || hashTypeMod >= 0x04) throw new Error('Invalid hashType ' + hashType)\n\n  return {\n    signature: ECSignature.fromDER(buffer.slice(0, -1)),\n    hashType: hashType\n  }\n}\n\nECSignature.prototype.toCompact = function (i, compressed) {\n  if (compressed) {\n    i += 4\n  }\n\n  i += 27\n\n  var buffer = Buffer.alloc(65)\n  buffer.writeUInt8(i, 0)\n  this.toRSBuffer(buffer, 1)\n  return buffer\n}\n\nECSignature.prototype.toDER = function () {\n  var r = Buffer.from(this.r.toDERInteger())\n  var s = Buffer.from(this.s.toDERInteger())\n\n  return bip66.encode(r, s)\n}\n\nECSignature.prototype.toRSBuffer = function (buffer, offset) {\n  buffer = buffer || Buffer.alloc(64)\n  this.r.toBuffer(32).copy(buffer, offset)\n  this.s.toBuffer(32).copy(buffer, offset + 32)\n  return buffer\n}\n\nECSignature.prototype.toScriptSignature = function (hashType) {\n  var hashTypeMod = hashType & ~0xc0\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType)\n\n  var hashTypeBuffer = Buffer.alloc(1)\n  hashTypeBuffer.writeUInt8(hashType, 0)\n\n  return Buffer.concat([this.toDER(), hashTypeBuffer])\n}\n\nmodule.exports = ECSignature\n"]},"metadata":{},"sourceType":"script"}