{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar BlockHeader = require('./blockheader');\n\nvar BufferUtil = require('../util/buffer');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar Hash = require('../crypto/hash');\n\nvar JSUtil = require('../util/js');\n\nvar Transaction = require('../transaction');\n\nvar errors = require('../errors');\n\nvar $ = require('../util/preconditions');\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\n\n\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n\n    if (arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n\n  _.extend(this, info);\n\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n  return this;\n}\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\n\n\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\n\n\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n/**\n * @returns {Buffer} - A buffer of the block\n */\n\n\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\n\n\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n\n  bw.writeVarintNum(this.flags.length);\n\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n\n  return bw;\n};\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\n\n\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\n\n\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions\n\n  if (this.hashes.length > this.numTransactions) {\n    return false;\n  } // Can't have more flag bits than num hashes\n\n\n  if (this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n\n  var opts = {\n    hashesUsed: 0,\n    flagBitsUsed: 0\n  };\n\n  var root = this._traverseMerkleTree(height, 0, opts);\n\n  if (opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\n\n\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions\n\n  if (this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  } // Can't have more flag bits than num hashes\n\n\n  if (this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  } // If there is only one hash the filter do not match any txs in the block\n\n\n  if (this.hashes.length === 1) {\n    return [];\n  }\n\n  ;\n\n  var height = this._calcTreeHeight();\n\n  var opts = {\n    hashesUsed: 0,\n    flagBitsUsed: 0\n  };\n\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n\n  if (opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  return txs;\n};\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\n\n\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n\n  /* jshint maxstatements: 20 */\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n\n  if (opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n\n  var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;\n\n  if (depth === 0 || !isParentOfMatch) {\n    if (opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n\n    var hash = this.hashes[opts.hashesUsed++];\n\n    if (depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);\n\n    var right = left;\n\n    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {\n      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);\n    }\n\n    if (checkForTxs) {\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    }\n\n    ;\n  }\n};\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\n\n\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return this.numTransactions + (1 << height) - 1 >> height;\n};\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\n\n\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n\n  return height;\n};\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\n\n\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n  var hash = tx;\n\n  if (tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n\n  var height = this._calcTreeHeight();\n\n  this._traverseMerkleTree(height, 0, {\n    txs: txs\n  });\n\n  return txs.indexOf(hash) !== -1;\n};\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\n\n\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n\n  return info;\n};\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\n\n\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib-cash/lib/block/merkleblock.js"],"names":["_","require","BlockHeader","BufferUtil","BufferReader","BufferWriter","Hash","JSUtil","Transaction","errors","$","MerkleBlock","arg","info","isBuffer","_fromBufferReader","isObject","header","fromObject","numTransactions","hashes","flags","TypeError","extend","_flagBitsUsed","_hashesUsed","fromBuffer","buf","fromBufferReader","br","prototype","toBuffer","toBufferWriter","concat","bw","write","writeUInt32LE","writeVarintNum","length","i","Buffer","from","writeUInt8","toObject","toJSON","validMerkleTree","checkState","isArray","height","_calcTreeHeight","opts","hashesUsed","flagBitsUsed","root","_traverseMerkleTree","equals","merkleRoot","filterdTxsHash","InvalidMerkleTree","txs","traverseMerkleTree","depth","pos","checkForTxs","isParentOfMatch","hash","push","left","right","_calcTreeWidth","sha256sha256","calcTreeWidth","calcTreeHeight","hasTransaction","tx","checkArgument","isUndefined","reverse","id","toString","indexOf","finished","readUInt32LE","numHashes","readVarintNum","read","numFlags","readUInt8","obj","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar JSUtil = require('../util/js');\nvar Transaction = require('../transaction');\nvar errors = require('../errors');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if(arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this,info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if(opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // If there is only one hash the filter do not match any txs in the block\n  if(this.hashes.length === 1) {\n    return [];\n  };\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n  if(opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n  return txs;\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n\n  if(opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\n  if(depth === 0 || !isParentOfMatch) {\n    if(opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if(depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\n    var right = left;\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\n    }\n    if (checkForTxs){\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    };\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return (this.numTransactions + (1 << height) - 1) >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n\n  var hash = tx;\n  if(tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, { txs: txs });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;\n"]},"metadata":{},"sourceType":"script"}