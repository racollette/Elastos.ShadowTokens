{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar Address = require('./address');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar BN = require('./crypto/bn');\n\nvar JSUtil = require('./util/js');\n\nvar Networks = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PublicKey = require('./publickey');\n\nvar Random = require('./crypto/random');\n\nvar $ = require('./util/preconditions');\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\n\n\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n\n  /* jshint maxcomplexity: 8 */\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network); // validation\n\n\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0) {\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n\n  if (typeof info.network === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n  return this;\n}\n\n;\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\n\nPrivateKey.prototype._classifyArguments = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  }; // detect type of data\n\n  if (_.isUndefined(data) || _.isNull(data)) {\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network) {\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof data === 'string') {\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n\n  return info;\n};\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\n\n\nPrivateKey._getRandomBN = function () {\n  var condition;\n  var bn;\n\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n\n  return bn;\n};\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformBuffer = function (buf, network) {\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n  return info;\n};\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\n\n\nPrivateKey._transformBNBuffer = function (buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformWIF = function (str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\n\n\nPrivateKey.fromBuffer = function (arg, network) {\n  return new PrivateKey(arg, network);\n};\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformObject = function (json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromString = PrivateKey.fromWIF = function (str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\n\n\nPrivateKey.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromRandom = function (network) {\n  var bn = PrivateKey._getRandomBN();\n\n  return new PrivateKey(bn, network);\n};\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\n\nPrivateKey.getValidationError = function (data, network) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\n\n\nPrivateKey.isValid = function (data, network) {\n  if (!data) {\n    return false;\n  }\n\n  return !PrivateKey.getValidationError(data, network);\n};\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\n\n\nPrivateKey.prototype.toString = function () {\n  return this.toBuffer().toString('hex');\n};\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\n\n\nPrivateKey.prototype.toWIF = function () {\n  var network = this.network;\n  var compressed = this.compressed;\n  var buf;\n\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]), this.bn.toBuffer({\n      size: 32\n    }), Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]), this.bn.toBuffer({\n      size: 32\n    })]);\n  }\n\n  return Base58Check.encode(buf);\n};\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\n\n\nPrivateKey.prototype.toBigNumber = function () {\n  return this.bn;\n};\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBuffer = function () {\n  return this.bn.toBuffer({\n    size: 32\n  });\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBufferNoPadding = function () {\n  return this.bn.toBuffer();\n};\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\n\n\nPrivateKey.prototype.toPublicKey = function () {\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n\n  return this._pubkey;\n};\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\n\n\nPrivateKey.prototype.toAddress = function (network) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network);\n};\n/**\n * @returns {Object} A plain object representation\n */\n\n\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\n\n\nPrivateKey.prototype.inspect = function () {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitcore-lib-cash/lib/privatekey.js"],"names":["_","require","Address","Base58Check","BN","JSUtil","Networks","Point","PublicKey","Random","$","PrivateKey","data","network","info","_classifyArguments","bn","cmp","TypeError","lt","getN","defineImmutable","compressed","Object","defineProperty","configurable","enumerable","get","toPublicKey","bind","prototype","defaultNetwork","isUndefined","isNull","_getRandomBN","Buffer","Uint8Array","_transformBuffer","_transformObject","isHexa","from","_transformWIF","condition","privbuf","getRandomBuffer","fromBuffer","buf","length","_transformBNBuffer","Error","slice","str","decode","arg","json","fromString","fromWIF","checkArgument","isString","fromObject","obj","isObject","fromRandom","getValidationError","error","e","isValid","toString","toBuffer","toWIF","concat","privatekey","size","encode","toBigNumber","toBufferNoPadding","_pubkey","fromPrivateKey","toAddress","pubkey","fromPublicKey","toObject","toJSON","inspect","uncompressed","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,wBAAD,CAAzB;;AACA,IAAIG,EAAE,GAAGH,OAAO,CAAC,aAAD,CAAhB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIM,KAAK,GAAGN,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIO,SAAS,GAAGP,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIQ,MAAM,GAAGR,OAAO,CAAC,iBAAD,CAApB;;AACA,IAAIS,CAAC,GAAGT,OAAO,CAAC,sBAAD,CAAf;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAASU,UAAT,CAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AACjC;;AACA;AAEA,MAAI,EAAE,gBAAgBF,UAAlB,CAAJ,EAAmC;AACjC,WAAO,IAAIA,UAAJ,CAAeC,IAAf,EAAqBC,OAArB,CAAP;AACD;;AACD,MAAID,IAAI,YAAYD,UAApB,EAAgC;AAC9B,WAAOC,IAAP;AACD;;AAED,MAAIE,IAAI,GAAG,KAAKC,kBAAL,CAAwBH,IAAxB,EAA8BC,OAA9B,CAAX,CAXiC,CAajC;;;AACA,MAAI,CAACC,IAAI,CAACE,EAAN,IAAYF,IAAI,CAACE,EAAL,CAAQC,GAAR,CAAY,IAAIb,EAAJ,CAAO,CAAP,CAAZ,MAA2B,CAA3C,EAA6C;AAC3C,UAAM,IAAIc,SAAJ,CAAc,2DAAd,CAAN;AACD;;AACD,MAAI,CAACJ,IAAI,CAACE,EAAL,CAAQG,EAAR,CAAWZ,KAAK,CAACa,IAAN,EAAX,CAAL,EAA+B;AAC7B,UAAM,IAAIF,SAAJ,CAAc,4BAAd,CAAN;AACD;;AACD,MAAI,OAAOJ,IAAI,CAACD,OAAZ,KAAyB,WAA7B,EAA0C;AACxC,UAAM,IAAIK,SAAJ,CAAc,mDAAd,CAAN;AACD;;AAEDb,EAAAA,MAAM,CAACgB,eAAP,CAAuB,IAAvB,EAA6B;AAC3BL,IAAAA,EAAE,EAAEF,IAAI,CAACE,EADkB;AAE3BM,IAAAA,UAAU,EAAER,IAAI,CAACQ,UAFU;AAG3BT,IAAAA,OAAO,EAAEC,IAAI,CAACD;AAHa,GAA7B;AAMAU,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACvCC,IAAAA,YAAY,EAAE,KADyB;AAEvCC,IAAAA,UAAU,EAAE,IAF2B;AAGvCC,IAAAA,GAAG,EAAE,KAAKC,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB;AAHkC,GAAzC;AAMA,SAAO,IAAP;AAED;;AAAA;AAED;;;;;;;;;AAQAlB,UAAU,CAACmB,SAAX,CAAqBf,kBAArB,GAA0C,UAASH,IAAT,EAAeC,OAAf,EAAwB;AAChE;AACA,MAAIC,IAAI,GAAG;AACTQ,IAAAA,UAAU,EAAE,IADH;AAETT,IAAAA,OAAO,EAAEA,OAAO,GAAGP,QAAQ,CAACqB,GAAT,CAAad,OAAb,CAAH,GAA2BP,QAAQ,CAACyB;AAF3C,GAAX,CAFgE,CAOhE;;AACA,MAAI/B,CAAC,CAACgC,WAAF,CAAcpB,IAAd,KAAuBZ,CAAC,CAACiC,MAAF,CAASrB,IAAT,CAA3B,EAA0C;AACxCE,IAAAA,IAAI,CAACE,EAAL,GAAUL,UAAU,CAACuB,YAAX,EAAV;AACD,GAFD,MAEO,IAAItB,IAAI,YAAYR,EAApB,EAAwB;AAC7BU,IAAAA,IAAI,CAACE,EAAL,GAAUJ,IAAV;AACD,GAFM,MAEA,IAAIA,IAAI,YAAYuB,MAAhB,IAA0BvB,IAAI,YAAYwB,UAA9C,EAA0D;AAC/DtB,IAAAA,IAAI,GAAGH,UAAU,CAAC0B,gBAAX,CAA4BzB,IAA5B,EAAkCC,OAAlC,CAAP;AACD,GAFM,MAEA,IAAID,IAAI,CAACI,EAAL,IAAWJ,IAAI,CAACC,OAApB,EAA4B;AACjCC,IAAAA,IAAI,GAAGH,UAAU,CAAC2B,gBAAX,CAA4B1B,IAA5B,CAAP;AACD,GAFM,MAEA,IAAI,CAACC,OAAD,IAAYP,QAAQ,CAACqB,GAAT,CAAaf,IAAb,CAAhB,EAAoC;AACzCE,IAAAA,IAAI,CAACE,EAAL,GAAUL,UAAU,CAACuB,YAAX,EAAV;AACApB,IAAAA,IAAI,CAACD,OAAL,GAAeP,QAAQ,CAACqB,GAAT,CAAaf,IAAb,CAAf;AACD,GAHM,MAGA,IAAI,OAAOA,IAAP,KAAiB,QAArB,EAA8B;AACnC,QAAIP,MAAM,CAACkC,MAAP,CAAc3B,IAAd,CAAJ,EAAyB;AACvBE,MAAAA,IAAI,CAACE,EAAL,GAAU,IAAIZ,EAAJ,CAAO+B,MAAM,CAACK,IAAP,CAAY5B,IAAZ,EAAkB,KAAlB,CAAP,CAAV;AACD,KAFD,MAEO;AACLE,MAAAA,IAAI,GAAGH,UAAU,CAAC8B,aAAX,CAAyB7B,IAAzB,EAA+BC,OAA/B,CAAP;AACD;AACF,GANM,MAMA;AACL,UAAM,IAAIK,SAAJ,CAAc,8CAAd,CAAN;AACD;;AACD,SAAOJ,IAAP;AACD,CA7BD;AA+BA;;;;;;;;AAMAH,UAAU,CAACuB,YAAX,GAA0B,YAAU;AAClC,MAAIQ,SAAJ;AACA,MAAI1B,EAAJ;;AACA,KAAG;AACD,QAAI2B,OAAO,GAAGlC,MAAM,CAACmC,eAAP,CAAuB,EAAvB,CAAd;AACA5B,IAAAA,EAAE,GAAGZ,EAAE,CAACyC,UAAH,CAAcF,OAAd,CAAL;AACAD,IAAAA,SAAS,GAAG1B,EAAE,CAACG,EAAH,CAAMZ,KAAK,CAACa,IAAN,EAAN,CAAZ;AACD,GAJD,QAIS,CAACsB,SAJV;;AAKA,SAAO1B,EAAP;AACD,CATD;AAWA;;;;;;;;;;AAQAL,UAAU,CAAC0B,gBAAX,GAA8B,UAASS,GAAT,EAAcjC,OAAd,EAAuB;AAEnD,MAAIC,IAAI,GAAG,EAAX;;AAEA,MAAIgC,GAAG,CAACC,MAAJ,KAAe,EAAnB,EAAuB;AACrB,WAAOpC,UAAU,CAACqC,kBAAX,CAA8BF,GAA9B,EAAmCjC,OAAnC,CAAP;AACD;;AAEDC,EAAAA,IAAI,CAACD,OAAL,GAAeP,QAAQ,CAACqB,GAAT,CAAamB,GAAG,CAAC,CAAD,CAAhB,EAAqB,YAArB,CAAf;;AAEA,MAAI,CAAChC,IAAI,CAACD,OAAV,EAAmB;AACjB,UAAM,IAAIoC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,MAAIpC,OAAO,IAAIC,IAAI,CAACD,OAAL,KAAiBP,QAAQ,CAACqB,GAAT,CAAad,OAAb,CAAhC,EAAuD;AACrD,UAAM,IAAIK,SAAJ,CAAc,8BAAd,CAAN;AACD;;AAED,MAAI4B,GAAG,CAACC,MAAJ,KAAe,IAAI,EAAJ,GAAS,CAAxB,IAA6BD,GAAG,CAAC,IAAI,EAAJ,GAAS,CAAT,GAAa,CAAd,CAAH,KAAwB,CAAzD,EAA4D;AAC1DhC,IAAAA,IAAI,CAACQ,UAAL,GAAkB,IAAlB;AACD,GAFD,MAEO,IAAIwB,GAAG,CAACC,MAAJ,KAAe,IAAI,EAAvB,EAA2B;AAChCjC,IAAAA,IAAI,CAACQ,UAAL,GAAkB,KAAlB;AACD,GAFM,MAEA;AACL,UAAM,IAAI2B,KAAJ,CAAU,+DAAV,CAAN;AACD;;AAEDnC,EAAAA,IAAI,CAACE,EAAL,GAAUZ,EAAE,CAACyC,UAAH,CAAcC,GAAG,CAACI,KAAJ,CAAU,CAAV,EAAa,KAAK,CAAlB,CAAd,CAAV;AAEA,SAAOpC,IAAP;AACD,CA7BD;AA+BA;;;;;;;;;;AAQAH,UAAU,CAACqC,kBAAX,GAAgC,UAASF,GAAT,EAAcjC,OAAd,EAAuB;AACrD,MAAIC,IAAI,GAAG,EAAX;AACAA,EAAAA,IAAI,CAACD,OAAL,GAAeP,QAAQ,CAACqB,GAAT,CAAad,OAAb,KAAyBP,QAAQ,CAACyB,cAAjD;AACAjB,EAAAA,IAAI,CAACE,EAAL,GAAUZ,EAAE,CAACyC,UAAH,CAAcC,GAAd,CAAV;AACAhC,EAAAA,IAAI,CAACQ,UAAL,GAAkB,KAAlB;AACA,SAAOR,IAAP;AACD,CAND;AAQA;;;;;;;;;AAOAH,UAAU,CAAC8B,aAAX,GAA2B,UAASU,GAAT,EAActC,OAAd,EAAuB;AAChD,SAAOF,UAAU,CAAC0B,gBAAX,CAA4BlC,WAAW,CAACiD,MAAZ,CAAmBD,GAAnB,CAA5B,EAAqDtC,OAArD,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOAF,UAAU,CAACkC,UAAX,GAAwB,UAASQ,GAAT,EAAcxC,OAAd,EAAuB;AAC7C,SAAO,IAAIF,UAAJ,CAAe0C,GAAf,EAAoBxC,OAApB,CAAP;AACD,CAFD;AAIA;;;;;;;;;;AAQAF,UAAU,CAAC2B,gBAAX,GAA8B,UAASgB,IAAT,EAAe;AAC3C,MAAItC,EAAE,GAAG,IAAIZ,EAAJ,CAAOkD,IAAI,CAACtC,EAAZ,EAAgB,KAAhB,CAAT;AACA,MAAIH,OAAO,GAAGP,QAAQ,CAACqB,GAAT,CAAa2B,IAAI,CAACzC,OAAlB,CAAd;AACA,SAAO;AACLG,IAAAA,EAAE,EAAEA,EADC;AAELH,IAAAA,OAAO,EAAEA,OAFJ;AAGLS,IAAAA,UAAU,EAAEgC,IAAI,CAAChC;AAHZ,GAAP;AAKD,CARD;AAUA;;;;;;;;AAMAX,UAAU,CAAC4C,UAAX,GAAwB5C,UAAU,CAAC6C,OAAX,GAAqB,UAASL,GAAT,EAAc;AACzDzC,EAAAA,CAAC,CAAC+C,aAAF,CAAgBzD,CAAC,CAAC0D,QAAF,CAAWP,GAAX,CAAhB,EAAiC,4CAAjC;AACA,SAAO,IAAIxC,UAAJ,CAAewC,GAAf,CAAP;AACD,CAHD;AAKA;;;;;;;AAKAxC,UAAU,CAACgD,UAAX,GAAwB,UAASC,GAAT,EAAc;AACpClD,EAAAA,CAAC,CAAC+C,aAAF,CAAgBzD,CAAC,CAAC6D,QAAF,CAAWD,GAAX,CAAhB,EAAiC,6CAAjC;AACA,SAAO,IAAIjD,UAAJ,CAAeiD,GAAf,CAAP;AACD,CAHD;AAKA;;;;;;;;AAMAjD,UAAU,CAACmD,UAAX,GAAwB,UAASjD,OAAT,EAAkB;AACxC,MAAIG,EAAE,GAAGL,UAAU,CAACuB,YAAX,EAAT;;AACA,SAAO,IAAIvB,UAAJ,CAAeK,EAAf,EAAmBH,OAAnB,CAAP;AACD,CAHD;AAKA;;;;;;;;;AAQAF,UAAU,CAACoD,kBAAX,GAAgC,UAASnD,IAAT,EAAeC,OAAf,EAAwB;AACtD,MAAImD,KAAJ;;AACA,MAAI;AACF;AACA,QAAIrD,UAAJ,CAAeC,IAAf,EAAqBC,OAArB;AACD,GAHD,CAGE,OAAOoD,CAAP,EAAU;AACVD,IAAAA,KAAK,GAAGC,CAAR;AACD;;AACD,SAAOD,KAAP;AACD,CATD;AAWA;;;;;;;;;AAOArD,UAAU,CAACuD,OAAX,GAAqB,UAAStD,IAAT,EAAeC,OAAf,EAAuB;AAC1C,MAAI,CAACD,IAAL,EAAW;AACT,WAAO,KAAP;AACD;;AACD,SAAO,CAACD,UAAU,CAACoD,kBAAX,CAA8BnD,IAA9B,EAAoCC,OAApC,CAAR;AACD,CALD;AAOA;;;;;;;AAKAF,UAAU,CAACmB,SAAX,CAAqBqC,QAArB,GAAgC,YAAW;AACzC,SAAO,KAAKC,QAAL,GAAgBD,QAAhB,CAAyB,KAAzB,CAAP;AACD,CAFD;AAIA;;;;;;;AAKAxD,UAAU,CAACmB,SAAX,CAAqBuC,KAArB,GAA6B,YAAW;AACtC,MAAIxD,OAAO,GAAG,KAAKA,OAAnB;AACA,MAAIS,UAAU,GAAG,KAAKA,UAAtB;AAEA,MAAIwB,GAAJ;;AACA,MAAIxB,UAAJ,EAAgB;AACdwB,IAAAA,GAAG,GAAGX,MAAM,CAACmC,MAAP,CAAc,CAACnC,MAAM,CAACK,IAAP,CAAY,CAAC3B,OAAO,CAAC0D,UAAT,CAAZ,CAAD,EACC,KAAKvD,EAAL,CAAQoD,QAAR,CAAiB;AAACI,MAAAA,IAAI,EAAE;AAAP,KAAjB,CADD,EAECrC,MAAM,CAACK,IAAP,CAAY,CAAC,IAAD,CAAZ,CAFD,CAAd,CAAN;AAGD,GAJD,MAIO;AACLM,IAAAA,GAAG,GAAGX,MAAM,CAACmC,MAAP,CAAc,CAACnC,MAAM,CAACK,IAAP,CAAY,CAAC3B,OAAO,CAAC0D,UAAT,CAAZ,CAAD,EACC,KAAKvD,EAAL,CAAQoD,QAAR,CAAiB;AAACI,MAAAA,IAAI,EAAE;AAAP,KAAjB,CADD,CAAd,CAAN;AAED;;AAED,SAAOrE,WAAW,CAACsE,MAAZ,CAAmB3B,GAAnB,CAAP;AACD,CAfD;AAiBA;;;;;;;AAKAnC,UAAU,CAACmB,SAAX,CAAqB4C,WAArB,GAAmC,YAAU;AAC3C,SAAO,KAAK1D,EAAZ;AACD,CAFD;AAIA;;;;;;;AAKAL,UAAU,CAACmB,SAAX,CAAqBsC,QAArB,GAAgC,YAAU;AACxC,SAAO,KAAKpD,EAAL,CAAQoD,QAAR,CAAiB;AAACI,IAAAA,IAAI,EAAE;AAAP,GAAjB,CAAP;AACD,CAFD;AAIA;;;;;;;;;;AAQA7D,UAAU,CAACmB,SAAX,CAAqB6C,iBAArB,GAAyC,YAAW;AAClD,SAAO,KAAK3D,EAAL,CAAQoD,QAAR,EAAP;AACD,CAFD;AAIA;;;;;;;AAKAzD,UAAU,CAACmB,SAAX,CAAqBF,WAArB,GAAmC,YAAU;AAC3C,MAAI,CAAC,KAAKgD,OAAV,EAAmB;AACjB,SAAKA,OAAL,GAAepE,SAAS,CAACqE,cAAV,CAAyB,IAAzB,CAAf;AACD;;AACD,SAAO,KAAKD,OAAZ;AACD,CALD;AAOA;;;;;;;;;AAOAjE,UAAU,CAACmB,SAAX,CAAqBgD,SAArB,GAAiC,UAASjE,OAAT,EAAkB;AACjD,MAAIkE,MAAM,GAAG,KAAKnD,WAAL,EAAb;AACA,SAAO1B,OAAO,CAAC8E,aAAR,CAAsBD,MAAtB,EAA8BlE,OAAO,IAAI,KAAKA,OAA9C,CAAP;AACD,CAHD;AAKA;;;;;AAGAF,UAAU,CAACmB,SAAX,CAAqBmD,QAArB,GAAgCtE,UAAU,CAACmB,SAAX,CAAqBoD,MAArB,GAA8B,SAASD,QAAT,GAAoB;AAChF,SAAO;AACLjE,IAAAA,EAAE,EAAE,KAAKA,EAAL,CAAQmD,QAAR,CAAiB,KAAjB,CADC;AAEL7C,IAAAA,UAAU,EAAE,KAAKA,UAFZ;AAGLT,IAAAA,OAAO,EAAE,KAAKA,OAAL,CAAasD,QAAb;AAHJ,GAAP;AAKD,CAND;AAQA;;;;;;;AAKAxD,UAAU,CAACmB,SAAX,CAAqBqD,OAArB,GAA+B,YAAW;AACxC,MAAIC,YAAY,GAAG,CAAC,KAAK9D,UAAN,GAAmB,gBAAnB,GAAsC,EAAzD;AACA,SAAO,kBAAkB,KAAK6C,QAAL,EAAlB,GAAoC,aAApC,GAAoD,KAAKtD,OAAzD,GAAmEuE,YAAnE,GAAkF,GAAzF;AACD,CAHD;;AAKAC,MAAM,CAACC,OAAP,GAAiB3E,UAAjB","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar Address = require('./address');\nvar Base58Check = require('./encoding/base58check');\nvar BN = require('./crypto/bn');\nvar JSUtil = require('./util/js');\nvar Networks = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\nvar Random = require('./crypto/random');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof(info.network) === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n\n  return this;\n\n};\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)){\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network){\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof(data) === 'string'){\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function(){\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function(buf, network) {\n\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function(buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function(str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function(arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function(json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function(network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\nPrivateKey.getValidationError = function(data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function(data, network){\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function() {\n  var network = this.network;\n  var compressed = this.compressed;\n\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32}),\n                         Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32})]);\n  }\n\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function(){\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function(){\n  return this.bn.toBuffer({size: 32});\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBufferNoPadding = function() {\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function(){\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function(network) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function() {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;\n"]},"metadata":{},"sourceType":"script"}