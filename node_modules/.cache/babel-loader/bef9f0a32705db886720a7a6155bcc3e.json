{"ast":null,"code":"/* eslint-disable */\nconst types = require('./types');\n\nconst typeforce = require('typeforce');\n\nconst varuint = require('varuint-bitcoin'); // https://github.com/feross/buffer/blob/master/index.js#L1127\n\n\nfunction verifuint(value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number');\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component');\n}\n\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\n\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\n\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n\n  return buffer;\n}\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\n\n\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\n\n\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n\n    return vector;\n  }\n\n}\n\nmodule.exports = {\n  readUInt64LE,\n  writeUInt64LE,\n  reverseBuffer,\n  BufferWriter,\n  BufferReader\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/bitgo-utxo-lib/src/bufferutils.js"],"names":["types","require","typeforce","varuint","verifuint","value","max","Error","Math","floor","readUInt64LE","buffer","offset","a","readUInt32LE","b","writeUInt64LE","writeInt32LE","writeUInt32LE","reverseBuffer","length","j","tmp","i","BufferWriter","constructor","tuple","Buffer","UInt32","writeUInt8","writeInt32","writeUInt32","writeUInt64","writeVarInt","encode","bytes","writeSlice","slice","copy","writeVarSlice","writeVector","vector","forEach","buf","BufferReader","readUInt8","result","readInt32","readInt32LE","readUInt32","readUInt64","readVarInt","vi","decode","readSlice","n","readVarSlice","readVector","count","push","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n    if (typeof value !== 'number')\n        throw new Error('cannot write a non-number as a number');\n    if (value < 0)\n        throw new Error('specified a negative value for writing an unsigned value');\n    if (value > max)\n        throw new Error('RangeError: value out of range');\n    if (Math.floor(value) !== value)\n        throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n    const a = buffer.readUInt32LE(offset);\n    let b = buffer.readUInt32LE(offset + 4);\n    b *= 0x100000000;\n    verifuint(b + a, 0x001fffffffffffff);\n    return b + a;\n}\nfunction writeUInt64LE(buffer, value, offset) {\n    verifuint(value, 0x001fffffffffffff);\n    buffer.writeInt32LE(value & -1, offset);\n    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n    return offset + 8;\n}\nfunction reverseBuffer(buffer) {\n    if (buffer.length < 1)\n        return buffer;\n    let j = buffer.length - 1;\n    let tmp = 0;\n    for (let i = 0; i < buffer.length / 2; i++) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        j--;\n    }\n    return buffer;\n}\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n    }\n    writeUInt8(i) {\n        this.offset = this.buffer.writeUInt8(i, this.offset);\n    }\n    writeInt32(i) {\n        this.offset = this.buffer.writeInt32LE(i, this.offset);\n    }\n    writeUInt32(i) {\n        this.offset = this.buffer.writeUInt32LE(i, this.offset);\n    }\n    writeUInt64(i) {\n        this.offset = writeUInt64LE(this.buffer, i, this.offset);\n    }\n    writeVarInt(i) {\n        varuint.encode(i, this.buffer, this.offset);\n        this.offset += varuint.encode.bytes;\n    }\n    writeSlice(slice) {\n        if (this.buffer.length < this.offset + slice.length) {\n            throw new Error('Cannot write slice out of bounds');\n        }\n        this.offset += slice.copy(this.buffer, this.offset);\n    }\n    writeVarSlice(slice) {\n        this.writeVarInt(slice.length);\n        this.writeSlice(slice);\n    }\n    writeVector(vector) {\n        this.writeVarInt(vector.length);\n        vector.forEach((buf) => this.writeVarSlice(buf));\n    }\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n    }\n    readUInt8() {\n        const result = this.buffer.readUInt8(this.offset);\n        this.offset++;\n        return result;\n    }\n    readInt32() {\n        const result = this.buffer.readInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt32() {\n        const result = this.buffer.readUInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt64() {\n        const result = readUInt64LE(this.buffer, this.offset);\n        this.offset += 8;\n        return result;\n    }\n    readVarInt() {\n        const vi = varuint.decode(this.buffer, this.offset);\n        this.offset += varuint.decode.bytes;\n        return vi;\n    }\n    readSlice(n) {\n        if (this.buffer.length < this.offset + n) {\n            throw new Error('Cannot read slice out of bounds');\n        }\n        const result = this.buffer.slice(this.offset, this.offset + n);\n        this.offset += n;\n        return result;\n    }\n    readVarSlice() {\n        return this.readSlice(this.readVarInt());\n    }\n    readVector() {\n        const count = this.readVarInt();\n        const vector = [];\n        for (let i = 0; i < count; i++)\n            vector.push(this.readVarSlice());\n        return vector;\n    }\n}\nmodule.exports = {\n    readUInt64LE,\n    writeUInt64LE,\n    reverseBuffer,\n    BufferWriter,\n    BufferReader,\n};\n"]},"metadata":{},"sourceType":"script"}