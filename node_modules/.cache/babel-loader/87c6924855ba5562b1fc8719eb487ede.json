{"ast":null,"code":"'use strict';\n\nimport queryString from 'query-string'; // uncomment below to run tests\n// import WebSocket from 'promise-ws';\n\nimport 'isomorphic-ws';\nimport debugLogger from 'debug';\nconst debugPeer = debugLogger('MEWconnectVerbose:websocketWrapper');\nconst debug = debugLogger('MEWconnect:websocketWrapper');\nexport default class WebsocketConnection {\n  constructor(options = {}) {\n    this.options = options;\n    this.socket = {};\n    this.listeners = {};\n    this.SOCKET_STATES = {\n      0: 'CONNECTING',\n      1: 'OPEN',\n      2: 'CLOSING',\n      3: 'CLOSED'\n    };\n  }\n  /**\n   * Connect to a given @websocketURL with given @options query params.\n   * The client will connect and bind every on \"message\" event to the\n   * onMessage() function.\n   *\n   * In order to handle a message, the on() member function must be used to add\n   * an listener. This gives functionality similar to socket.io, in which\n   * it is possible to so something like:\n   *\n   * socket.on('error', err => {})\n   * as opposed to:\n   * socket.on('message', message => { if (message.signal === 'error')... })\n   *\n   * @param  {String} websocketURL - WSS address of websocket API\n   * @param  {Object} options - JSON-formatted connection query params\n   * @param  {String} options.role - Either \"initiator\" or \"receiver\" accordingly\n   * @param  {String} options.connId - Last 32 characters of the public key portion of the key-pair\n   *                                  created for the particular paired connection\n   * @param  {String} options.signed - Private key signed with the private key created for the connection\n   */\n\n\n  async connect(websocketUrl, options = {}) {\n    try {\n      const url = `${websocketUrl}?${queryString.stringify(options)}`;\n      debug(url);\n\n      if (typeof jest !== 'undefined' && typeof window === 'undefined') {\n        const WebSocket = require('promise-ws').default;\n\n        this.socket = await WebSocket.create(url);\n        this.socket.on('message', this.onMessage.bind(this));\n      } else {\n        this.socket = new WebSocket(url);\n        this.socket.onmessage = this.onMessage.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        debug(`extensions used: ${this.socket.extensions} or none`);\n        debug(`protocol used: ${this.socket.protocol} or default`);\n        debug(`binary type used: ${this.socket.binaryType} [either blob or arraybuffer]`);\n      }\n    } catch (e) {\n      debug('connect error:', e);\n    }\n  }\n\n  async disconnect() {\n    try {\n      debug('ADD DISCONNECT FUNCTIONALITY');\n      this.socket.close();\n    } catch (e) {\n      debug('disconnect error:', e);\n    }\n  }\n\n  getSocketState() {\n    return this.SOCKET_STATES[this.socket.readyState];\n  }\n\n  onOpen() {\n    debug(`websocket onopen = ${this.getSocketState()}`);\n  }\n  /**\n   * On 'message' event, parse the message and if possible,\n   * call the event listener with the message's particular signal.\n   *\n   * Messages are received as stringified JSON objects, that when parsed,\n   * take the following format:\n   *\n   * {\n   *   signal, // This is the signal that the member function on() can bind to\n   *   data, // The actual data payload\n   *   message // Accompanying server message\n   * }\n   *\n   * @param  {String} message - Stringified JSON payload sent by the server\n   * @return {[type]}         [description]\n   */\n\n\n  onMessage(message) {\n    try {\n      debugPeer('message', message);\n      debugPeer('message data', message.data);\n      let parsedMessage;\n\n      if (typeof jest === 'undefined') {\n        const parsedMessageRaw = typeof message === 'string' ? JSON.parse(message) : message;\n        parsedMessage = typeof parsedMessageRaw.data === 'string' ? JSON.parse(parsedMessageRaw.data) : parsedMessageRaw.data;\n        debugPeer('parsedMessage', parsedMessage);\n      } else {\n        parsedMessage = typeof message === 'string' ? JSON.parse(message) : message;\n        debugPeer('parsedMessage: message', parsedMessage);\n        debugPeer('parsedMessage: message data', parsedMessage.data);\n      }\n\n      const signal = parsedMessage.signal;\n      const data = parsedMessage.data;\n      debug(`onMessage Signal: ${signal}`);\n\n      try {\n        this.listeners[signal].call(this, data);\n      } catch (e) {\n        debug(e); // Unhandled message signal\n      }\n    } catch (e) {\n      debug('ERROR in onMessage', e);\n    }\n  }\n\n  onError(errorEvent) {\n    debug('Websocket ERROR');\n    debug('websocket error event', errorEvent);\n  }\n\n  onClose() {\n    debug(`websocket onClose = ${this.getSocketState()}`);\n  }\n  /**\n   * Bind an function to a particular message signal event.\n   * E.G.\n   * socket.on('error', err => {})\n   *\n   * @param  {String} signal - The signal to listen for\n   * @param  {Function} fn - Function to perform on message signal\n   */\n\n\n  on(signal, fn) {\n    this.listeners[signal] = fn;\n  }\n  /**\n   * Unbind a particular message signal event listener.\n   *\n   * @param  {String} signal - The signal to unbind\n   */\n\n\n  off(signal) {\n    delete this.listeners[signal];\n  }\n  /**\n   * Send a data payload to a particular signal.\n   *\n   * @param  {String} signal - Particular action/signal such as \"offersignal\"\n   * @param  {[type]} data - Data payload\n   */\n\n\n  send(signal, data = {}) {\n    try {\n      debug(`socket connection state: ${this.getSocketState()}`);\n      debug(`send signal: ${signal}`);\n      debug('send data:', data);\n      const message = JSON.stringify({\n        action: signal,\n        data: data\n      });\n      this.socket.send(message);\n    } catch (e) {\n      debug('ERROR in send', e);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/@myetherwallet/mewconnect-web-client/src/connectClient/websocketWrapper.js"],"names":["queryString","debugLogger","debugPeer","debug","WebsocketConnection","constructor","options","socket","listeners","SOCKET_STATES","connect","websocketUrl","url","stringify","jest","window","WebSocket","require","default","create","on","onMessage","bind","onmessage","onerror","onError","onopen","onOpen","onclose","onClose","extensions","protocol","binaryType","e","disconnect","close","getSocketState","readyState","message","data","parsedMessage","parsedMessageRaw","JSON","parse","signal","call","errorEvent","fn","off","send","action"],"mappings":"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","sourcesContent":["'use strict';\n\nimport queryString from 'query-string';\n// uncomment below to run tests\n// import WebSocket from 'promise-ws';\nimport 'isomorphic-ws';\nimport debugLogger from 'debug';\n\nconst debugPeer = debugLogger('MEWconnectVerbose:websocketWrapper');\nconst debug = debugLogger('MEWconnect:websocketWrapper');\n\nexport default class WebsocketConnection {\n  constructor(options = {}) {\n    this.options = options;\n    this.socket = {};\n    this.listeners = {};\n\n    this.SOCKET_STATES = {\n      0: 'CONNECTING',\n      1: 'OPEN',\n      2: 'CLOSING',\n      3: 'CLOSED'\n    };\n  }\n\n  /**\n   * Connect to a given @websocketURL with given @options query params.\n   * The client will connect and bind every on \"message\" event to the\n   * onMessage() function.\n   *\n   * In order to handle a message, the on() member function must be used to add\n   * an listener. This gives functionality similar to socket.io, in which\n   * it is possible to so something like:\n   *\n   * socket.on('error', err => {})\n   * as opposed to:\n   * socket.on('message', message => { if (message.signal === 'error')... })\n   *\n   * @param  {String} websocketURL - WSS address of websocket API\n   * @param  {Object} options - JSON-formatted connection query params\n   * @param  {String} options.role - Either \"initiator\" or \"receiver\" accordingly\n   * @param  {String} options.connId - Last 32 characters of the public key portion of the key-pair\n   *                                  created for the particular paired connection\n   * @param  {String} options.signed - Private key signed with the private key created for the connection\n   */\n  async connect(websocketUrl, options = {}) {\n    try {\n      const url = `${websocketUrl}?${queryString.stringify(options)}`;\n      debug(url);\n      if (typeof jest !== 'undefined' && typeof window === 'undefined') {\n        const WebSocket = require('promise-ws').default;\n        this.socket = await WebSocket.create(url);\n        this.socket.on('message', this.onMessage.bind(this));\n      } else {\n        this.socket = new WebSocket(url);\n        this.socket.onmessage = this.onMessage.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n\n        debug(`extensions used: ${this.socket.extensions} or none`);\n        debug(`protocol used: ${this.socket.protocol} or default`);\n        debug(\n          `binary type used: ${this.socket.binaryType} [either blob or arraybuffer]`\n        );\n      }\n    } catch (e) {\n      debug('connect error:', e);\n    }\n  }\n\n  async disconnect() {\n    try {\n      debug('ADD DISCONNECT FUNCTIONALITY');\n      this.socket.close();\n    } catch (e) {\n      debug('disconnect error:', e);\n    }\n  }\n\n  getSocketState() {\n    return this.SOCKET_STATES[this.socket.readyState];\n  }\n\n  onOpen() {\n    debug(`websocket onopen = ${this.getSocketState()}`);\n  }\n\n  /**\n   * On 'message' event, parse the message and if possible,\n   * call the event listener with the message's particular signal.\n   *\n   * Messages are received as stringified JSON objects, that when parsed,\n   * take the following format:\n   *\n   * {\n   *   signal, // This is the signal that the member function on() can bind to\n   *   data, // The actual data payload\n   *   message // Accompanying server message\n   * }\n   *\n   * @param  {String} message - Stringified JSON payload sent by the server\n   * @return {[type]}         [description]\n   */\n  onMessage(message) {\n    try {\n      debugPeer('message', message);\n      debugPeer('message data', message.data);\n      let parsedMessage;\n      if (typeof jest === 'undefined') {\n        const parsedMessageRaw =\n          typeof message === 'string' ? JSON.parse(message) : message;\n        parsedMessage =\n          typeof parsedMessageRaw.data === 'string'\n            ? JSON.parse(parsedMessageRaw.data)\n            : parsedMessageRaw.data;\n        debugPeer('parsedMessage', parsedMessage);\n      } else {\n        parsedMessage =\n          typeof message === 'string' ? JSON.parse(message) : message;\n        debugPeer('parsedMessage: message', parsedMessage);\n        debugPeer('parsedMessage: message data', parsedMessage.data);\n      }\n\n      const signal = parsedMessage.signal;\n      const data = parsedMessage.data;\n      debug(`onMessage Signal: ${signal}`);\n      try {\n        this.listeners[signal].call(this, data);\n      } catch (e) {\n        debug(e);\n        // Unhandled message signal\n      }\n    } catch (e) {\n      debug('ERROR in onMessage', e);\n    }\n  }\n\n  onError(errorEvent) {\n    debug('Websocket ERROR');\n    debug('websocket error event', errorEvent);\n  }\n\n  onClose() {\n    debug(`websocket onClose = ${this.getSocketState()}`);\n  }\n\n  /**\n   * Bind an function to a particular message signal event.\n   * E.G.\n   * socket.on('error', err => {})\n   *\n   * @param  {String} signal - The signal to listen for\n   * @param  {Function} fn - Function to perform on message signal\n   */\n  on(signal, fn) {\n    this.listeners[signal] = fn;\n  }\n\n  /**\n   * Unbind a particular message signal event listener.\n   *\n   * @param  {String} signal - The signal to unbind\n   */\n  off(signal) {\n    delete this.listeners[signal];\n  }\n\n  /**\n   * Send a data payload to a particular signal.\n   *\n   * @param  {String} signal - Particular action/signal such as \"offersignal\"\n   * @param  {[type]} data - Data payload\n   */\n  send(signal, data = {}) {\n    try {\n      debug(`socket connection state: ${this.getSocketState()}`);\n      debug(`send signal: ${signal}`);\n      debug('send data:', data);\n      const message = JSON.stringify({\n        action: signal,\n        data: data\n      });\n      this.socket.send(message);\n    } catch (e) {\n      debug('ERROR in send', e);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}