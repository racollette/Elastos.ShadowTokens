{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar base58check = require('bs58check');\n\nvar bcrypto = require('./crypto');\n\nvar createHmac = require('create-hmac');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ECPair = require('./ecpair');\n\nvar ecurve = require('ecurve');\n\nvar curve = ecurve.getCurveByName('secp256k1');\n\nvar fastcurve = require('./fastcurve');\n\nfunction HDNode(keyPair, chainCode) {\n  typeforce(types.tuple('ECPair', types.Buffer256bit), arguments);\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs');\n  this.keyPair = keyPair;\n  this.chainCode = chainCode;\n  this.depth = 0;\n  this.index = 0;\n  this.parentFingerprint = 0x00000000;\n  this.derivationCache = {};\n}\n\nHDNode.HIGHEST_BIT = 0x80000000;\nHDNode.LENGTH = 78;\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32); // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n\n  var pIL = BigInteger.fromBuffer(IL);\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  });\n  return new HDNode(keyPair, IR);\n};\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string);\n  if (buffer.length !== 78) throw new Error('Invalid buffer length'); // 4 bytes: version bytes\n\n  var version = buffer.readUInt32BE(0);\n  var network; // list of networks?\n\n  if (Array.isArray(networks)) {\n    // FIXME(BG-16845):\n    // This is only useful when you know the coin but you are not sure if it is mainnet or testnet.\n    // All mainnets have xpub/xprv and all testnets have tpub/tprv as version.\n    network = networks.filter(function (x) {\n      return version === x.bip32.private || version === x.bip32.public;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin;\n  }\n\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new Error('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  var parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new Error('Invalid index'); // 32 bytes: the chain code\n\n  var chainCode = buffer.slice(13, 45);\n  var keyPair; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key');\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78));\n    keyPair = new ECPair(d, null, {\n      network: network\n    }); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78)); // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n\n    curve.validate(Q);\n    keyPair = new ECPair(null, Q, {\n      network: network\n    });\n  }\n\n  var hd = new HDNode(keyPair, chainCode);\n  hd.depth = depth;\n  hd.index = index;\n  hd.parentFingerprint = parentFingerprint;\n  return hd;\n};\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress();\n};\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());\n};\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4);\n};\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork();\n};\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer();\n};\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  });\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode);\n  neutered.depth = this.depth;\n  neutered.index = this.index;\n  neutered.parentFingerprint = this.parentFingerprint;\n  return neutered;\n};\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash);\n};\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature);\n};\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0'); // Version\n\n  var network = this.keyPair.network;\n  var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n  var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n  buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n  buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n  this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45);\n    this.keyPair.d.toBuffer(32).copy(buffer, 46); // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45);\n  }\n\n  return base58check.encode(buffer);\n}; // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index);\n  var isHardened = index >= HDNode.HIGHEST_BIT;\n  var data = Buffer.allocUnsafe(37); // Hardened child\n\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data[0] = 0x00;\n    this.keyPair.d.toBuffer(32).copy(data, 1);\n    data.writeUInt32BE(index, 33); // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0);\n    data.writeUInt32BE(index, 33);\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var pIL = BigInteger.fromBuffer(IL); // In case parse256(IL) >= n, proceed with the next value for i\n\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1);\n  } // Private parent key -> private child key\n\n\n  var derivedKeyPair;\n\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n); // In case ki == 0, proceed with the next value for i\n\n    if (ki.signum() === 0) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    }); // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var point = fastcurve.publicKeyCreate(IL, false);\n    var Ki = point !== undefined ? ecurve.Point.decodeFrom(curve, point).add(this.keyPair.Q) : curve.G.multiply(pIL).add(this.keyPair.Q); // In case Ki is the point at infinity, proceed with the next value for i\n\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    });\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR);\n  hd.depth = this.depth + 1;\n  hd.index = index;\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);\n  return hd;\n};\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index); // Only derives hardened private keys by default\n\n  return this.derive(index + HDNode.HIGHEST_BIT);\n}; // Private === not neutered\n// Public === neutered\n\n\nHDNode.prototype.isNeutered = function () {\n  return !this.keyPair.d;\n};\n\nHDNode.prototype.derivePath = function (path, cache) {\n  typeforce(types.BIP32Path, path);\n  typeforce(types.maybe(types.Object), cache);\n  cache = cache || this.derivationCache;\n  var splitPath = path.split('/');\n\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node');\n    }\n\n    splitPath = splitPath.slice(1);\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index;\n    var cacheObject = cache[indexStr] || {};\n\n    if (cacheObject.node) {\n      cache = cacheObject.next;\n      return cacheObject.node;\n    }\n\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10);\n      cacheObject.node = prevHd.deriveHardened(index);\n    } else {\n      index = parseInt(indexStr, 10);\n      cacheObject.node = prevHd.derive(index);\n    }\n\n    cache[indexStr] = cacheObject;\n    cacheObject.next = {};\n    cache = cacheObject.next;\n    return cacheObject.node;\n  }, this);\n};\n/**\n * Create a new ECPair object from this HDNode's ECPair.\n *\n * Uses secp256k1 if available for accelerated computation of the cloned public key.\n * @return {ECPair}\n */\n\n\nHDNode.prototype.cloneKeypair = function () {\n  var k = this.keyPair;\n  var result = new ECPair(k.d, k.d ? null : k.Q, {\n    network: k.network,\n    compressed: k.compressed\n  }); // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute\n  // if Q is not set here, it will be lazily computed via the slow path\n\n  if (!result.__Q) {\n    var point = fastcurve.publicKeyCreate(k.d.toBuffer(32), false);\n\n    if (point !== undefined) {\n      result.__Q = ecurve.Point.decodeFrom(curve, point);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = HDNode;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitgo-utxo-lib/src/hdnode.js"],"names":["Buffer","require","base58check","bcrypto","createHmac","typeforce","types","NETWORKS","BigInteger","ECPair","ecurve","curve","getCurveByName","fastcurve","HDNode","keyPair","chainCode","tuple","Buffer256bit","arguments","compressed","TypeError","depth","index","parentFingerprint","derivationCache","HIGHEST_BIT","LENGTH","MASTER_SECRET","from","fromSeedBuffer","seed","network","maybe","Network","length","I","update","digest","IL","slice","IR","pIL","fromBuffer","fromSeedHex","hex","fromBase58","string","networks","buffer","decode","Error","version","readUInt32BE","Array","isArray","filter","x","bip32","private","public","pop","bitcoin","readUInt8","d","Q","Point","decodeFrom","validate","hd","prototype","getAddress","getIdentifier","hash160","getPublicKeyBuffer","getFingerprint","getNetwork","neutered","neuteredKeyPair","sign","hash","verify","signature","toBase58","__isPrivate","undefined","isNeutered","allocUnsafe","writeUInt32BE","writeUInt8","copy","toBuffer","encode","derive","UInt32","isHardened","data","compareTo","n","derivedKeyPair","ki","add","mod","signum","point","publicKeyCreate","Ki","G","multiply","isInfinity","deriveHardened","UInt31","derivePath","path","cache","BIP32Path","Object","splitPath","split","reduce","prevHd","indexStr","cacheObject","node","next","parseInt","cloneKeypair","k","result","__Q","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar base58check = require('bs58check')\nvar bcrypto = require('./crypto')\nvar createHmac = require('create-hmac')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar NETWORKS = require('./networks')\n\nvar BigInteger = require('bigi')\nvar ECPair = require('./ecpair')\n\nvar ecurve = require('ecurve')\nvar curve = ecurve.getCurveByName('secp256k1')\n\nvar fastcurve = require('./fastcurve')\n\nfunction HDNode (keyPair, chainCode) {\n  typeforce(types.tuple('ECPair', types.Buffer256bit), arguments)\n\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs')\n\n  this.keyPair = keyPair\n  this.chainCode = chainCode\n  this.depth = 0\n  this.index = 0\n  this.parentFingerprint = 0x00000000\n  this.derivationCache = {}\n}\n\nHDNode.HIGHEST_BIT = 0x80000000\nHDNode.LENGTH = 78\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments)\n\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits')\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits')\n\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n  var pIL = BigInteger.fromBuffer(IL)\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  })\n\n  return new HDNode(keyPair, IR)\n}\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network)\n}\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string)\n  if (buffer.length !== 78) throw new Error('Invalid buffer length')\n\n  // 4 bytes: version bytes\n  var version = buffer.readUInt32BE(0)\n  var network\n\n  // list of networks?\n  if (Array.isArray(networks)) {\n    // FIXME(BG-16845):\n    // This is only useful when you know the coin but you are not sure if it is mainnet or testnet.\n    // All mainnets have xpub/xprv and all testnets have tpub/tprv as version.\n    network = networks.filter(function (x) {\n      return version === x.bip32.private ||\n             version === x.bip32.public\n    }).pop()\n\n    if (!network) throw new Error('Unknown network version')\n\n  // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin\n  }\n\n  if (version !== network.bip32.private &&\n    version !== network.bip32.public) throw new Error('Invalid network version')\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  var depth = buffer[4]\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  var parentFingerprint = buffer.readUInt32BE(5)\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint')\n  }\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  var index = buffer.readUInt32BE(9)\n  if (depth === 0 && index !== 0) throw new Error('Invalid index')\n\n  // 32 bytes: the chain code\n  var chainCode = buffer.slice(13, 45)\n  var keyPair\n\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key')\n\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78))\n    keyPair = new ECPair(d, null, { network: network })\n\n  // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78))\n    // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n    curve.validate(Q)\n\n    keyPair = new ECPair(null, Q, { network: network })\n  }\n\n  var hd = new HDNode(keyPair, chainCode)\n  hd.depth = depth\n  hd.index = index\n  hd.parentFingerprint = parentFingerprint\n\n  return hd\n}\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress()\n}\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer())\n}\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4)\n}\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork()\n}\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer()\n}\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  })\n\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode)\n  neutered.depth = this.depth\n  neutered.index = this.index\n  neutered.parentFingerprint = this.parentFingerprint\n\n  return neutered\n}\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash)\n}\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature)\n}\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0')\n\n  // Version\n  var network = this.keyPair.network\n  var version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public\n  var buffer = Buffer.allocUnsafe(78)\n\n  // 4 bytes: version bytes\n  buffer.writeUInt32BE(version, 0)\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n  buffer.writeUInt8(this.depth, 4)\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  buffer.writeUInt32BE(this.parentFingerprint, 5)\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n  buffer.writeUInt32BE(this.index, 9)\n\n  // 32 bytes: the chain code\n  this.chainCode.copy(buffer, 13)\n\n  // 33 bytes: the public key or private key data\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45)\n    this.keyPair.d.toBuffer(32).copy(buffer, 46)\n\n  // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45)\n  }\n\n  return base58check.encode(buffer)\n}\n\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index)\n\n  var isHardened = index >= HDNode.HIGHEST_BIT\n  var data = Buffer.allocUnsafe(37)\n\n  // Hardened child\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key')\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00\n    this.keyPair.d.toBuffer(32).copy(data, 1)\n    data.writeUInt32BE(index, 33)\n\n  // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0)\n    data.writeUInt32BE(index, 33)\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var pIL = BigInteger.fromBuffer(IL)\n\n  // In case parse256(IL) >= n, proceed with the next value for i\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1)\n  }\n\n  // Private parent key -> private child key\n  var derivedKeyPair\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n)\n\n    // In case ki == 0, proceed with the next value for i\n    if (ki.signum() === 0) {\n      return this.derive(index + 1)\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    })\n\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var point = fastcurve.publicKeyCreate(IL, false)\n    var Ki = point !== undefined\n      ? ecurve.Point.decodeFrom(curve, point).add(this.keyPair.Q)\n      : curve.G.multiply(pIL).add(this.keyPair.Q)\n\n    // In case Ki is the point at infinity, proceed with the next value for i\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1)\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    })\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR)\n  hd.depth = this.depth + 1\n  hd.index = index\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0)\n\n  return hd\n}\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index)\n\n  // Only derives hardened private keys by default\n  return this.derive(index + HDNode.HIGHEST_BIT)\n}\n\n// Private === not neutered\n// Public === neutered\nHDNode.prototype.isNeutered = function () {\n  return !(this.keyPair.d)\n}\n\nHDNode.prototype.derivePath = function (path, cache) {\n  typeforce(types.BIP32Path, path)\n  typeforce(types.maybe(types.Object), cache)\n\n  cache = cache || this.derivationCache\n\n  var splitPath = path.split('/')\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node')\n    }\n\n    splitPath = splitPath.slice(1)\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index\n    var cacheObject = cache[indexStr] || {}\n    if (cacheObject.node) {\n      cache = cacheObject.next\n      return cacheObject.node\n    }\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10)\n      cacheObject.node = prevHd.deriveHardened(index)\n    } else {\n      index = parseInt(indexStr, 10)\n      cacheObject.node = prevHd.derive(index)\n    }\n\n    cache[indexStr] = cacheObject\n    cacheObject.next = {}\n    cache = cacheObject.next\n    return cacheObject.node\n  }, this)\n}\n\n/**\n * Create a new ECPair object from this HDNode's ECPair.\n *\n * Uses secp256k1 if available for accelerated computation of the cloned public key.\n * @return {ECPair}\n */\nHDNode.prototype.cloneKeypair = function () {\n  var k = this.keyPair\n  var result = new ECPair(k.d, k.d ? null : k.Q, {\n    network: k.network,\n    compressed: k.compressed\n  })\n  // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute\n  // if Q is not set here, it will be lazily computed via the slow path\n  if (!result.__Q) {\n    var point = fastcurve.publicKeyCreate(k.d.toBuffer(32), false)\n    if (point !== undefined) {\n      result.__Q = ecurve.Point.decodeFrom(curve, point)\n    }\n  }\n  return result\n}\n\nmodule.exports = HDNode\n"]},"metadata":{},"sourceType":"script"}