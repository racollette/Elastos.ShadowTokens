{"ast":null,"code":"import React from 'react';\n\nvar warnUser = function warnUser(prop) {\n  console.group('%c @spyna/react-store ', 'background: #fcc; color: #333');\n  console.error('Sorry, you can\\'t modify the [' + prop + '] property this way.');\n  console.groupEnd();\n};\n\nvar storeHandler = {\n  set: function set(obj, prop, value) {\n    warnUser(prop);\n    return true;\n  },\n  deleteProperty: function deleteProperty(target, prop) {\n    warnUser(prop);\n    return true;\n  }\n};\nvar defaultConfig = {\n  listener: function listener() {},\n  proxyStore: true\n};\nvar StoreContext = React.createContext();\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar rawStore = void 0;\n/**\n * @param {ReactElement} WrappedComponent the component to connect with the store\n * @param {Object} initialValue the initial store value or nothing\n * @param {Object} config the custom configuration. If nothing is passed will use the default config\n */\n\nvar createStore = function createStore(WrappedComponent, initialValue) {\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultConfig;\n  var userConfig = Object.freeze(_extends({}, defaultConfig, config));\n  var listener = userConfig.listener,\n      proxyStore = userConfig.proxyStore;\n  return function (_React$Component) {\n    inherits(_class2, _React$Component);\n\n    function _class2(props) {\n      classCallCheck(this, _class2);\n\n      var _this = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, props));\n\n      _this.updateState = function (state) {\n        return new Promise(function (resolve) {\n          _this.setState({\n            storage: state\n          });\n\n          resolve(state);\n          listener(state);\n        });\n      };\n\n      _this.state = {\n        storage: _extends({}, initialValue)\n      };\n      return _this;\n    }\n\n    createClass(_class2, [{\n      key: 'componentWillMount',\n      value: function componentWillMount() {\n        var _this2 = this;\n\n        var store = {\n          get: function get$$1(key, defaultValue) {\n            var value = _this2.state.storage[key];\n\n            if (value === undefined) {\n              value = defaultValue;\n            }\n\n            return value;\n          },\n          set: function set$$1(key, value) {\n            var storage = _this2.state.storage;\n            storage[key] = value;\n            return _this2.updateState(storage);\n          },\n          setAll: function setAll() {\n            for (var _len = arguments.length, arrayOfEntris = Array(_len), _key = 0; _key < _len; _key++) {\n              arrayOfEntris[_key] = arguments[_key];\n            }\n\n            var storage = _this2.state.storage;\n            arrayOfEntris.forEach(function (entry) {\n              var key = entry.key,\n                  value = entry.value;\n              storage[key] = value;\n            });\n            return _this2.updateState(storage);\n          },\n          remove: function remove(key) {\n            var storage = _this2.state.storage;\n            delete storage[key];\n            return _this2.updateState(storage);\n          },\n          getState: function getState() {\n            return Object.assign({}, _this2.state.storage);\n          }\n        };\n\n        if (proxyStore) {\n          store = new Proxy(store, storeHandler);\n        }\n\n        this.setState({\n          store: store\n        });\n        rawStore = store;\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        return React.createElement(StoreContext.Provider, {\n          value: {\n            store: this.state.store\n          }\n        }, React.createElement(WrappedComponent, this.props));\n      }\n    }]);\n    return _class2;\n  }(React.Component);\n};\n/**\n *\n * @param {ReactElement} WrappedComponent the component will be connected with the store\n * @param {Array<String>} keys the keys of the data in the store to set as WrappedComponent props.\n */\n\n\nvar withStore = function withStore(WrappedComponent) {\n  var _class, _temp;\n\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return _temp = _class = function (_React$PureComponent) {\n    inherits(_class, _React$PureComponent);\n\n    function _class() {\n      classCallCheck(this, _class);\n      return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    createClass(_class, [{\n      key: 'render',\n      value: function render() {\n        var _this2 = this;\n\n        return React.createElement(StoreContext.Consumer, null, function (context) {\n          var store = context.store;\n          var storeData = {};\n          keys.forEach(function (key) {\n            storeData[key] = store.get(key);\n          });\n          return React.createElement(WrappedComponent, _extends({\n            store: store\n          }, _this2.props, storeData));\n        });\n      }\n    }]);\n    return _class;\n  }(React.PureComponent), _class.displayName = 'withStore(' + (WrappedComponent.displayName || WrappedComponent.name) + ')', _class.WrappedComponent = WrappedComponent, _temp;\n};\n\nexport { createStore, withStore, rawStore as store };","map":{"version":3,"sources":["../src/storeProxyHandler.js","../src/defaultConfig.js","../src/StoreContext.js","../src/createStore.js","../src/withStore.js"],"names":["warnUser","storeHandler","React","rawStore","createStore","config","defaultConfig","userConfig","Object","listener","proxyStore","storage","store","value","arrayOfEntris","key","entry","withStore","keys","WrappedComponent","context","storeData"],"mappings":"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","sourcesContent":["const warnUser = prop => {\n  console.group('%c @spyna/react-store ', 'background: #fcc; color: #333')\n  console.error(`Sorry, you can't modify the [${prop}] property this way.`)\n  console.groupEnd()\n}\n\nconst storeHandler = {\n  set(obj, prop, value) {\n    warnUser(prop)\n    return true\n  },\n  deleteProperty(target, prop) {\n    warnUser(prop)\n    return true\n  }\n}\nexport { storeHandler }\n","export default {\n  listener: () => {},\n  proxyStore: true\n}\n","import React from 'react'\nexport default React.createContext()\n","import React from 'react'\nimport { storeHandler } from './storeProxyHandler'\nimport defaultConfig from './defaultConfig'\nimport StoreContext from './StoreContext'\n\nlet rawStore\n/**\n * @param {ReactElement} WrappedComponent the component to connect with the store\n * @param {Object} initialValue the initial store value or nothing\n * @param {Object} config the custom configuration. If nothing is passed will use the default config\n */\nconst createStore = (\n  WrappedComponent,\n  initialValue,\n  config = defaultConfig\n) => {\n  const userConfig = Object.freeze({ ...defaultConfig, ...config })\n\n  const { listener, proxyStore } = userConfig\n\n  return class extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = { storage: { ...initialValue } }\n    }\n\n    updateState = state => {\n      return new Promise(resolve => {\n        this.setState({ storage: state })\n        resolve(state)\n        listener(state)\n      })\n    }\n\n    componentWillMount() {\n      let store = {\n        get: (key, defaultValue) => {\n          let value = this.state.storage[key]\n          if (value === undefined) {\n            value = defaultValue\n          }\n          return value\n        },\n        set: (key, value) => {\n          const { storage } = this.state\n          storage[key] = value\n          return this.updateState(storage)\n        },\n        setAll: (...arrayOfEntris) => {\n          const { storage } = this.state\n          arrayOfEntris.forEach(entry => {\n            const { key, value } = entry\n            storage[key] = value\n          })\n          return this.updateState(storage)\n        },\n        remove: key => {\n          const { storage } = this.state\n          delete storage[key]\n          return this.updateState(storage)\n        },\n        getState: () => {\n          return Object.assign({}, this.state.storage)\n        }\n      }\n      if (proxyStore) {\n        store = new Proxy(store, storeHandler)\n      }\n      this.setState({ store })\n      rawStore = store\n    }\n\n    render() {\n      return (\n        <StoreContext.Provider value={{ store: this.state.store }}>\n          <WrappedComponent {...this.props} />\n        </StoreContext.Provider>\n      )\n    }\n  }\n}\n\nexport default createStore\n\nexport { rawStore as store }\n","import React from 'react'\nimport StoreContext from './StoreContext'\n\n/**\n *\n * @param {ReactElement} WrappedComponent the component will be connected with the store\n * @param {Array<String>} keys the keys of the data in the store to set as WrappedComponent props.\n */\nconst withStore = (WrappedComponent, keys = []) => {\n  return class extends React.PureComponent {\n    static displayName = `withStore(${WrappedComponent.displayName ||\n      WrappedComponent.name})`\n    static WrappedComponent = WrappedComponent\n\n    render() {\n      return (\n        <StoreContext.Consumer>\n          {context => {\n            const { store } = context\n            const storeData = {}\n            keys.forEach(key => {\n              storeData[key] = store.get(key)\n            })\n            return (\n              <WrappedComponent store={store} {...this.props} {...storeData} />\n            )\n          }}\n        </StoreContext.Consumer>\n      )\n    }\n  }\n}\n\nexport default withStore\n"]},"metadata":{},"sourceType":"module"}