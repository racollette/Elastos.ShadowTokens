{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\n\nvar Opcode = require('../opcode');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar Signature = require('../crypto/signature');\n\nvar PublicKey = require('../publickey');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar Schnorr = require('../crypto/schnorr');\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\n\n\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} satoshisBN - amount in satoshis of the input to be verified (when FORKID signhash is used)\n *\n * Translated from bitcoind's VerifyScript\n */\n\n\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags, satoshisBN) {\n  var Transaction = require('../transaction');\n\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  } // If FORKID is enabled, we also ensure strict encoding.\n\n\n  if (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {\n    flags |= Interpreter.SCRIPT_VERIFY_STRICTENC; // If FORKID is enabled, we need the input amount.\n\n    if (!satoshisBN) {\n      throw new Error('internal error - need satoshisBN to verify FORKID transactions');\n    }\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags,\n    satoshisBN: satoshisBN\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  } // evaluate scriptSig\n\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags,\n    satoshisBN: satoshisBN\n  }); // evaluate scriptPubkey\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  } // Additional validation for spend-to-script-hash transactions:\n\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    } // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n\n\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags,\n      satoshisBN: satoshisBN\n    }); // evaluate redeemScript\n\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n  } // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n    // Disallow CLEANSTACK without P2SH, as otherwise a switch\n    // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n    // softfork (and P2SH should be one).\n    if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0) {\n      throw new Error('internal error - CLEANSTACK without P2SH');\n    }\n\n    if (stackCopy.length != 1) {\n      this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function (obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.satoshisBN = obj.satoshisBN || this.satoshisBN;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.MAXIMUM_ELEMENT_SIZE = 4;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n\nInterpreter.SCRIPT_VERIFY_NONE = 0; // Evaluate P2SH subscripts (softfork safe, BIP16).\n\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0; // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\n\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1; // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\n\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2; // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\n\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3; // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\n\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4; // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\n\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5; // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\n\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6; // Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7; // Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must // be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\n\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = 1 << 8, // CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9; // support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\n\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10; // Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\n\nInterpreter.SCRIPT_VERIFY_MINIMALIF = 1 << 13; // Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\n\nInterpreter.SCRIPT_VERIFY_NULLFAIL = 1 << 14; // Public keys in scripts must be compressed\n\nInterpreter.SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE = 1 << 15; // Do we accept signature using SIGHASH_FORKID\n//\n\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16; // Do we accept activate replay protection using a different fork id.\n//\n\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 1 << 17; // Enable new opcodes.\n//\n\nInterpreter.SCRIPT_ENABLE_CHECKDATASIG = 1 << 18, // The exception to CLEANSTACK and P2SH for the recovery of coins sent\n// to p2sh segwit addresses is not allowed.\nInterpreter.SCRIPT_DISALLOW_SEGWIT_RECOVERY = 1 << 20; // Whether to allow new OP_CHECKMULTISIG logic to trigger. (new multisig\n// logic verifies faster, and only allows Schnorr signatures)\n\nInterpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG = 1 << 21,\n/* Below flags apply in the context of BIP 68*/\n\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nInterpreter.isSchnorrSig = function (buf) {\n  return (buf.length === 64 || buf.length === 65) && buf[0] !== 0x30;\n};\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\n\n\nInterpreter.prototype.checkRawSignatureEncoding = function (buf) {\n  var sig; //TODO update interpreter.js and necessary functions to match bitcoin-abc interpreter.cpp\n\n  if (Interpreter.isSchnorrSig(buf)) {\n    return true;\n  }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  }\n\n  return true;\n}; // Back compat\n\n\nInterpreter.prototype.checkSignatureEncoding = Interpreter.prototype.checkTxSignatureEncoding = function (buf) {\n  // Empty signature. Not strictly DER encoded, but allowed to provide a\n  // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n  if (buf.length == 0) {\n    return true;\n  }\n\n  if (!this.checkRawSignatureEncoding(buf.slice(0, buf.length - 1))) {\n    return false;\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    var sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n\n    if (!(this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) && sig.nhashtype & Signature.SIGHASH_FORKID) {\n      this.errstr = 'SCRIPT_ERR_ILLEGAL_FORKID';\n      return false;\n    }\n\n    if (this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID && !(sig.nhashtype & Signature.SIGHASH_FORKID)) {\n      this.errstr = 'SCRIPT_ERR_MUST_USE_FORKID';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nInterpreter.prototype.checkDataSignatureEncoding = function (buf) {\n  // Empty signature. Not strictly DER encoded, but allowed to provide a\n  // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n  if (buf.length == 0) {\n    return true;\n  }\n\n  return this.checkRawSignatureEncoding(buf);\n};\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\n\n\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !(PublicKey.isValid(buf) || IsCompressedOrUncompressedPubkey(buf))) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n\nfunction IsCompressedOrUncompressedPubkey(bufPubkey) {\n  switch (bufPubkey.length) {\n    case 33:\n      return bufPubkey[0] === 0x02 || bufPubkey[0] === 0x03;\n\n    case 64:\n      return bufPubkey[0] === 0x04;\n\n    default:\n      return false;\n  }\n}\n/**\n  *\n  * Check the buffer is minimally encoded (see https://github.com/bitcoincashorg/spec/blob/master/may-2018-reenabled-opcodes.md#op_bin2num)\n  *\n  *\n  */\n\n\nInterpreter._isMinimallyEncoded = function (buf, nMaxNumSize) {\n  nMaxNumSize = nMaxNumSize || Interpreter.MAXIMUM_ELEMENT_SIZE;\n\n  if (buf.length > nMaxNumSize) {\n    return false;\n  }\n\n  if (buf.length > 0) {\n    // Check that the number is encoded with the minimum possible number\n    // of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) == 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set it\n      // would conflict with the sign bit. An example of this case is\n      // +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) == 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n/**\n  *\n  * minimally encode the buffer content\n  *\n  * @param {number} nMaxNumSize (max allowed size)\n  */\n\n\nInterpreter._minimallyEncode = function (buf) {\n  if (buf.length == 0) {\n    return buf;\n  } // If the last byte is not 0x00 or 0x80, we are minimally encoded.\n\n\n  var last = buf[buf.length - 1];\n\n  if (last & 0x7f) {\n    return buf;\n  } // If the script is one byte long, then we have a zero, which encodes as an\n  // empty array.\n\n\n  if (buf.length == 1) {\n    return Buffer.from('');\n  } // If the next byte has it sign bit set, then we are minimaly encoded.\n\n\n  if (buf[buf.length - 2] & 0x80) {\n    return buf;\n  } // We are not minimally encoded, we need to figure out how much to trim.\n\n\n  for (var i = buf.length - 1; i > 0; i--) {\n    // We found a non zero byte, time to encode.\n    if (buf[i - 1] != 0) {\n      if (buf[i - 1] & 0x80) {\n        // We found a byte with it sign bit set so we need one more\n        // byte.\n        buf[i++] = last;\n      } else {\n        // the sign bit is clear, we can use it.\n        buf[i - 1] |= last;\n      }\n\n      return buf.slice(0, i);\n    }\n  } // If we the whole thing is zeros, then we have a zero.\n\n\n  return Buffer.from('');\n};\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n\n      if (!fSuccess) {\n        return false;\n      }\n    } // Size limits\n\n\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\n\n\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n\n\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  } // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n\n\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence\n */\n\n\nInterpreter.prototype.checkSequence = function (nSequence) {\n  // Relative lock times are supported by comparing the passed in operand to\n  // the sequence number of the input.\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber; // Fail if the transaction's version number is not set high enough to\n  // trigger BIP 68 rules.\n\n  if (this.tx.version < 2) {\n    return false;\n  } // Sequence numbers with their most significant bit set are not consensus\n  // constrained. Testing that the transaction's sequence number do not have\n  // this bit set prevents using this property to get around a\n  // CHECKSEQUENCEVERIFY check.\n\n\n  if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return false;\n  } // Mask off any bits that do not have consensus-enforced meaning before\n  // doing the integer comparisons\n\n\n  var nLockTimeMask = Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n  var nSequenceMasked = nSequence.and(nLockTimeMask); // There are two kinds of nSequence: lock-by-blockheight and\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n  //\n  // We want to compare apples to apples, so fail the script unless the type\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n  // transaction.\n\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n\n  if (!(txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) || txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the comparison is a\n  // simple numeric one.\n\n\n  if (nSequenceMasked.gt(txToSequenceMasked)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Implemented from bitcoin-abc\n * https://github.com/Bitcoin-ABC/bitcoin-abc/blob/f8cbc0e2b439aa4030430a7b1ecbdafede0dd072/src/script/bitfield.cpp\n * @param {*} dummy\n * @param {*} size\n */\n\n\nfunction DecodeBitfield(dummy, size) {\n  if (size > 32) {\n    this.errstr = \"INVALID_BITFIELD_SIZE\";\n    return {\n      result: false\n    };\n  }\n\n  let bitfieldSize = Math.floor((size + 7) / 8);\n  let dummyBitlength = dummy.length;\n\n  if (dummyBitlength !== bitfieldSize) {\n    this.errstr = \"INVALID_BITFIELD_SIZE\";\n    return {\n      result: false\n    };\n  }\n\n  let bitfield = 0;\n  let dummyAs32Bit = Uint32Array.from(dummy); // let one = new Uint8Array([1]);\n  // let oneAs64Bit = BigUint64Array.from(one);\n\n  for (let i = 0; i < bitfieldSize; i++) {\n    bitfield = bitfield | dummyAs32Bit[i] << 8 * i;\n  }\n\n  let mask = (0x01 << size) - 1;\n\n  if ((bitfield & mask) != bitfield) {\n    this.errstr = \"INVALID_BIT_RANGE\";\n    return {\n      result: false\n    };\n  }\n\n  return {\n    result: true,\n    bitfield: bitfield\n  };\n}\n/**\n * countBits\n * Implemented from https://github.com/Bitcoin-ABC/bitcoin-abc/blob/f8cbc0e2b439aa4030430a7b1ecbdafede0dd072/src/util/bitmanip.h\n * @param {*} v\n */\n\n\nfunction countBits(v) {\n  /**\n    * Computes the number of bits set in each group of 8bits then uses a\n    * multiplication to sum all of them in the 8 most significant bits and\n    * return these.\n    * More detailed explanation can be found at\n    * https://www.playingwithpointers.com/blog/swar.html\n  */\n  v = v - (v >> 1 & 0x55555555);\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333);\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.step = function () {\n  var self = this;\n\n  function stacktop(i) {\n    return self.stack[self.stack.length + i];\n  }\n\n  function isOpcodeDisabled(opcode) {\n    switch (opcode) {\n      case Opcode.OP_INVERT:\n      case Opcode.OP_2MUL:\n      case Opcode.OP_2DIV:\n      case Opcode.OP_MUL:\n      case Opcode.OP_LSHIFT:\n      case Opcode.OP_RSHIFT:\n        // Disabled opcodes.\n        return true;\n\n      case Opcode.OP_DIV:\n      case Opcode.OP_MOD:\n      case Opcode.OP_SPLIT:\n      case Opcode.OP_CAT:\n      case Opcode.OP_AND:\n      case Opcode.OP_OR:\n      case Opcode.OP_XOR:\n      case Opcode.OP_BIN2NUM:\n      case Opcode.OP_NUM2BIN:\n        // Opcodes that have been reenabled and do not need any flag as for Nov 14,2018\n        return false;\n\n      default:\n        break;\n    }\n\n    return false;\n  }\n\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, bufMessage, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess; // Read instruction\n\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  } // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n\n\n  if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n  if (isOpcodeDisabled(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n      //\n      // Control\n      //\n\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n\n\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due tod\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n\n        var nSequence = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n\n\n        if ((nSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = stacktop(-1);\n\n            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n\n              if (buf.length == 1 && buf[0] != 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n\n            fValue = Interpreter.castToBool(buf);\n\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n\n            this.stack.pop();\n          }\n\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n      //\n      // Stack ops\n      //\n\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-3);\n          buf2 = stacktop(-2);\n          var buf3 = stacktop(-1);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-4);\n          buf2 = stacktop(-3);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(stacktop(-1));\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(stacktop(-2));\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-n - 1);\n\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = stacktop(-3);\n          x2 = stacktop(-2);\n          var x3 = stacktop(-1);\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = stacktop(-2);\n          x2 = stacktop(-1);\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 0, stacktop(-1));\n        }\n        break;\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn = new BN(stacktop(-1).length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n      //\n      // Bitwise logic\n      //\n\n      case Opcode.OP_AND:\n      case Opcode.OP_OR:\n      case Opcode.OP_XOR:\n        {\n          // (x1 x2 - out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1); // Inputs must be the same size\n\n          if (buf1.length !== buf2.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_OPERAND_SIZE';\n            return false;\n          } // To avoid allocating, we modify vch1 in place.\n\n\n          switch (opcodenum) {\n            case Opcode.OP_AND:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] &= buf2[i];\n              }\n\n              break;\n\n            case Opcode.OP_OR:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] |= buf2[i];\n              }\n\n              break;\n\n            case Opcode.OP_XOR:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] ^= buf2[i];\n              }\n\n              break;\n\n            default:\n              break;\n          } // And pop vch2.\n\n\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Numeric\n      //\n\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n\n              break;\n\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n            //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_MOD:\n      case Opcode.OP_DIV:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n            case Opcode.OP_DIV:\n              // denominator must not be 0\n              if (bn2 == 0) {\n                this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';\n                return false;\n              }\n\n              bn = bn1.div(bn2);\n              break;\n\n            case Opcode.OP_MOD:\n              // divisor must not be 0\n              if (bn2 == 0) {\n                this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';\n                return false;\n              }\n\n              bn = bn1.mod(bn2);\n              break;\n\n            case Opcode.OP_BOOLAND:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n\n            case Opcode.OP_BOOLOR:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n\n            case Opcode.OP_MIN:\n              bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n              break;\n\n            case Opcode.OP_MAX:\n              bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n              break;\n            // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(stacktop(-1))) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(stacktop(-3), fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal); //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n      //\n      // Crypto\n      //\n\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1); //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n\n          var bufHash;\n\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = stacktop(-2);\n          bufPubkey = stacktop(-1);\n\n          if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signature, since there's no way for a signature to sign itself\n\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n\n            if (!sig.isSchnorr) {\n              fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);\n            } else {\n              fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags, \"schnorr\");\n            }\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKDATASIG:\n      case Opcode.OP_CHECKDATASIGVERIFY:\n        {\n          // (sig message pubkey -- bool)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = stacktop(-3);\n          bufMessage = stacktop(-2);\n          bufPubkey = stacktop(-1);\n\n          if (!this.checkDataSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          fSuccess = false;\n\n          try {\n            sig = Signature.fromDataFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            bufHash = Hash.sha256(bufMessage);\n\n            if (!sig.isSchnorr) {\n              fSuccess = ECDSA.verify(bufHash, sig, pubkey, 'big');\n            } else {\n              fSuccess = Schnorr.verify(bufHash, sig, pubkey, 'big');\n            }\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKDATASIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKDATASIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_REVERSEBYTES:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-1);\n          var reversedBuf = Buffer.from(buf1).reverse();\n          this.stack.pop();\n          this.stack.push(reversedBuf);\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([dummy] [sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n          var i = 1;\n          let idxTopKey = i + 1;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(stacktop(-i), fRequireMinimal).toNumber();\n          var idxSigCount = idxTopKey + nKeysCount;\n\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n\n          this.nOpCount += nKeysCount;\n\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          } // todo map interpreter.cpp variables with interpreter.js variables for future readability, maintainability\n          // ikey maps to idxTopKey in interpreter.cpp (MULTISIG case)\n\n\n          var ikey = ++i; // top pubkey\n\n          var idxTopSig = idxSigCount + 1; // i maps to idxSigCount in interpreter.cpp (MULTISIG case) (stack depth of nSigsCount)\n\n          i += nKeysCount; // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n\n          var ikey2 = nKeysCount + 2; // ?dummy variable\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(stacktop(-idxSigCount), fRequireMinimal).toNumber();\n          var idxDummy = idxTopSig + nSigsCount;\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          } // int isig = ++i;\n\n\n          var isig = ++i;\n          i += nSigsCount;\n\n          if (this.stack.length < idxDummy) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n          fSuccess = true;\n\n          if (this.flags & Interpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG && stacktop(-idxDummy).length !== 0) {\n            // SCHNORR MULTISIG\n            let dummy = stacktop(-idxDummy);\n            let bitfieldObj = DecodeBitfield(dummy, nKeysCount);\n\n            if (!bitfieldObj[\"result\"]) {\n              fSuccess = false;\n            }\n\n            let nSigs8bit = new Uint8Array([nSigsCount]);\n            let nSigs32 = Uint32Array.from(nSigs8bit);\n\n            if (countBits(bitfieldObj[\"bitfield\"]) !== nSigs32[0]) {\n              this.errstr = \"INVALID_BIT_COUNT\";\n              fSuccess = false;\n            }\n\n            var bottomKey = idxTopKey + nKeysCount - 1;\n            var bottomSig = idxTopSig + nSigsCount - 1;\n            let iKey = 0;\n\n            for (let iSig = 0; iSig < nSigsCount; iSig++, iKey++) {\n              if (bitfieldObj[\"bitfield\"] >> iKey === 0) {\n                this.errstr = \"INVALID_BIT_RANGE\";\n                fSuccess = false;\n              }\n\n              while ((bitfieldObj[\"bitfield\"] >> iKey & 0x01) == 0) {\n                if (iKey >= nKeysCount) {\n                  this.errstr = \"wrong\";\n                  fSuccess = false;\n                  break;\n                }\n\n                iKey++;\n              } // this is a sanity check and should be\n              // unreachable\n\n\n              if (iKey >= nKeysCount) {\n                this.errstr = \"PUBKEY_COUNT\";\n                fSuccess = false;\n              } // Check the signature\n\n\n              let bufsig = stacktop(-bottomSig + iSig);\n              let bufPubkey = stacktop(-bottomKey + iKey); // Note that only pubkeys associated with a\n              // signature are check for validity\n\n              if (!this.checkRawSignatureEncoding(bufsig) || !this.checkPubkeyEncoding(bufPubkey)) {\n                fSuccess = false;\n              }\n\n              let sig = Signature.fromTxFormat(bufsig);\n              let pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              let fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags, \"schnorr\");\n\n              if (!fOk) {\n                this.errstr = \"SIG_NULLFAIL\";\n                fSuccess = false;\n              }\n            }\n\n            if (bitfieldObj[\"bitfield\"] >> iKey != 0) {\n              // This is a sanity check and should be\n              // unreachable.\n              this.errstr = \"INVALID_BIT_COUNT\";\n              fSuccess = false;\n            }\n          } else {\n            // Drop the signatures, since there's no way for a signature to sign itself\n            for (var k = 0; k < nSigsCount; k++) {\n              bufSig = stacktop(-isig - k);\n              subscript.findAndDelete(new Script().add(bufSig));\n            }\n\n            while (fSuccess && nSigsCount > 0) {\n              // valtype& vchSig  = stacktop(-isig);\n              bufSig = stacktop(-isig); // valtype& vchPubKey = stacktop(-ikey);\n\n              bufPubkey = stacktop(-ikey);\n\n              if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n                return false;\n              }\n\n              var fOk;\n\n              try {\n                sig = Signature.fromTxFormat(bufSig);\n                pubkey = PublicKey.fromBuffer(bufPubkey, false);\n                fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);\n              } catch (e) {\n                //invalid sig or pubkey\n                fOk = false;\n              }\n\n              if (fOk) {\n                isig++;\n                nSigsCount--;\n              }\n\n              ikey++;\n              nKeysCount--; // If there are more signatures left than keys left,\n              // then too many signatures have failed\n\n              if (nSigsCount > nKeysCount) {\n                fSuccess = false;\n              }\n            }\n          } // Clean up stack of actual arguments\n\n\n          while (i-- > 1) {\n            if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && !ikey2 && stacktop(-1).length) {\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          } // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && stacktop(-1).length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Byte string operations\n      //\n\n      case Opcode.OP_CAT:\n        {\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n\n          if (buf1.length + buf2.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n            this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n            return false;\n          }\n\n          this.stack[this.stack.length - 2] = Buffer.concat([buf1, buf2]);\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_SPLIT:\n        {\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2); // Make sure the split point is apropriate.\n\n          var position = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();\n\n          if (position < 0 || position > buf1.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_SPLIT_RANGE';\n            return false;\n          } // Prepare the results in their own buffer as `data`\n          // will be invalidated.\n          // Copy buffer data, to slice it before\n\n\n          var n1 = Buffer.from(buf1); // Replace existing stack values by the new values.\n\n          this.stack[this.stack.length - 2] = n1.slice(0, position);\n          this.stack[this.stack.length - 1] = n1.slice(position);\n        }\n        break;\n      //\n      // Conversion operations\n      //\n\n      case Opcode.OP_NUM2BIN:\n        {\n          // (in -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var size = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();\n\n          if (size > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n            this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n            return false;\n          }\n\n          this.stack.pop();\n          var rawnum = stacktop(-1); // Try to see if we can fit that number in the number of\n          // byte requested.\n\n          rawnum = Interpreter._minimallyEncode(rawnum);\n\n          if (rawnum.length > size) {\n            // We definitively cannot.\n            this.errstr = 'SCRIPT_ERR_IMPOSSIBLE_ENCODING';\n            return false;\n          } // We already have an element of the right size, we\n          // don't need to do anything.\n\n\n          if (rawnum.length == size) {\n            this.stack[this.stack.length - 1] = rawnum;\n            break;\n          }\n\n          var signbit = 0x00;\n\n          if (rawnum.length > 0) {\n            signbit = rawnum[rawnum.length - 1] & 0x80;\n            rawnum[rawnum.length - 1] &= 0x7f;\n          }\n\n          var num = Buffer.alloc(size);\n          rawnum.copy(num, 0);\n          var l = rawnum.length - 1;\n\n          while (l++ < size - 2) {\n            num[l] = 0x00;\n          }\n\n          num[l] = signbit;\n          this.stack[this.stack.length - 1] = num;\n        }\n        break;\n\n      case Opcode.OP_BIN2NUM:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-1);\n          buf2 = Interpreter._minimallyEncode(buf1);\n          this.stack[this.stack.length - 1] = buf2; // The resulting number must be a valid number.\n\n          if (!Interpreter._isMinimallyEncoded(buf2)) {\n            this.errstr = 'SCRIPT_ERR_INVALID_NUMBER_RANGE';\n            return false;\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib-cash/lib/script/interpreter.js"],"names":["_","require","Script","Opcode","BN","Hash","Signature","PublicKey","ECDSA","Schnorr","Interpreter","obj","initialize","set","prototype","verify","scriptSig","scriptPubkey","tx","nin","flags","satoshisBN","Transaction","isUndefined","SCRIPT_ENABLE_SIGHASH_FORKID","SCRIPT_VERIFY_STRICTENC","Error","script","stackCopy","SCRIPT_VERIFY_SIGPUSHONLY","isPushOnly","errstr","evaluate","SCRIPT_VERIFY_P2SH","stack","slice","length","buf","castToBool","isScriptHashOut","redeemScriptSerialized","redeemScript","fromBuffer","pop","SCRIPT_VERIFY_CLEANSTACK","module","exports","altstack","pc","pbegincodehash","nOpCount","vfExec","altack","true","Buffer","from","false","MAX_SCRIPT_ELEMENT_SIZE","MAXIMUM_ELEMENT_SIZE","LOCKTIME_THRESHOLD","LOCKTIME_THRESHOLD_BN","SCRIPT_VERIFY_NONE","SCRIPT_VERIFY_DERSIG","SCRIPT_VERIFY_LOW_S","SCRIPT_VERIFY_NULLDUMMY","SCRIPT_VERIFY_MINIMALDATA","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS","SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY","SCRIPT_VERIFY_CHECKSEQUENCEVERIFY","SCRIPT_VERIFY_MINIMALIF","SCRIPT_VERIFY_NULLFAIL","SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE","SCRIPT_ENABLE_REPLAY_PROTECTION","SCRIPT_ENABLE_CHECKDATASIG","SCRIPT_DISALLOW_SEGWIT_RECOVERY","SCRIPT_ENABLE_SCHNORR_MULTISIG","SEQUENCE_LOCKTIME_DISABLE_FLAG","SEQUENCE_LOCKTIME_TYPE_FLAG","SEQUENCE_LOCKTIME_MASK","i","isSchnorrSig","checkRawSignatureEncoding","sig","isDER","fromTxFormat","hasLowS","checkSignatureEncoding","checkTxSignatureEncoding","hasDefinedHashtype","nhashtype","SIGHASH_FORKID","checkDataSignatureEncoding","checkPubkeyEncoding","isValid","IsCompressedOrUncompressedPubkey","bufPubkey","_isMinimallyEncoded","nMaxNumSize","_minimallyEncode","last","toBuffer","chunks","fSuccess","step","e","checkLockTime","nLockTime","lt","gte","gt","inputs","isFinal","checkSequence","nSequence","txToSequence","sequenceNumber","version","nLockTimeMask","txToSequenceMasked","nSequenceMasked","and","SEQUENCE_LOCKTIME_TYPE_FLAG_BN","DecodeBitfield","dummy","size","result","bitfieldSize","Math","floor","dummyBitlength","bitfield","dummyAs32Bit","Uint32Array","mask","countBits","v","self","stacktop","isOpcodeDisabled","opcode","OP_INVERT","OP_2MUL","OP_2DIV","OP_MUL","OP_LSHIFT","OP_RSHIFT","OP_DIV","OP_MOD","OP_SPLIT","OP_CAT","OP_AND","OP_OR","OP_XOR","OP_BIN2NUM","OP_NUM2BIN","fRequireMinimal","fExec","indexOf","buf1","buf2","spliced","n","x1","x2","bn","bn1","bn2","bufSig","bufMessage","subscript","pubkey","fValue","chunk","opcodenum","OP_16","OP_PUSHDATA4","checkMinimalPush","push","len","OP_IF","OP_ENDIF","OP_1NEGATE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","toScriptNumBuffer","OP_NOP","OP_NOP2","OP_CHECKLOCKTIMEVERIFY","fromScriptNumBuffer","OP_NOP3","OP_CHECKSEQUENCEVERIFY","OP_NOP1","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_NOTIF","OP_ELSE","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","buf3","OP_2OVER","OP_2ROT","splice","OP_2SWAP","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","toNumber","OP_ROT","x3","OP_SWAP","OP_TUCK","OP_SIZE","OP_EQUAL","OP_EQUALVERIFY","fEqual","toString","OP_1ADD","OP_1SUB","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","add","One","sub","neg","cmp","Zero","OP_ADD","OP_SUB","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","div","mod","OP_WITHIN","bn3","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","bufHash","ripemd160","sha1","sha256","sha256ripemd160","sha256sha256","OP_CODESEPARATOR","OP_CHECKSIG","OP_CHECKSIGVERIFY","tmpScript","findAndDelete","isSchnorr","verifySignature","OP_CHECKDATASIG","OP_CHECKDATASIGVERIFY","fromDataFormat","OP_REVERSEBYTES","reversedBuf","reverse","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","idxTopKey","nKeysCount","idxSigCount","ikey","idxTopSig","ikey2","nSigsCount","idxDummy","isig","bitfieldObj","nSigs8bit","Uint8Array","nSigs32","bottomKey","bottomSig","iKey","iSig","bufsig","fOk","k","concat","position","n1","rawnum","signbit","num","alloc","copy","l"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\nvar Opcode = require('../opcode');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar Signature = require('../crypto/signature');\nvar PublicKey = require('../publickey');\nvar ECDSA = require('../crypto/ecdsa');\nvar Schnorr = require('../crypto/schnorr');\n\n\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} satoshisBN - amount in satoshis of the input to be verified (when FORKID signhash is used)\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, satoshisBN) {\n  var Transaction = require('../transaction');\n\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n\n  // If FORKID is enabled, we also ensure strict encoding.\n  if (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {\n    flags |= Interpreter.SCRIPT_VERIFY_STRICTENC;\n\n    // If FORKID is enabled, we need the input amount.\n    if (!satoshisBN) {\n      throw new Error('internal error - need satoshisBN to verify FORKID transactions');\n    }\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags,\n    satoshisBN: satoshisBN,\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags,\n    satoshisBN: satoshisBN,\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags,\n      satoshisBN: satoshisBN,\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n  }\n\n  // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n  if ((flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n      // Disallow CLEANSTACK without P2SH, as otherwise a switch\n      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n      // softfork (and P2SH should be one).\n      if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0) {\n        throw new Error('internal error - CLEANSTACK without P2SH');\n      }\n\n      if (stackCopy.length != 1) {\n        this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n        return false;\n      }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.satoshisBN = obj.satoshisBN || this.satoshisBN;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\n\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.MAXIMUM_ELEMENT_SIZE = 4;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n\n// Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must // be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),\n\n// CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\n// support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);\n\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\nInterpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);\n\n// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\nInterpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);\n\n// Public keys in scripts must be compressed\nInterpreter.SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE = (1 << 15);\n\n// Do we accept signature using SIGHASH_FORKID\n//\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);\n\n// Do we accept activate replay protection using a different fork id.\n//\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);\n\n// Enable new opcodes.\n//\nInterpreter.SCRIPT_ENABLE_CHECKDATASIG = (1 << 18),\n\n\n// The exception to CLEANSTACK and P2SH for the recovery of coins sent\n// to p2sh segwit addresses is not allowed.\n\nInterpreter.SCRIPT_DISALLOW_SEGWIT_RECOVERY = (1 << 20)\n\n\n// Whether to allow new OP_CHECKMULTISIG logic to trigger. (new multisig\n// logic verifies faster, and only allows Schnorr signatures)\nInterpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG = (1 << 21),\n\n\n/* Below flags apply in the context of BIP 68*/\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\nInterpreter.isSchnorrSig = function(buf) {\n  return (buf.length === 64 || buf.length === 65) && (buf[0] !== 0x30);\n}\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkRawSignatureEncoding = function(buf) {\n  var sig;\n\n  //TODO update interpreter.js and necessary functions to match bitcoin-abc interpreter.cpp\n  if(Interpreter.isSchnorrSig(buf)) {\n    return true;\n  }\n\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\n// Back compat\nInterpreter.prototype.checkSignatureEncoding =\nInterpreter.prototype.checkTxSignatureEncoding = function(buf) {\n\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n    if (buf.length == 0) {\n        return true;\n    }\n\n    if (!this.checkRawSignatureEncoding(buf.slice(0,buf.length-1))) {\n      return false;\n    }\n\n    if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n      var sig = Signature.fromTxFormat(buf);\n      if (!sig.hasDefinedHashtype()) {\n        this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n        return false;\n      }\n      if (!(this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) &&\n        (sig.nhashtype & Signature.SIGHASH_FORKID)) {\n        this.errstr = 'SCRIPT_ERR_ILLEGAL_FORKID';\n        return false;\n      }\n\n      if ( (this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) &&\n        !(sig.nhashtype & Signature.SIGHASH_FORKID)) {\n        this.errstr = 'SCRIPT_ERR_MUST_USE_FORKID';\n        return false;\n      }\n    }\n\n    return true;\n};\n\nInterpreter.prototype.checkDataSignatureEncoding = function(buf) {\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n    if (buf.length == 0) {\n        return true;\n    }\n\n    return this.checkRawSignatureEncoding(buf);\n};\n\n\n\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !(PublicKey.isValid(buf) || IsCompressedOrUncompressedPubkey(buf))) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n  return true;\n};\n\nfunction IsCompressedOrUncompressedPubkey(bufPubkey) {\n  switch(bufPubkey.length) {\n    case 33:\n      return bufPubkey[0] === 0x02 || bufPubkey[0] === 0x03;\n    case 64:\n      return bufPubkey[0] === 0x04;\n    default:\n      return false;\n  }\n}\n\n\n\n/**\n  *\n  * Check the buffer is minimally encoded (see https://github.com/bitcoincashorg/spec/blob/master/may-2018-reenabled-opcodes.md#op_bin2num)\n  *\n  *\n  */\n\nInterpreter._isMinimallyEncoded = function(buf, nMaxNumSize) {\n  nMaxNumSize = nMaxNumSize || Interpreter.MAXIMUM_ELEMENT_SIZE;\n  if (buf.length >  nMaxNumSize ) {\n      return false;\n  }\n\n  if (buf.length > 0) {\n      // Check that the number is encoded with the minimum possible number\n      // of bytes.\n      //\n      // If the most-significant-byte - excluding the sign bit - is zero\n      // then we're not minimal. Note how this test also rejects the\n      // negative-zero encoding, 0x80.\n      if ((buf[buf.length-1] & 0x7f) == 0) {\n          // One exception: if there's more than one byte and the most\n          // significant bit of the second-most-significant-byte is set it\n          // would conflict with the sign bit. An example of this case is\n          // +-255, which encode to 0xff00 and 0xff80 respectively.\n          // (big-endian).\n          if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) == 0) {\n              return false;\n          }\n      }\n  }\n  return true;\n};\n\n/**\n  *\n  * minimally encode the buffer content\n  *\n  * @param {number} nMaxNumSize (max allowed size)\n  */\nInterpreter._minimallyEncode = function(buf) {\n    if (buf.length == 0) {\n        return buf;\n    }\n\n    // If the last byte is not 0x00 or 0x80, we are minimally encoded.\n    var last = buf[buf.length - 1];\n    if (last & 0x7f) {\n        return buf;\n    }\n\n    // If the script is one byte long, then we have a zero, which encodes as an\n    // empty array.\n    if (buf.length == 1) {\n      return Buffer.from('');\n    }\n\n    // If the next byte has it sign bit set, then we are minimaly encoded.\n    if (buf[buf.length - 2] & 0x80) {\n        return buf;\n    }\n\n    // We are not minimally encoded, we need to figure out how much to trim.\n    for (var i = buf.length - 1; i > 0; i--) {\n        // We found a non zero byte, time to encode.\n        if (buf[i - 1] != 0) {\n            if (buf[i - 1] & 0x80) {\n                // We found a byte with it sign bit set so we need one more\n                // byte.\n                buf[i++] = last;\n            } else {\n                // the sign bit is clear, we can use it.\n                buf[i - 1] |= last;\n            }\n\n            return buf.slice(0,i);\n        }\n    }\n\n    // If we the whole thing is zeros, then we have a zero.\n    return Buffer.from('');\n}\n\n\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n\n    // Size limits\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence\n */\nInterpreter.prototype.checkSequence = function(nSequence) {\n\n    // Relative lock times are supported by comparing the passed in operand to\n    // the sequence number of the input.\n    var txToSequence = this.tx.inputs[this.nin].sequenceNumber;\n\n    // Fail if the transaction's version number is not set high enough to\n    // trigger BIP 68 rules.\n    if (this.tx.version < 2) {\n        return false;\n    }\n\n    // Sequence numbers with their most significant bit set are not consensus\n    // constrained. Testing that the transaction's sequence number do not have\n    // this bit set prevents using this property to get around a\n    // CHECKSEQUENCEVERIFY check.\n    if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n        return false;\n    }\n\n    // Mask off any bits that do not have consensus-enforced meaning before\n    // doing the integer comparisons\n    var nLockTimeMask =\n        Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n    var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n    var nSequenceMasked = nSequence.and(nLockTimeMask);\n\n    // There are two kinds of nSequence: lock-by-blockheight and\n    // lock-by-blocktime, distinguished by whether nSequenceMasked <\n    // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n    //\n    // We want to compare apples to apples, so fail the script unless the type\n    // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n    // transaction.\n    var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n\n    if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&\n           nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||\n          (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&\n           nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {\n        return false;\n    }\n\n    // Now that we know we're comparing apples-to-apples, the comparison is a\n    // simple numeric one.\n    if (nSequenceMasked.gt(txToSequenceMasked)) {\n        return false;\n    }\n    return true;\n  }\n\n/**\n * Implemented from bitcoin-abc\n * https://github.com/Bitcoin-ABC/bitcoin-abc/blob/f8cbc0e2b439aa4030430a7b1ecbdafede0dd072/src/script/bitfield.cpp\n * @param {*} dummy\n * @param {*} size\n */\nfunction DecodeBitfield(dummy, size) {\n  if (size > 32) {\n    this.errstr = \"INVALID_BITFIELD_SIZE\";\n    return {result: false};\n  }\n\n  let bitfieldSize = Math.floor((size + 7) / 8);\n  let dummyBitlength = dummy.length;\n  if (dummyBitlength !== bitfieldSize) {\n    this.errstr = \"INVALID_BITFIELD_SIZE\";\n    return {result: false};\n  }\n\n  let bitfield = 0;\n  let dummyAs32Bit = Uint32Array.from(dummy);\n  // let one = new Uint8Array([1]);\n  // let oneAs64Bit = BigUint64Array.from(one);\n\n  for (let i = 0; i < bitfieldSize; i++) {\n    bitfield = bitfield | (dummyAs32Bit[i] << (8*i));\n  }\n\n  let mask = (0x01 << size) - 1\n  if((bitfield & mask) != bitfield) {\n    this.errstr = \"INVALID_BIT_RANGE\";\n    return {result: false};\n  }\n\n  return {result: true, bitfield: bitfield};\n}\n\n/**\n * countBits\n * Implemented from https://github.com/Bitcoin-ABC/bitcoin-abc/blob/f8cbc0e2b439aa4030430a7b1ecbdafede0dd072/src/util/bitmanip.h\n * @param {*} v\n */\n\nfunction countBits(v) {\n  /**\n    * Computes the number of bits set in each group of 8bits then uses a\n    * multiplication to sum all of them in the 8 most significant bits and\n    * return these.\n    * More detailed explanation can be found at\n    * https://www.playingwithpointers.com/blog/swar.html\n  */\n   v = v - (((v) >> 1) & 0x55555555);\n   v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n   return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n}\n\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n  var self = this;\n\n  function stacktop(i) {\n    return self.stack[self.stack.length+i];\n  }\n\n  function isOpcodeDisabled(opcode) {\n    switch (opcode) {\n      case Opcode.OP_INVERT:\n      case Opcode.OP_2MUL:\n      case Opcode.OP_2DIV:\n      case Opcode.OP_MUL:\n      case Opcode.OP_LSHIFT:\n      case Opcode.OP_RSHIFT:\n\n\n\n        // Disabled opcodes.\n        return true;\n\n      case Opcode.OP_DIV:\n      case Opcode.OP_MOD:\n      case Opcode.OP_SPLIT:\n      case Opcode.OP_CAT:\n      case Opcode.OP_AND:\n      case Opcode.OP_OR:\n      case Opcode.OP_XOR:\n      case Opcode.OP_BIN2NUM:\n      case Opcode.OP_NUM2BIN:\n        // Opcodes that have been reenabled and do not need any flag as for Nov 14,2018\n        return false;\n\n      default:\n        break;\n    }\n\n    return false;\n  }\n\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, bufMessage, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n  if (isOpcodeDisabled(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due tod\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n\n        // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n        var nSequence = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, 5);\n\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n        if ((nSequence &\n          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n            buf = stacktop(-1);\n\n            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n              if (buf.length == 1 && buf[0]!=1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n            this.stack.pop();\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = stacktop(-1);\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = stacktop(-3);\n          buf2 = stacktop(-2);\n          var buf3 = stacktop(-1);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = stacktop(-4);\n          buf2 = stacktop(-3);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = stacktop(-1);\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(stacktop(-1));\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(stacktop(-2));\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = stacktop(-1);\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf =  stacktop(-n-1);\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = stacktop(-3);\n          x2 = stacktop(-2);\n          var x3 = stacktop(-1);\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = stacktop(-2);\n          x2 = stacktop(-1);\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, stacktop(-1));\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(stacktop(-1).length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      //\n      // Bitwise logic\n      //\n      case Opcode.OP_AND:\n      case Opcode.OP_OR:\n      case Opcode.OP_XOR:\n        {\n          // (x1 x2 - out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n\n          // Inputs must be the same size\n          if (buf1.length !== buf2.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_OPERAND_SIZE';\n            return false;\n          }\n\n          // To avoid allocating, we modify vch1 in place.\n          switch (opcodenum) {\n            case Opcode.OP_AND:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] &= buf2[i];\n              }\n              break;\n            case Opcode.OP_OR:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] |= buf2[i];\n              }\n              break;\n            case Opcode.OP_XOR:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] ^= buf2[i];\n              }\n              break;\n            default:\n              break;\n          }\n\n          // And pop vch2.\n          this.stack.pop()\n        }\n        break;\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = stacktop(-1);\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_MOD:\n      case Opcode.OP_DIV:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n            case Opcode.OP_DIV:\n              // denominator must not be 0\n              if (bn2 == 0) {\n                this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';\n                return false;\n              }\n              bn = bn1.div(bn2);\n              break;\n\n            case Opcode.OP_MOD:\n              // divisor must not be 0\n              if (bn2 == 0) {\n                this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';\n                return false;\n              }\n              bn = bn1.mod(bn2);\n              break;\n\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(stacktop(-1))) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(stacktop(-3), fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = stacktop(-1);\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = stacktop(-2);\n          bufPubkey = stacktop(-1);\n\n          if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signature, since there's no way for a signature to sign itself\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n\n            if(!sig.isSchnorr) {\n              fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);\n            } else {\n              fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags, \"schnorr\");\n            }\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n            bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKDATASIG:\n      case Opcode.OP_CHECKDATASIGVERIFY:\n        {\n\n\n          // (sig message pubkey -- bool)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = stacktop(-3);\n          bufMessage = stacktop(-2);\n          bufPubkey = stacktop(-1);\n\n          if (!this.checkDataSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          fSuccess = false;\n\n\n          try {\n            sig = Signature.fromDataFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            bufHash = Hash.sha256(bufMessage);\n            if (!sig.isSchnorr) {\n              fSuccess = ECDSA.verify(bufHash, sig, pubkey, 'big');\n            } else {\n              fSuccess = Schnorr.verify(bufHash, sig, pubkey, 'big');\n            }\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n            bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKDATASIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKDATASIGVERIFY';\n              return false;\n            }\n          }\n\n        }\n        break;\n\n      case Opcode.OP_REVERSEBYTES:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-1);\n          var reversedBuf = Buffer.from(buf1).reverse();\n          this.stack.pop();\n          this.stack.push(reversedBuf);\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([dummy] [sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          let idxTopKey = i + 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(stacktop(-i), fRequireMinimal).toNumber();\n          var idxSigCount = idxTopKey + nKeysCount;\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n\n          // todo map interpreter.cpp variables with interpreter.js variables for future readability, maintainability\n          // ikey maps to idxTopKey in interpreter.cpp (MULTISIG case)\n          var ikey = ++i; // top pubkey\n          var idxTopSig = idxSigCount + 1;\n\n          // i maps to idxSigCount in interpreter.cpp (MULTISIG case) (stack depth of nSigsCount)\n          i += nKeysCount;\n\n          // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n          var ikey2 = nKeysCount + 2; // ?dummy variable\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(stacktop(-idxSigCount), fRequireMinimal).toNumber();\n          var idxDummy = idxTopSig + nSigsCount;\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < idxDummy) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          fSuccess = true;\n\n          if((this.flags & Interpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG) && stacktop(-idxDummy).length !== 0) {\n            // SCHNORR MULTISIG\n\n            let dummy = stacktop(-idxDummy);\n\n            let bitfieldObj = DecodeBitfield(dummy, nKeysCount);\n\n            if(!bitfieldObj[\"result\"]) {\n              fSuccess = false;\n            }\n\n            let nSigs8bit = new Uint8Array([nSigsCount]);\n            let nSigs32 = Uint32Array.from(nSigs8bit);\n\n            if (countBits(bitfieldObj[\"bitfield\"]) !== nSigs32[0]) {\n              this.errstr = \"INVALID_BIT_COUNT\";\n              fSuccess = false;\n            }\n\n            var bottomKey = idxTopKey + nKeysCount - 1;\n            var bottomSig = idxTopSig + nSigsCount - 1;\n\n            let iKey = 0;\n            for(let iSig = 0; iSig < nSigsCount;\n              iSig++, iKey++) {\n                if((bitfieldObj[\"bitfield\"] >> iKey) === 0) {\n                  this.errstr = \"INVALID_BIT_RANGE\";\n                  fSuccess = false;\n                }\n\n                while(((bitfieldObj[\"bitfield\"] >> iKey) & 0x01) == 0) {\n                  if(iKey >= nKeysCount) {\n                    this.errstr = \"wrong\";\n                    fSuccess = false;\n                    break;\n                  }\n                  iKey++;\n                }\n\n                // this is a sanity check and should be\n                // unreachable\n                if(iKey >= nKeysCount) {\n                  this.errstr = \"PUBKEY_COUNT\";\n                  fSuccess = false;\n                }\n\n                // Check the signature\n                let bufsig = stacktop(-bottomSig + iSig)\n                let bufPubkey = stacktop(-bottomKey + iKey)\n\n                // Note that only pubkeys associated with a\n                // signature are check for validity\n\n                if(!this.checkRawSignatureEncoding(bufsig) || !this.checkPubkeyEncoding(bufPubkey)) {\n                  fSuccess = false;\n                }\n\n                let sig = Signature.fromTxFormat(bufsig);\n                let pubkey = PublicKey.fromBuffer(bufPubkey, false);\n                let fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags, \"schnorr\");\n\n                if(!fOk) {\n                  this.errstr = \"SIG_NULLFAIL\"\n                  fSuccess = false;\n                }\n              }\n\n              if ((bitfieldObj[\"bitfield\"] >> iKey) != 0) {\n                // This is a sanity check and should be\n                // unreachable.\n                this.errstr = \"INVALID_BIT_COUNT\"\n                fSuccess = false;\n              }\n          }\n          else {\n            // Drop the signatures, since there's no way for a signature to sign itself\n            for (var k = 0; k < nSigsCount; k++) {\n              bufSig = stacktop(-isig-k);\n              subscript.findAndDelete(new Script().add(bufSig));\n            }\n\n            while (fSuccess && nSigsCount > 0) {\n\n                  // valtype& vchSig  = stacktop(-isig);\n                bufSig = stacktop(-isig);\n                // valtype& vchPubKey = stacktop(-ikey);\n                bufPubkey = stacktop(-ikey);\n\n                if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n                  return false;\n                }\n\n                var fOk;\n                try {\n                  sig = Signature.fromTxFormat(bufSig);\n                  pubkey = PublicKey.fromBuffer(bufPubkey, false);\n                  fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);\n                } catch (e) {\n                  //invalid sig or pubkey\n                  fOk = false;\n                }\n\n                if (fOk) {\n                  isig++;\n                  nSigsCount--;\n                }\n                ikey++;\n                nKeysCount--;\n\n                // If there are more signatures left than keys left,\n                // then too many signatures have failed\n                if (nSigsCount > nKeysCount) {\n                  fSuccess = false;\n                }\n              }\n          }\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n              !ikey2 && stacktop(-1).length) {\n\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n        //\n        // Byte string operations\n        //\n        case Opcode.OP_CAT: {\n\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          if (buf1.length + buf2.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n            this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n            return false;\n          }\n          this.stack[this.stack.length - 2] = Buffer.concat([buf1,buf2]);\n          this.stack.pop();\n        }\n        break;\n\n        case Opcode.OP_SPLIT: {\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = stacktop(-2);\n\n          // Make sure the split point is apropriate.\n          var position = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();\n          if (position < 0 || position > buf1.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_SPLIT_RANGE';\n            return false;\n          }\n\n          // Prepare the results in their own buffer as `data`\n          // will be invalidated.\n          // Copy buffer data, to slice it before\n          var n1 = Buffer.from(buf1);\n\n          // Replace existing stack values by the new values.\n          this.stack[this.stack.length - 2] = n1.slice(0, position);\n          this.stack[this.stack.length - 1] = n1.slice(position);\n        }\n        break;\n\n        //\n        // Conversion operations\n        //\n        case Opcode.OP_NUM2BIN: {\n\n          // (in -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var size = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();\n          if (size > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n            this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n            return false;\n          }\n\n          this.stack.pop();\n          var rawnum = stacktop(-1);\n\n          // Try to see if we can fit that number in the number of\n          // byte requested.\n          rawnum=Interpreter._minimallyEncode(rawnum);\n\n          if (rawnum.length > size) {\n            // We definitively cannot.\n            this.errstr = 'SCRIPT_ERR_IMPOSSIBLE_ENCODING';\n            return false;\n          }\n\n          // We already have an element of the right size, we\n          // don't need to do anything.\n          if (rawnum.length == size) {\n            this.stack[this.stack.length-1] = rawnum;\n            break;\n          }\n\n          var signbit = 0x00;\n          if (rawnum.length > 0) {\n            signbit = rawnum[rawnum.length - 1] & 0x80;\n            rawnum[rawnum.length - 1] &= 0x7f;\n          }\n\n          var num = Buffer.alloc(size);\n          rawnum.copy(num,0);\n\n          var l = rawnum.length - 1;\n          while (l++ < size - 2) {\n            num[l]=0x00;\n          }\n\n          num[l]=signbit;\n\n          this.stack[this.stack.length-1] = num;\n        }\n        break;\n\n\n\n        case Opcode.OP_BIN2NUM: {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-1);\n          buf2 = Interpreter._minimallyEncode(buf1);\n\n          this.stack[this.stack.length - 1] = buf2;\n\n          // The resulting number must be a valid number.\n          if (!Interpreter._isMinimallyEncoded(buf2)) {\n            this.errstr = 'SCRIPT_ERR_INVALID_NUMBER_RANGE';\n            return false;\n          }\n        }\n        break;\n\n\n\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};\n\n"]},"metadata":{},"sourceType":"script"}