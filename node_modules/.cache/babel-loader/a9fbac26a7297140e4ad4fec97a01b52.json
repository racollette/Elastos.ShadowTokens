{"ast":null,"code":"import createLogger from 'logging';\nimport debugLogger from 'debug';\nimport { V1endpoint, V2endpoint } from '../config';\nimport wrtc from 'wrtc';\nimport io from 'socket.io-client';\nimport MewConnectCommon from '../MewConnectCommon';\nconst debug = debugLogger('MEWconnect:initiator-V1');\nconst debugPeer = debugLogger('MEWconnectVerbose:peer-instances-V1');\nconst debugStages = debugLogger('MEWconnect:initiator-stages-V1');\nconst logger = createLogger('MewConnectInitiator-V1');\nexport default class MewConnectInitiatorV1 extends MewConnectCommon {\n  constructor(options = {}) {\n    super('V1');\n\n    try {\n      this.supportedBrowser = MewConnectCommon.checkBrowser();\n      this.uiCommunicator = options.uiCommunicator;\n      this.active = true;\n      this.activePeerId = '';\n      this.allPeerIds = [];\n      this.peersCreated = [];\n      this.Url = options.url || V1endpoint;\n      this.v2Url = options.v2Url || V2endpoint;\n      this.turnTest = options.turnTest;\n      this.p = null;\n      this.socketConnected = false;\n      this.connected = false;\n      this.tryingTurn = false;\n      this.turnDisabled = false;\n      this.signalUrl = null;\n      this.iceState = '';\n      this.turnServers = [];\n      this.webRtcCommunication = options.webRtcCommunication;\n      this.io = io;\n      this.signals = this.jsonDetails.signals;\n      this.rtcEvents = this.jsonDetails.rtc;\n      this.version = this.jsonDetails.version;\n      this.versions = this.jsonDetails.versions;\n      this.lifeCycle = this.jsonDetails.lifeCycle;\n      this.stunServers = options.stunServers || this.jsonDetails.stunSrvers;\n      this.iceStates = this.jsonDetails.iceConnectionState;\n      this.timer = null;\n      debug(this.signals);\n    } catch (e) {\n      debug('constructor error:', e);\n    }\n  }\n\n  setWebRtc(webRtcCommunication) {\n    this.webRtcCommunication = webRtcCommunication;\n  } // Initalize a websocket connection with the signal server\n\n\n  async initiatorStart(url = this.Url, cryptoInstance, details) {\n    try {\n      this.mewCrypto = cryptoInstance;\n      const toSign = this.mewCrypto.generateMessage();\n      this.connId = details.connId;\n      this.uiCommunicator(this.lifeCycle.signatureCheck);\n      const options = {\n        query: {\n          stage: 'initiator',\n          signed: details.signed,\n          message: toSign,\n          connId: this.connId\n        },\n        transports: ['websocket', 'polling', 'flashsocket'],\n        secure: true\n      };\n      this.socketManager = this.io(url, options);\n      this.socket = this.socketManager.connect();\n      this.initiatorConnect(this.socket);\n    } catch (e) {\n      debug(e);\n    }\n  } // ------------- WebSocket Communication Methods and Handlers ------------------------------\n  // ----- Setup handlers for communication with the signal server\n\n\n  initiatorConnect(socket) {\n    debugStages('INITIATOR CONNECT');\n    this.uiCommunicator(this.lifeCycle.SocketConnectedEvent);\n    this.socket.on(this.signals.connect, () => {\n      debug(': SOCKET CONNECTED');\n      this.socketConnected = true;\n    });\n    this.socketOn(this.signals.confirmation, this.beginRtcSequence.bind(this)); // response\n\n    this.socketOn(this.signals.answer, this.recieveAnswer.bind(this));\n    this.socketOn(this.signals.confirmationFailedBusy, this.busyFailure.bind(this));\n    this.socketOn(this.signals.confirmationFailed, this.confirmationFailure.bind(this));\n    this.socketOn(this.signals.invalidConnection, this.invalidFailure.bind(this));\n    this.socketOn(this.signals.disconnect, this.socketDisconnectHandler.bind(this));\n    this.socketOn(this.signals.attemptingTurn, this.willAttemptTurn.bind(this));\n    this.socketOn(this.signals.turnToken, this.beginTurn.bind(this));\n    return socket;\n  } // ----- Wrapper around Socket.IO methods\n  // socket.emit wrapper\n\n\n  socketEmit(signal, data) {\n    this.socket.binary(false).emit(signal, data);\n  } // socket.disconnect wrapper\n\n\n  socketDisconnect() {\n    this.active = false;\n    this.socket.disconnect();\n    this.socketConnected = false;\n    debug('webSocket Disconnected');\n  } // socket.on listener registration wrapper\n\n\n  socketOn(signal, func) {\n    this.socket.on(signal, func);\n  } // ----- Socket Event handlers\n  // Handle Socket Disconnect Event\n\n\n  socketDisconnectHandler(reason) {\n    debug(reason);\n    this.socketConnected = false;\n  } // Handle Socket Attempting Turn informative signal\n  // Provide Notice that initial WebRTC connection failed and the fallback method will be used\n\n\n  willAttemptTurn() {\n    this.tryingTurn = true;\n    debugStages('TRY TURN CONNECTION');\n    this.uiCommunicator(this.lifeCycle.UsingFallback);\n  } // Handle Socket event to initiate turn connection\n  // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN\n\n\n  beginTurn(data) {\n    this.tryingTurn = true;\n    this.webRtcCommunication.turnReset(this.activePeerId);\n    this.retryViaTurn(data);\n  } // ----- Failure Handlers\n  // Handle Failure due to an attempt to join a connection with two existing endpoints\n\n\n  busyFailure() {\n    this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.confirmationFailedBusyEvent);\n    debug('confirmation Failed: Busy');\n  } // Handle Failure due to no opposing peer existing\n\n\n  invalidFailure() {\n    this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.invalidConnectionEvent);\n    debug('confirmation Failed: no opposite peer found');\n  } // Handle Failure due to the handshake/ verify details being invalid for the connection ID\n\n\n  confirmationFailure() {\n    this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.confirmationFailedEvent);\n    debug('confirmation Failed: invalid confirmation');\n  } // =============== [End] WebSocket Communication Methods and Handlers ========================\n  // ======================== [Start] WebRTC Communication Methods =============================\n  // ----- WebRTC Setup Methods\n  // A connection pair exists, create and send WebRTC OFFER\n\n\n  async beginRtcSequence(data) {\n    this.emit('socketPaired');\n    debug(data);\n    debug('sendOffer: SOCKET CONFIRMATION');\n    this.emit('beginRtcSequence', 'V1'); // this.connPath = source;\n    // const plainTextVersion = await this.mewCrypto.decrypt(data.version);\n    // this.peerVersion = plainTextVersion;\n    // this.uiCommunicator(this.lifeCycle.receiverVersion, plainTextVersion);\n\n    debug('sendOffer', data);\n    const options = {\n      webRtcConfig: {\n        servers: this.stunServers\n      }\n    };\n    this.initiatorStartRTC(this.socket, options);\n  }\n\n  initiatorStartRTC(socket, options) {\n    debug('initiatorStartRTC');\n    const webRtcConfig = options.webRtcConfig || {};\n    const webRtcServers = webRtcConfig.servers || this.stunServers;\n    const suppliedOptions = options.webRtcOptions || {};\n    const defaultOptions = {\n      initiator: true,\n      trickle: false,\n      iceTransportPolicy: 'relay',\n      config: {\n        iceServers: webRtcServers\n      },\n      wrtc: wrtc\n    };\n    const simpleOptions = { ...defaultOptions,\n      suppliedOptions\n    };\n    debug(`initiatorStartRTC - options: ${simpleOptions}`);\n    debug('START V1'); // todo remove dev item\n\n    this.webRtcCommunication.setConnectionVersion('V1');\n    this.webRtcCommunication.start(simpleOptions);\n    this.uiCommunicator(this.lifeCycle.RtcInitiatedEvent);\n    const peerID = this.webRtcCommunication.getActivePeerId();\n    this.webRtcCommunication.once('connect', this.onConnect.bind(this, peerID));\n    this.webRtcCommunication.once('signal', this.onSignal.bind(this));\n    this.webRtcCommunication.once('data', this.onData.bind(this, peerID));\n  }\n\n  onConnect(peerID) {\n    debugStages('RTC CONNECT', 'ok');\n    debugPeer('peerID', peerID);\n    this.connected = true;\n    this.turnDisabled = true;\n    this.socketEmit(this.signals.rtcConnected, this.socketKey);\n    this.socketDisconnect();\n    this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);\n  }\n\n  async onSignal(data) {\n    debug('onSignal');\n    debug(data);\n    const encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(data));\n    this.uiCommunicator(this.lifeCycle.sendOffer);\n    this.socketEmit(this.signals.offerSignal, {\n      data: encryptedSend,\n      connId: this.connId,\n      options: this.stunServers\n    });\n  } // Handle the WebRTC ANSWER from the opposite (mobile) peer\n\n\n  async recieveAnswer(data) {\n    debug('recieveAnswer', data);\n\n    try {\n      const plainTextOffer = await this.mewCrypto.decrypt(data.data);\n      this.webRtcCommunication.receiveAnswer(JSON.parse(plainTextOffer)); // this.rtcRecieveAnswer({ data: plainTextOffer });\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n\n  rtcRecieveAnswer(data) {\n    this.uiCommunicator(this.lifeCycle.answerReceived);\n    this.p.signal(JSON.parse(data.data));\n  }\n\n  rtcDestroy() {\n    if (this.active) {\n      this.webRtcCommunication.rtcDestroy();\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);\n    }\n  }\n\n  disconnectRTCClosure() {\n    return () => {\n      debugStages('DISCONNECT RTC Closure');\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n      this.rtcDestroy();\n      this.instance = null;\n    };\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.rtcDestroy();\n    this.instance = null;\n  }\n\n  async useFallback() {\n    this.socketEmit(this.signals.tryTurn, {\n      connId: this.connId\n    });\n  } // ----- WebRTC Communication Event Handlers\n\n\n  onData(data) {\n    this.emit(data.type, data.data);\n  }\n\n  retryViaTurn(data) {\n    debugStages('Retrying via TURN v1');\n    debug(data);\n    const options = {\n      signalListener: this.initiatorSignalListener,\n      webRtcConfig: {\n        servers: data.data\n      }\n    };\n    this.beginRtcSequence(options);\n  }\n\n}","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/@myetherwallet/mewconnect-web-client/src/connectClient/initiator/MewConnectInitiatorV1.js"],"names":["createLogger","debugLogger","V1endpoint","V2endpoint","wrtc","io","MewConnectCommon","debug","debugPeer","debugStages","logger","MewConnectInitiatorV1","constructor","options","supportedBrowser","checkBrowser","uiCommunicator","active","activePeerId","allPeerIds","peersCreated","Url","url","v2Url","turnTest","p","socketConnected","connected","tryingTurn","turnDisabled","signalUrl","iceState","turnServers","webRtcCommunication","signals","jsonDetails","rtcEvents","rtc","version","versions","lifeCycle","stunServers","stunSrvers","iceStates","iceConnectionState","timer","e","setWebRtc","initiatorStart","cryptoInstance","details","mewCrypto","toSign","generateMessage","connId","signatureCheck","query","stage","signed","message","transports","secure","socketManager","socket","connect","initiatorConnect","SocketConnectedEvent","on","socketOn","confirmation","beginRtcSequence","bind","answer","recieveAnswer","confirmationFailedBusy","busyFailure","confirmationFailed","confirmationFailure","invalidConnection","invalidFailure","disconnect","socketDisconnectHandler","attemptingTurn","willAttemptTurn","turnToken","beginTurn","socketEmit","signal","data","binary","emit","socketDisconnect","func","reason","UsingFallback","turnReset","retryViaTurn","Failed","confirmationFailedBusyEvent","invalidConnectionEvent","confirmationFailedEvent","webRtcConfig","servers","initiatorStartRTC","webRtcServers","suppliedOptions","webRtcOptions","defaultOptions","initiator","trickle","iceTransportPolicy","config","iceServers","simpleOptions","setConnectionVersion","start","RtcInitiatedEvent","peerID","getActivePeerId","once","onConnect","onSignal","onData","rtcConnected","socketKey","RtcConnectedEvent","encryptedSend","encrypt","JSON","stringify","sendOffer","offerSignal","plainTextOffer","decrypt","receiveAnswer","parse","error","rtcRecieveAnswer","answerReceived","rtcDestroy","RtcDestroyedEvent","disconnectRTCClosure","RtcDisconnectEvent","instance","disconnectRTC","useFallback","tryTurn","type","signalListener","initiatorSignalListener"],"mappings":"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","sourcesContent":["import createLogger from 'logging';\nimport debugLogger from 'debug';\nimport {V1endpoint, V2endpoint} from '../config';\n\nimport wrtc from 'wrtc';\nimport io from 'socket.io-client';\nimport MewConnectCommon from '../MewConnectCommon';\n\nconst debug = debugLogger('MEWconnect:initiator-V1');\nconst debugPeer = debugLogger('MEWconnectVerbose:peer-instances-V1');\nconst debugStages = debugLogger('MEWconnect:initiator-stages-V1');\nconst logger = createLogger('MewConnectInitiator-V1');\n\nexport default class MewConnectInitiatorV1 extends MewConnectCommon {\n  constructor(options = {}) {\n    super('V1');\n\n    try {\n      this.supportedBrowser = MewConnectCommon.checkBrowser();\n      this.uiCommunicator = options.uiCommunicator;\n      this.active = true;\n      this.activePeerId = '';\n      this.allPeerIds = [];\n      this.peersCreated = [];\n\n      this.Url = options.url || V1endpoint;\n      this.v2Url = options.v2Url || V2endpoint;\n\n      this.turnTest = options.turnTest;\n\n      this.p = null;\n      this.socketConnected = false;\n      this.connected = false;\n      this.tryingTurn = false;\n      this.turnDisabled = false;\n      this.signalUrl = null;\n      this.iceState = '';\n      this.turnServers = [];\n\n      this.webRtcCommunication = options.webRtcCommunication;\n\n      this.io = io;\n\n      this.signals = this.jsonDetails.signals;\n      this.rtcEvents = this.jsonDetails.rtc;\n      this.version = this.jsonDetails.version;\n      this.versions = this.jsonDetails.versions;\n      this.lifeCycle = this.jsonDetails.lifeCycle;\n      this.stunServers = options.stunServers || this.jsonDetails.stunSrvers;\n      this.iceStates = this.jsonDetails.iceConnectionState;\n      this.timer = null;\n      debug(this.signals);\n    } catch (e) {\n      debug('constructor error:', e);\n    }\n  }\n\n  setWebRtc(webRtcCommunication) {\n    this.webRtcCommunication = webRtcCommunication;\n  }\n\n  // Initalize a websocket connection with the signal server\n  async initiatorStart(url = this.Url, cryptoInstance, details) {\n    try {\n      this.mewCrypto = cryptoInstance;\n      const toSign = this.mewCrypto.generateMessage();\n      this.connId = details.connId;\n      this.uiCommunicator(this.lifeCycle.signatureCheck);\n      const options = {\n        query: {\n          stage: 'initiator',\n          signed: details.signed,\n          message: toSign,\n          connId: this.connId\n        },\n        transports: ['websocket', 'polling', 'flashsocket'],\n        secure: true\n      };\n      this.socketManager = this.io(url, options);\n      this.socket = this.socketManager.connect();\n      this.initiatorConnect(this.socket);\n    } catch (e) {\n      debug(e);\n    }\n  }\n\n  // ------------- WebSocket Communication Methods and Handlers ------------------------------\n\n  // ----- Setup handlers for communication with the signal server\n  initiatorConnect(socket) {\n    debugStages('INITIATOR CONNECT');\n    this.uiCommunicator(this.lifeCycle.SocketConnectedEvent);\n\n    this.socket.on(this.signals.connect, () => {\n      debug(': SOCKET CONNECTED');\n      this.socketConnected = true;\n    });\n\n    this.socketOn(this.signals.confirmation, this.beginRtcSequence.bind(this)); // response\n    this.socketOn(this.signals.answer, this.recieveAnswer.bind(this));\n    this.socketOn(\n      this.signals.confirmationFailedBusy,\n      this.busyFailure.bind(this)\n    );\n    this.socketOn(\n      this.signals.confirmationFailed,\n      this.confirmationFailure.bind(this)\n    );\n    this.socketOn(\n      this.signals.invalidConnection,\n      this.invalidFailure.bind(this)\n    );\n    this.socketOn(\n      this.signals.disconnect,\n      this.socketDisconnectHandler.bind(this)\n    );\n    this.socketOn(this.signals.attemptingTurn, this.willAttemptTurn.bind(this));\n    this.socketOn(this.signals.turnToken, this.beginTurn.bind(this));\n    return socket;\n  }\n\n  // ----- Wrapper around Socket.IO methods\n  // socket.emit wrapper\n  socketEmit(signal, data) {\n    this.socket.binary(false).emit(signal, data);\n  }\n\n  // socket.disconnect wrapper\n  socketDisconnect() {\n    this.active = false;\n    this.socket.disconnect();\n    this.socketConnected = false;\n    debug('webSocket Disconnected');\n  }\n\n  // socket.on listener registration wrapper\n  socketOn(signal, func) {\n    this.socket.on(signal, func);\n  }\n\n  // ----- Socket Event handlers\n\n  // Handle Socket Disconnect Event\n  socketDisconnectHandler(reason) {\n    debug(reason);\n    this.socketConnected = false;\n  }\n\n  // Handle Socket Attempting Turn informative signal\n  // Provide Notice that initial WebRTC connection failed and the fallback method will be used\n  willAttemptTurn() {\n    this.tryingTurn = true;\n    debugStages('TRY TURN CONNECTION');\n    this.uiCommunicator(this.lifeCycle.UsingFallback);\n  }\n\n  // Handle Socket event to initiate turn connection\n  // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN\n  beginTurn(data) {\n    this.tryingTurn = true;\n    this.webRtcCommunication.turnReset(this.activePeerId);\n    this.retryViaTurn(data);\n  }\n\n  // ----- Failure Handlers\n\n  // Handle Failure due to an attempt to join a connection with two existing endpoints\n  busyFailure() {\n    this.uiCommunicator(\n      this.lifeCycle.Failed,\n      this.lifeCycle.confirmationFailedBusyEvent\n    );\n    debug('confirmation Failed: Busy');\n  }\n\n  // Handle Failure due to no opposing peer existing\n  invalidFailure() {\n    this.uiCommunicator(\n      this.lifeCycle.Failed,\n      this.lifeCycle.invalidConnectionEvent\n    );\n    debug('confirmation Failed: no opposite peer found');\n  }\n\n  // Handle Failure due to the handshake/ verify details being invalid for the connection ID\n  confirmationFailure() {\n    this.uiCommunicator(\n      this.lifeCycle.Failed,\n      this.lifeCycle.confirmationFailedEvent\n    );\n    debug('confirmation Failed: invalid confirmation');\n  }\n\n  // =============== [End] WebSocket Communication Methods and Handlers ========================\n\n  // ======================== [Start] WebRTC Communication Methods =============================\n\n  // ----- WebRTC Setup Methods\n\n  // A connection pair exists, create and send WebRTC OFFER\n  async beginRtcSequence(data) {\n    this.emit('socketPaired');\n    debug(data);\n    debug('sendOffer: SOCKET CONFIRMATION');\n    this.emit('beginRtcSequence', 'V1');\n    // this.connPath = source;\n    // const plainTextVersion = await this.mewCrypto.decrypt(data.version);\n    // this.peerVersion = plainTextVersion;\n    // this.uiCommunicator(this.lifeCycle.receiverVersion, plainTextVersion);\n    debug('sendOffer', data);\n    const options = {\n      webRtcConfig: {\n        servers: this.stunServers\n      }\n    };\n    this.initiatorStartRTC(this.socket, options);\n  }\n\n  initiatorStartRTC(socket, options) {\n    debug('initiatorStartRTC');\n    const webRtcConfig = options.webRtcConfig || {};\n\n    const webRtcServers = webRtcConfig.servers || this.stunServers;\n\n    const suppliedOptions = options.webRtcOptions || {};\n\n    const defaultOptions = {\n      initiator: true,\n      trickle: false,\n      iceTransportPolicy: 'relay',\n      config: {\n        iceServers: webRtcServers\n      },\n      wrtc: wrtc\n    };\n\n    const simpleOptions = {\n      ...defaultOptions,\n      suppliedOptions\n    };\n\n    debug(`initiatorStartRTC - options: ${simpleOptions}`);\n    debug('START V1'); // todo remove dev item\n    this.webRtcCommunication.setConnectionVersion('V1');\n    this.webRtcCommunication.start(simpleOptions);\n    this.uiCommunicator(this.lifeCycle.RtcInitiatedEvent);\n    const peerID = this.webRtcCommunication.getActivePeerId();\n    this.webRtcCommunication.once('connect', this.onConnect.bind(this, peerID));\n    this.webRtcCommunication.once('signal', this.onSignal.bind(this));\n    this.webRtcCommunication.once('data', this.onData.bind(this, peerID));\n  }\n\n  onConnect(peerID) {\n    debugStages('RTC CONNECT', 'ok');\n    debugPeer('peerID', peerID);\n    this.connected = true;\n    this.turnDisabled = true;\n    this.socketEmit(this.signals.rtcConnected, this.socketKey);\n    this.socketDisconnect();\n    this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);\n  }\n\n  async onSignal(data) {\n    debug('onSignal');\n    debug(data);\n    const encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(data));\n    this.uiCommunicator(this.lifeCycle.sendOffer);\n    this.socketEmit(this.signals.offerSignal, {\n      data: encryptedSend,\n      connId: this.connId,\n      options: this.stunServers\n    });\n  }\n\n  // Handle the WebRTC ANSWER from the opposite (mobile) peer\n  async recieveAnswer(data) {\n    debug('recieveAnswer', data);\n    try {\n      const plainTextOffer = await this.mewCrypto.decrypt(data.data);\n      this.webRtcCommunication.receiveAnswer(JSON.parse(plainTextOffer));\n      // this.rtcRecieveAnswer({ data: plainTextOffer });\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n\n  rtcRecieveAnswer(data) {\n    this.uiCommunicator(this.lifeCycle.answerReceived);\n    this.p.signal(JSON.parse(data.data));\n  }\n\n  rtcDestroy() {\n    if (this.active) {\n      this.webRtcCommunication.rtcDestroy();\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);\n    }\n  }\n\n  disconnectRTCClosure() {\n    return () => {\n      debugStages('DISCONNECT RTC Closure');\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n      this.rtcDestroy();\n      this.instance = null;\n    };\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.rtcDestroy();\n    this.instance = null;\n  }\n\n  async useFallback() {\n    this.socketEmit(this.signals.tryTurn, { connId: this.connId });\n  }\n\n  // ----- WebRTC Communication Event Handlers\n\n  onData(data) {\n    this.emit(data.type, data.data);\n  }\n\n  retryViaTurn(data) {\n    debugStages('Retrying via TURN v1');\n    debug(data);\n    const options = {\n      signalListener: this.initiatorSignalListener,\n      webRtcConfig: {\n        servers: data.data\n      }\n    };\n    this.beginRtcSequence(options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}