{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bech32 = require('bech32');\n\nvar bs58check = require('bs58check');\n\nvar bscript = require('./script');\n\nvar btemplates = require('./templates');\n\nvar networks = require('./networks');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nfunction fromBase58Check(address) {\n  var payload = bs58check.decode(address); // TODO: 4.0.0, move to \"toOutputScript\"\n\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 22) throw new TypeError(address + ' is too long');\n  var multibyte = payload.length === 22;\n  var offset = multibyte ? 2 : 1;\n  var version = multibyte ? payload.readUInt16BE(0) : payload[0];\n  var hash = payload.slice(offset);\n  return {\n    version: version,\n    hash: hash\n  };\n}\n\nfunction fromBech32(address) {\n  var result = bech32.decode(address);\n  var data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n}\n\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt16), arguments); // Zcash adds an extra prefix resulting in a bigger (22 bytes) payload. We identify them Zcash by checking if the\n  // version is multibyte (2 bytes instead of 1)\n\n  var multibyte = version > 0xff;\n  var size = multibyte ? 22 : 21;\n  var offset = multibyte ? 2 : 1;\n  var payload = Buffer.allocUnsafe(size);\n  multibyte ? payload.writeUInt16BE(version, 0) : payload.writeUInt8(version, 0);\n  hash.copy(payload, offset);\n  return bs58check.encode(payload);\n}\n\nfunction toBech32(data, version, prefix) {\n  var words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\n\nfunction fromOutputScript(outputScript, network) {\n  network = network || networks.bitcoin;\n  if (btemplates.pubKeyHash.output.check(outputScript)) return toBase58Check(bscript.compile(outputScript).slice(3, 23), network.pubKeyHash);\n  if (btemplates.scriptHash.output.check(outputScript)) return toBase58Check(bscript.compile(outputScript).slice(2, 22), network.scriptHash);\n  if (btemplates.witnessPubKeyHash.output.check(outputScript)) return toBech32(bscript.compile(outputScript).slice(2, 22), 0, network.bech32);\n  if (btemplates.witnessScriptHash.output.check(outputScript)) return toBech32(bscript.compile(outputScript).slice(2, 34), 0, network.bech32);\n  throw new Error(bscript.toASM(outputScript) + ' has no matching Address');\n}\n\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  var decode;\n\n  try {\n    decode = fromBase58Check(address);\n  } catch (e) {}\n\n  if (decode) {\n    if (decode.version === network.pubKeyHash) return btemplates.pubKeyHash.output.encode(decode.hash);\n    if (decode.version === network.scriptHash) return btemplates.scriptHash.output.encode(decode.hash);\n  } else {\n    try {\n      decode = fromBech32(address);\n    } catch (e) {}\n\n    if (decode) {\n      if (decode.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');\n\n      if (decode.version === 0) {\n        if (decode.data.length === 20) return btemplates.witnessPubKeyHash.output.encode(decode.data);\n        if (decode.data.length === 32) return btemplates.witnessScriptHash.output.encode(decode.data);\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script');\n}\n\nmodule.exports = {\n  fromBase58Check: fromBase58Check,\n  fromBech32: fromBech32,\n  fromOutputScript: fromOutputScript,\n  toBase58Check: toBase58Check,\n  toBech32: toBech32,\n  toOutputScript: toOutputScript\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitgo-utxo-lib/src/address.js"],"names":["Buffer","require","bech32","bs58check","bscript","btemplates","networks","typeforce","types","fromBase58Check","address","payload","decode","length","TypeError","multibyte","offset","version","readUInt16BE","hash","slice","fromBech32","result","data","fromWords","words","prefix","from","toBase58Check","tuple","Hash160bit","UInt16","arguments","size","allocUnsafe","writeUInt16BE","writeUInt8","copy","encode","toBech32","toWords","unshift","fromOutputScript","outputScript","network","bitcoin","pubKeyHash","output","check","compile","scriptHash","witnessPubKeyHash","witnessScriptHash","Error","toASM","toOutputScript","e","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAAP,CAAuBD,MAApC;;AACA,IAAIE,MAAM,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAArB;;AACA,IAAII,UAAU,GAAGJ,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIM,SAAS,GAAGN,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,SAAD,CAAnB;;AAEA,SAASQ,eAAT,CAA0BC,OAA1B,EAAmC;AACjC,MAAIC,OAAO,GAAGR,SAAS,CAACS,MAAV,CAAiBF,OAAjB,CAAd,CADiC,CAGjC;;AACA,MAAIC,OAAO,CAACE,MAAR,GAAiB,EAArB,EAAyB,MAAM,IAAIC,SAAJ,CAAcJ,OAAO,GAAG,eAAxB,CAAN;AACzB,MAAIC,OAAO,CAACE,MAAR,GAAiB,EAArB,EAAyB,MAAM,IAAIC,SAAJ,CAAcJ,OAAO,GAAG,cAAxB,CAAN;AAEzB,MAAIK,SAAS,GAAGJ,OAAO,CAACE,MAAR,KAAmB,EAAnC;AACA,MAAIG,MAAM,GAAGD,SAAS,GAAG,CAAH,GAAO,CAA7B;AAEA,MAAIE,OAAO,GAAGF,SAAS,GAAGJ,OAAO,CAACO,YAAR,CAAqB,CAArB,CAAH,GAA6BP,OAAO,CAAC,CAAD,CAA3D;AACA,MAAIQ,IAAI,GAAGR,OAAO,CAACS,KAAR,CAAcJ,MAAd,CAAX;AAEA,SAAO;AAAEC,IAAAA,OAAO,EAAEA,OAAX;AAAoBE,IAAAA,IAAI,EAAEA;AAA1B,GAAP;AACD;;AAED,SAASE,UAAT,CAAqBX,OAArB,EAA8B;AAC5B,MAAIY,MAAM,GAAGpB,MAAM,CAACU,MAAP,CAAcF,OAAd,CAAb;AACA,MAAIa,IAAI,GAAGrB,MAAM,CAACsB,SAAP,CAAiBF,MAAM,CAACG,KAAP,CAAaL,KAAb,CAAmB,CAAnB,CAAjB,CAAX;AAEA,SAAO;AACLH,IAAAA,OAAO,EAAEK,MAAM,CAACG,KAAP,CAAa,CAAb,CADJ;AAELC,IAAAA,MAAM,EAAEJ,MAAM,CAACI,MAFV;AAGLH,IAAAA,IAAI,EAAEvB,MAAM,CAAC2B,IAAP,CAAYJ,IAAZ;AAHD,GAAP;AAKD;;AAED,SAASK,aAAT,CAAwBT,IAAxB,EAA8BF,OAA9B,EAAuC;AACrCV,EAAAA,SAAS,CAACC,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAACsB,UAAlB,EAA8BtB,KAAK,CAACuB,MAApC,CAAD,EAA8CC,SAA9C,CAAT,CADqC,CAGrC;AACA;;AACA,MAAIjB,SAAS,GAAGE,OAAO,GAAG,IAA1B;AACA,MAAIgB,IAAI,GAAGlB,SAAS,GAAG,EAAH,GAAQ,EAA5B;AACA,MAAIC,MAAM,GAAGD,SAAS,GAAG,CAAH,GAAO,CAA7B;AAEA,MAAIJ,OAAO,GAAGX,MAAM,CAACkC,WAAP,CAAmBD,IAAnB,CAAd;AACAlB,EAAAA,SAAS,GAAGJ,OAAO,CAACwB,aAAR,CAAsBlB,OAAtB,EAA+B,CAA/B,CAAH,GAAuCN,OAAO,CAACyB,UAAR,CAAmBnB,OAAnB,EAA4B,CAA5B,CAAhD;AACAE,EAAAA,IAAI,CAACkB,IAAL,CAAU1B,OAAV,EAAmBK,MAAnB;AAEA,SAAOb,SAAS,CAACmC,MAAV,CAAiB3B,OAAjB,CAAP;AACD;;AAED,SAAS4B,QAAT,CAAmBhB,IAAnB,EAAyBN,OAAzB,EAAkCS,MAAlC,EAA0C;AACxC,MAAID,KAAK,GAAGvB,MAAM,CAACsC,OAAP,CAAejB,IAAf,CAAZ;AACAE,EAAAA,KAAK,CAACgB,OAAN,CAAcxB,OAAd;AAEA,SAAOf,MAAM,CAACoC,MAAP,CAAcZ,MAAd,EAAsBD,KAAtB,CAAP;AACD;;AAED,SAASiB,gBAAT,CAA2BC,YAA3B,EAAyCC,OAAzC,EAAkD;AAChDA,EAAAA,OAAO,GAAGA,OAAO,IAAItC,QAAQ,CAACuC,OAA9B;AAEA,MAAIxC,UAAU,CAACyC,UAAX,CAAsBC,MAAtB,CAA6BC,KAA7B,CAAmCL,YAAnC,CAAJ,EAAsD,OAAOf,aAAa,CAACxB,OAAO,CAAC6C,OAAR,CAAgBN,YAAhB,EAA8BvB,KAA9B,CAAoC,CAApC,EAAuC,EAAvC,CAAD,EAA6CwB,OAAO,CAACE,UAArD,CAApB;AACtD,MAAIzC,UAAU,CAAC6C,UAAX,CAAsBH,MAAtB,CAA6BC,KAA7B,CAAmCL,YAAnC,CAAJ,EAAsD,OAAOf,aAAa,CAACxB,OAAO,CAAC6C,OAAR,CAAgBN,YAAhB,EAA8BvB,KAA9B,CAAoC,CAApC,EAAuC,EAAvC,CAAD,EAA6CwB,OAAO,CAACM,UAArD,CAApB;AACtD,MAAI7C,UAAU,CAAC8C,iBAAX,CAA6BJ,MAA7B,CAAoCC,KAApC,CAA0CL,YAA1C,CAAJ,EAA6D,OAAOJ,QAAQ,CAACnC,OAAO,CAAC6C,OAAR,CAAgBN,YAAhB,EAA8BvB,KAA9B,CAAoC,CAApC,EAAuC,EAAvC,CAAD,EAA6C,CAA7C,EAAgDwB,OAAO,CAAC1C,MAAxD,CAAf;AAC7D,MAAIG,UAAU,CAAC+C,iBAAX,CAA6BL,MAA7B,CAAoCC,KAApC,CAA0CL,YAA1C,CAAJ,EAA6D,OAAOJ,QAAQ,CAACnC,OAAO,CAAC6C,OAAR,CAAgBN,YAAhB,EAA8BvB,KAA9B,CAAoC,CAApC,EAAuC,EAAvC,CAAD,EAA6C,CAA7C,EAAgDwB,OAAO,CAAC1C,MAAxD,CAAf;AAE7D,QAAM,IAAImD,KAAJ,CAAUjD,OAAO,CAACkD,KAAR,CAAcX,YAAd,IAA8B,0BAAxC,CAAN;AACD;;AAED,SAASY,cAAT,CAAyB7C,OAAzB,EAAkCkC,OAAlC,EAA2C;AACzCA,EAAAA,OAAO,GAAGA,OAAO,IAAItC,QAAQ,CAACuC,OAA9B;AAEA,MAAIjC,MAAJ;;AACA,MAAI;AACFA,IAAAA,MAAM,GAAGH,eAAe,CAACC,OAAD,CAAxB;AACD,GAFD,CAEE,OAAO8C,CAAP,EAAU,CAAE;;AAEd,MAAI5C,MAAJ,EAAY;AACV,QAAIA,MAAM,CAACK,OAAP,KAAmB2B,OAAO,CAACE,UAA/B,EAA2C,OAAOzC,UAAU,CAACyC,UAAX,CAAsBC,MAAtB,CAA6BT,MAA7B,CAAoC1B,MAAM,CAACO,IAA3C,CAAP;AAC3C,QAAIP,MAAM,CAACK,OAAP,KAAmB2B,OAAO,CAACM,UAA/B,EAA2C,OAAO7C,UAAU,CAAC6C,UAAX,CAAsBH,MAAtB,CAA6BT,MAA7B,CAAoC1B,MAAM,CAACO,IAA3C,CAAP;AAC5C,GAHD,MAGO;AACL,QAAI;AACFP,MAAAA,MAAM,GAAGS,UAAU,CAACX,OAAD,CAAnB;AACD,KAFD,CAEE,OAAO8C,CAAP,EAAU,CAAE;;AAEd,QAAI5C,MAAJ,EAAY;AACV,UAAIA,MAAM,CAACc,MAAP,KAAkBkB,OAAO,CAAC1C,MAA9B,EAAsC,MAAM,IAAImD,KAAJ,CAAU3C,OAAO,GAAG,wBAApB,CAAN;;AACtC,UAAIE,MAAM,CAACK,OAAP,KAAmB,CAAvB,EAA0B;AACxB,YAAIL,MAAM,CAACW,IAAP,CAAYV,MAAZ,KAAuB,EAA3B,EAA+B,OAAOR,UAAU,CAAC8C,iBAAX,CAA6BJ,MAA7B,CAAoCT,MAApC,CAA2C1B,MAAM,CAACW,IAAlD,CAAP;AAC/B,YAAIX,MAAM,CAACW,IAAP,CAAYV,MAAZ,KAAuB,EAA3B,EAA+B,OAAOR,UAAU,CAAC+C,iBAAX,CAA6BL,MAA7B,CAAoCT,MAApC,CAA2C1B,MAAM,CAACW,IAAlD,CAAP;AAChC;AACF;AACF;;AAED,QAAM,IAAI8B,KAAJ,CAAU3C,OAAO,GAAG,yBAApB,CAAN;AACD;;AAED+C,MAAM,CAACC,OAAP,GAAiB;AACfjD,EAAAA,eAAe,EAAEA,eADF;AAEfY,EAAAA,UAAU,EAAEA,UAFG;AAGfqB,EAAAA,gBAAgB,EAAEA,gBAHH;AAIfd,EAAAA,aAAa,EAAEA,aAJA;AAKfW,EAAAA,QAAQ,EAAEA,QALK;AAMfgB,EAAAA,cAAc,EAAEA;AAND,CAAjB","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar bech32 = require('bech32')\nvar bs58check = require('bs58check')\nvar bscript = require('./script')\nvar btemplates = require('./templates')\nvar networks = require('./networks')\nvar typeforce = require('typeforce')\nvar types = require('./types')\n\nfunction fromBase58Check (address) {\n  var payload = bs58check.decode(address)\n\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short')\n  if (payload.length > 22) throw new TypeError(address + ' is too long')\n\n  var multibyte = payload.length === 22\n  var offset = multibyte ? 2 : 1\n\n  var version = multibyte ? payload.readUInt16BE(0) : payload[0]\n  var hash = payload.slice(offset)\n\n  return { version: version, hash: hash }\n}\n\nfunction fromBech32 (address) {\n  var result = bech32.decode(address)\n  var data = bech32.fromWords(result.words.slice(1))\n\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  }\n}\n\nfunction toBase58Check (hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt16), arguments)\n\n  // Zcash adds an extra prefix resulting in a bigger (22 bytes) payload. We identify them Zcash by checking if the\n  // version is multibyte (2 bytes instead of 1)\n  var multibyte = version > 0xff\n  var size = multibyte ? 22 : 21\n  var offset = multibyte ? 2 : 1\n\n  var payload = Buffer.allocUnsafe(size)\n  multibyte ? payload.writeUInt16BE(version, 0) : payload.writeUInt8(version, 0)\n  hash.copy(payload, offset)\n\n  return bs58check.encode(payload)\n}\n\nfunction toBech32 (data, version, prefix) {\n  var words = bech32.toWords(data)\n  words.unshift(version)\n\n  return bech32.encode(prefix, words)\n}\n\nfunction fromOutputScript (outputScript, network) {\n  network = network || networks.bitcoin\n\n  if (btemplates.pubKeyHash.output.check(outputScript)) return toBase58Check(bscript.compile(outputScript).slice(3, 23), network.pubKeyHash)\n  if (btemplates.scriptHash.output.check(outputScript)) return toBase58Check(bscript.compile(outputScript).slice(2, 22), network.scriptHash)\n  if (btemplates.witnessPubKeyHash.output.check(outputScript)) return toBech32(bscript.compile(outputScript).slice(2, 22), 0, network.bech32)\n  if (btemplates.witnessScriptHash.output.check(outputScript)) return toBech32(bscript.compile(outputScript).slice(2, 34), 0, network.bech32)\n\n  throw new Error(bscript.toASM(outputScript) + ' has no matching Address')\n}\n\nfunction toOutputScript (address, network) {\n  network = network || networks.bitcoin\n\n  var decode\n  try {\n    decode = fromBase58Check(address)\n  } catch (e) {}\n\n  if (decode) {\n    if (decode.version === network.pubKeyHash) return btemplates.pubKeyHash.output.encode(decode.hash)\n    if (decode.version === network.scriptHash) return btemplates.scriptHash.output.encode(decode.hash)\n  } else {\n    try {\n      decode = fromBech32(address)\n    } catch (e) {}\n\n    if (decode) {\n      if (decode.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix')\n      if (decode.version === 0) {\n        if (decode.data.length === 20) return btemplates.witnessPubKeyHash.output.encode(decode.data)\n        if (decode.data.length === 32) return btemplates.witnessScriptHash.output.encode(decode.data)\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script')\n}\n\nmodule.exports = {\n  fromBase58Check: fromBase58Check,\n  fromBech32: fromBech32,\n  fromOutputScript: fromOutputScript,\n  toBase58Check: toBase58Check,\n  toBech32: toBech32,\n  toOutputScript: toOutputScript\n}\n"]},"metadata":{},"sourceType":"script"}