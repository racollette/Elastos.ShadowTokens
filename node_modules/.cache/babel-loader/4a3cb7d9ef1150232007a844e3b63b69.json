{"ast":null,"code":"/* eslint-disable */\nimport { getBufferFromHex, getSignTransactionObject, sanitizeHex, calculateChainIdFromV } from './utils';\nimport { hashPersonalMessage, publicToAddress, bufferToHex, ecsign, isValidPrivate, isValidPublic, privateToPublic, isHexString, toBuffer as utilsToBuffer } from 'ethereumjs-util';\nimport commonGenerator from './helpers/commonGenerator';\nimport { Transaction } from 'ethereumjs-tx';\nimport { toChecksumAddress } from './helpers/addressUtils';\nimport Networks from './networks/index';\n\nconst toBuffer = v => {\n  if (isHexString(v)) {\n    return utilsToBuffer(v);\n  }\n\n  return Buffer.from(v);\n};\n\nclass WalletInterface {\n  constructor(key, isPub = false, identifier, nick, keystore) {\n    this.nickname = nick !== null && nick !== '' ? nick : '';\n    this.keystore = keystore !== null && keystore !== '' ? keystore : '';\n    this.identifier = identifier;\n\n    if (!isPub) {\n      const _privKey = Buffer.isBuffer(key) ? key : getBufferFromHex(sanitizeHex(key));\n\n      if (!isValidPrivate(_privKey)) throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');\n      this.privateKey = _privKey;\n      this.publicKey = privateToPublic(_privKey);\n      this.isPubOnly = false;\n    } else {\n      const _pubKey = Buffer.isBuffer(key) ? key : getBufferFromHex(key);\n\n      if (_pubKey.length !== 20 && !isValidPublic(_pubKey, true)) throw new Error('Invalid public key');\n      if (_pubKey.length === 20) this.isAddress = true;\n      this.publicKey = _pubKey;\n      this.isPubOnly = true;\n    }\n  }\n\n  getPrivateKey() {\n    if (this.isPubOnly) throw new Error('public key only wallet');\n    return this.privateKey;\n  }\n\n  getPrivateKeyString() {\n    if (this.isPubOnly) throw new Error('public key only wallet');\n    return bufferToHex(this.getPrivateKey());\n  }\n\n  getNickname() {\n    if (this.nickname === '') return '';\n    return this.nickname;\n  }\n\n  getKeystore() {\n    if (this.keystore === '') return '';\n    return this.keystore;\n  }\n\n  getPublicKey() {\n    if (this.isAddress) throw new Error('Address only wallet');\n    return this.publicKey;\n  }\n\n  getPublicKeyString() {\n    return bufferToHex(this.getPublicKey());\n  }\n\n  getAddress() {\n    if (this.isAddress) return this.publicKey;\n    return publicToAddress(this.publicKey, true);\n  }\n\n  getAddressString() {\n    return bufferToHex(this.getAddress());\n  }\n\n  getChecksumAddressString() {\n    return toChecksumAddress(this.getAddressString());\n  }\n\n  signTransaction(txParams, signer) {\n    if (this.isPubOnly && typeof signer !== 'function') throw new Error('public key only wallets needs a signer');\n    return new Promise((resolve, reject) => {\n      signer(txParams).then(resolve).catch(reject); // }\n    });\n  }\n\n  signMessage(msg, signer) {\n    if (this.isPubOnly && typeof signer !== 'function') throw new Error('public key only wallets needs a signer');\n    return new Promise((resolve, reject) => {\n      if (!this.isPubOnly) {\n        const msgHash = hashPersonalMessage(toBuffer(msg));\n        const signed = ecsign(msgHash, this.privateKey);\n        resolve(Buffer.concat([Buffer.from(signed.r), Buffer.from(signed.s), Buffer.from([signed.v])]));\n      } else {\n        signer(msg).then(resolve).catch(reject);\n      }\n    });\n  }\n\n}\n\nexport default WalletInterface;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/@myetherwallet/mewconnect-web-client/src/connectProvider/web3Provider/WalletInterface.js"],"names":["getBufferFromHex","getSignTransactionObject","sanitizeHex","calculateChainIdFromV","hashPersonalMessage","publicToAddress","bufferToHex","ecsign","isValidPrivate","isValidPublic","privateToPublic","isHexString","toBuffer","utilsToBuffer","commonGenerator","Transaction","toChecksumAddress","Networks","v","Buffer","from","WalletInterface","constructor","key","isPub","identifier","nick","keystore","nickname","_privKey","isBuffer","Error","privateKey","publicKey","isPubOnly","_pubKey","length","isAddress","getPrivateKey","getPrivateKeyString","getNickname","getKeystore","getPublicKey","getPublicKeyString","getAddress","getAddressString","getChecksumAddressString","signTransaction","txParams","signer","Promise","resolve","reject","then","catch","signMessage","msg","msgHash","signed","concat","r","s"],"mappings":"AAAA;AAEA,SACEA,gBADF,EAEEC,wBAFF,EAGEC,WAHF,EAIEC,qBAJF,QAKO,SALP;AAMA,SACEC,mBADF,EAEEC,eAFF,EAGEC,WAHF,EAIEC,MAJF,EAKEC,cALF,EAMEC,aANF,EAOEC,eAPF,EAQEC,WARF,EASEC,QAAQ,IAAIC,aATd,QAUO,iBAVP;AAWA,OAAOC,eAAP,MAA4B,2BAA5B;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA,OAAOC,QAAP,MAAqB,kBAArB;;AAEA,MAAML,QAAQ,GAAGM,CAAC,IAAI;AACpB,MAAIP,WAAW,CAACO,CAAD,CAAf,EAAoB;AAClB,WAAOL,aAAa,CAACK,CAAD,CAApB;AACD;;AACD,SAAOC,MAAM,CAACC,IAAP,CAAYF,CAAZ,CAAP;AACD,CALD;;AAOA,MAAMG,eAAN,CAAsB;AACpBC,EAAAA,WAAW,CAACC,GAAD,EAAMC,KAAK,GAAG,KAAd,EAAqBC,UAArB,EAAiCC,IAAjC,EAAuCC,QAAvC,EAAiD;AAC1D,SAAKC,QAAL,GAAgBF,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,EAA1B,GAA+BA,IAA/B,GAAsC,EAAtD;AACA,SAAKC,QAAL,GAAgBA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,EAAlC,GAAuCA,QAAvC,GAAkD,EAAlE;AACA,SAAKF,UAAL,GAAkBA,UAAlB;;AACA,QAAI,CAACD,KAAL,EAAY;AACV,YAAMK,QAAQ,GAAGV,MAAM,CAACW,QAAP,CAAgBP,GAAhB,IACbA,GADa,GAEbvB,gBAAgB,CAACE,WAAW,CAACqB,GAAD,CAAZ,CAFpB;;AAGA,UAAI,CAACf,cAAc,CAACqB,QAAD,CAAnB,EACE,MAAM,IAAIE,KAAJ,CACJ,yEADI,CAAN;AAGF,WAAKC,UAAL,GAAkBH,QAAlB;AACA,WAAKI,SAAL,GAAiBvB,eAAe,CAACmB,QAAD,CAAhC;AACA,WAAKK,SAAL,GAAiB,KAAjB;AACD,KAXD,MAWO;AACL,YAAMC,OAAO,GAAGhB,MAAM,CAACW,QAAP,CAAgBP,GAAhB,IAAuBA,GAAvB,GAA6BvB,gBAAgB,CAACuB,GAAD,CAA7D;;AACA,UAAIY,OAAO,CAACC,MAAR,KAAmB,EAAnB,IAAyB,CAAC3B,aAAa,CAAC0B,OAAD,EAAU,IAAV,CAA3C,EACE,MAAM,IAAIJ,KAAJ,CAAU,oBAAV,CAAN;AACF,UAAII,OAAO,CAACC,MAAR,KAAmB,EAAvB,EAA2B,KAAKC,SAAL,GAAiB,IAAjB;AAC3B,WAAKJ,SAAL,GAAiBE,OAAjB;AACA,WAAKD,SAAL,GAAiB,IAAjB;AACD;AACF;;AAEDI,EAAAA,aAAa,GAAG;AACd,QAAI,KAAKJ,SAAT,EAAoB,MAAM,IAAIH,KAAJ,CAAU,wBAAV,CAAN;AACpB,WAAO,KAAKC,UAAZ;AACD;;AAEDO,EAAAA,mBAAmB,GAAG;AACpB,QAAI,KAAKL,SAAT,EAAoB,MAAM,IAAIH,KAAJ,CAAU,wBAAV,CAAN;AACpB,WAAOzB,WAAW,CAAC,KAAKgC,aAAL,EAAD,CAAlB;AACD;;AAEDE,EAAAA,WAAW,GAAG;AACZ,QAAI,KAAKZ,QAAL,KAAkB,EAAtB,EAA0B,OAAO,EAAP;AAC1B,WAAO,KAAKA,QAAZ;AACD;;AAEDa,EAAAA,WAAW,GAAG;AACZ,QAAI,KAAKd,QAAL,KAAkB,EAAtB,EAA0B,OAAO,EAAP;AAC1B,WAAO,KAAKA,QAAZ;AACD;;AAEDe,EAAAA,YAAY,GAAG;AACb,QAAI,KAAKL,SAAT,EAAoB,MAAM,IAAIN,KAAJ,CAAU,qBAAV,CAAN;AACpB,WAAO,KAAKE,SAAZ;AACD;;AAEDU,EAAAA,kBAAkB,GAAG;AACnB,WAAOrC,WAAW,CAAC,KAAKoC,YAAL,EAAD,CAAlB;AACD;;AAEDE,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKP,SAAT,EAAoB,OAAO,KAAKJ,SAAZ;AACpB,WAAO5B,eAAe,CAAC,KAAK4B,SAAN,EAAiB,IAAjB,CAAtB;AACD;;AAEDY,EAAAA,gBAAgB,GAAG;AACjB,WAAOvC,WAAW,CAAC,KAAKsC,UAAL,EAAD,CAAlB;AACD;;AAEDE,EAAAA,wBAAwB,GAAG;AACzB,WAAO9B,iBAAiB,CAAC,KAAK6B,gBAAL,EAAD,CAAxB;AACD;;AAEDE,EAAAA,eAAe,CAACC,QAAD,EAAWC,MAAX,EAAmB;AAChC,QAAI,KAAKf,SAAL,IAAkB,OAAOe,MAAP,KAAkB,UAAxC,EACE,MAAM,IAAIlB,KAAJ,CAAU,wCAAV,CAAN;AACF,WAAO,IAAImB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCH,MAAAA,MAAM,CAACD,QAAD,CAAN,CACGK,IADH,CACQF,OADR,EAEGG,KAFH,CAESF,MAFT,EADoC,CAItC;AACD,KALM,CAAP;AAMD;;AAEDG,EAAAA,WAAW,CAACC,GAAD,EAAMP,MAAN,EAAc;AACvB,QAAI,KAAKf,SAAL,IAAkB,OAAOe,MAAP,KAAkB,UAAxC,EACE,MAAM,IAAIlB,KAAJ,CAAU,wCAAV,CAAN;AACF,WAAO,IAAImB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAI,CAAC,KAAKlB,SAAV,EAAqB;AACnB,cAAMuB,OAAO,GAAGrD,mBAAmB,CAACQ,QAAQ,CAAC4C,GAAD,CAAT,CAAnC;AACA,cAAME,MAAM,GAAGnD,MAAM,CAACkD,OAAD,EAAU,KAAKzB,UAAf,CAArB;AACAmB,QAAAA,OAAO,CACLhC,MAAM,CAACwC,MAAP,CAAc,CACZxC,MAAM,CAACC,IAAP,CAAYsC,MAAM,CAACE,CAAnB,CADY,EAEZzC,MAAM,CAACC,IAAP,CAAYsC,MAAM,CAACG,CAAnB,CAFY,EAGZ1C,MAAM,CAACC,IAAP,CAAY,CAACsC,MAAM,CAACxC,CAAR,CAAZ,CAHY,CAAd,CADK,CAAP;AAOD,OAVD,MAUO;AACL+B,QAAAA,MAAM,CAACO,GAAD,CAAN,CACGH,IADH,CACQF,OADR,EAEGG,KAFH,CAESF,MAFT;AAGD;AACF,KAhBM,CAAP;AAiBD;;AAnGmB;;AAsGtB,eAAe/B,eAAf","sourcesContent":["/* eslint-disable */\n\nimport {\n  getBufferFromHex,\n  getSignTransactionObject,\n  sanitizeHex,\n  calculateChainIdFromV\n} from './utils';\nimport {\n  hashPersonalMessage,\n  publicToAddress,\n  bufferToHex,\n  ecsign,\n  isValidPrivate,\n  isValidPublic,\n  privateToPublic,\n  isHexString,\n  toBuffer as utilsToBuffer\n} from 'ethereumjs-util';\nimport commonGenerator from './helpers/commonGenerator';\nimport { Transaction } from 'ethereumjs-tx';\nimport { toChecksumAddress } from './helpers/addressUtils';\nimport Networks from './networks/index';\n\nconst toBuffer = v => {\n  if (isHexString(v)) {\n    return utilsToBuffer(v);\n  }\n  return Buffer.from(v);\n};\n\nclass WalletInterface {\n  constructor(key, isPub = false, identifier, nick, keystore) {\n    this.nickname = nick !== null && nick !== '' ? nick : '';\n    this.keystore = keystore !== null && keystore !== '' ? keystore : '';\n    this.identifier = identifier;\n    if (!isPub) {\n      const _privKey = Buffer.isBuffer(key)\n        ? key\n        : getBufferFromHex(sanitizeHex(key));\n      if (!isValidPrivate(_privKey))\n        throw new Error(\n          'Private key does not satisfy the curve requirements (ie. it is invalid)'\n        );\n      this.privateKey = _privKey;\n      this.publicKey = privateToPublic(_privKey);\n      this.isPubOnly = false;\n    } else {\n      const _pubKey = Buffer.isBuffer(key) ? key : getBufferFromHex(key);\n      if (_pubKey.length !== 20 && !isValidPublic(_pubKey, true))\n        throw new Error('Invalid public key');\n      if (_pubKey.length === 20) this.isAddress = true;\n      this.publicKey = _pubKey;\n      this.isPubOnly = true;\n    }\n  }\n\n  getPrivateKey() {\n    if (this.isPubOnly) throw new Error('public key only wallet');\n    return this.privateKey;\n  }\n\n  getPrivateKeyString() {\n    if (this.isPubOnly) throw new Error('public key only wallet');\n    return bufferToHex(this.getPrivateKey());\n  }\n\n  getNickname() {\n    if (this.nickname === '') return '';\n    return this.nickname;\n  }\n\n  getKeystore() {\n    if (this.keystore === '') return '';\n    return this.keystore;\n  }\n\n  getPublicKey() {\n    if (this.isAddress) throw new Error('Address only wallet');\n    return this.publicKey;\n  }\n\n  getPublicKeyString() {\n    return bufferToHex(this.getPublicKey());\n  }\n\n  getAddress() {\n    if (this.isAddress) return this.publicKey;\n    return publicToAddress(this.publicKey, true);\n  }\n\n  getAddressString() {\n    return bufferToHex(this.getAddress());\n  }\n\n  getChecksumAddressString() {\n    return toChecksumAddress(this.getAddressString());\n  }\n\n  signTransaction(txParams, signer) {\n    if (this.isPubOnly && typeof signer !== 'function')\n      throw new Error('public key only wallets needs a signer');\n    return new Promise((resolve, reject) => {\n        signer(txParams)\n          .then(resolve)\n          .catch(reject);\n      // }\n    });\n  }\n\n  signMessage(msg, signer) {\n    if (this.isPubOnly && typeof signer !== 'function')\n      throw new Error('public key only wallets needs a signer');\n    return new Promise((resolve, reject) => {\n      if (!this.isPubOnly) {\n        const msgHash = hashPersonalMessage(toBuffer(msg));\n        const signed = ecsign(msgHash, this.privateKey);\n        resolve(\n          Buffer.concat([\n            Buffer.from(signed.r),\n            Buffer.from(signed.s),\n            Buffer.from([signed.v])\n          ])\n        );\n      } else {\n        signer(msg)\n          .then(resolve)\n          .catch(reject);\n      }\n    });\n  }\n}\n\nexport default WalletInterface;\n"]},"metadata":{},"sourceType":"module"}