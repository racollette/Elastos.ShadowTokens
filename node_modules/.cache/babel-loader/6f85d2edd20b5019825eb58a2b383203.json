{"ast":null,"code":"'use strict';\n\nvar Address = require('../address');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar Hash = require('../crypto/hash');\n\nvar Opcode = require('../opcode');\n\nvar PublicKey = require('../publickey');\n\nvar Signature = require('../crypto/signature');\n\nvar Networks = require('../networks');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n\nvar errors = require('../errors');\n\nvar buffer = require('buffer');\n\nvar BufferUtil = require('../util/buffer');\n\nvar JSUtil = require('../util/js');\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\n\n\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (_.isString(from)) {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && _.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\n\nScript.prototype.set = function (obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(_.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\n\nScript.fromBuffer = function (buffer) {\n  var script = new Script();\n  script.chunks = [];\n  var br = new BufferReader(buffer);\n\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n      var len, buf;\n\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function () {\n  var bw = new BufferWriter();\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      }\n    }\n  }\n\n  return bw.concat();\n};\n\nScript.fromASM = function (str) {\n  var script = new Script();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n\n  return script;\n};\n\nScript.fromHex = function (str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function (str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n\n  var script = new Script();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      opcodenum = parseInt(token);\n\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype._chunkToString = function (chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = type === 'asm';\n  var str = '';\n\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if (opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n\n  return str;\n};\n\nScript.prototype.toASM = function () {\n  var str = '';\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toString = function () {\n  var str = '';\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function () {\n  return '<Script: ' + this.toString() + '>';\n}; // script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\n\n\nScript.prototype.isPublicKeyHashOut = function () {\n  return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\n\n\nScript.prototype.isPublicKeyHashIn = function () {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30 && pubkeyBuf && pubkeyBuf.length) {\n      var version = pubkeyBuf[0];\n\n      if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nScript.prototype.getPublicKey = function () {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function () {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n/**\n * @returns {boolean} if this is a public key output script\n */\n\n\nScript.prototype.isPublicKeyOut = function () {\n  if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n\n    if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\n\n\nScript.prototype.isPublicKeyIn = function () {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a p2sh output script\n */\n\n\nScript.prototype.isScriptHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 0x14 && buf[buf.length - 1] === Opcode.OP_EQUAL;\n};\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\n\n\nScript.prototype.isWitnessScriptHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 34 && buf[0] === 0 && buf[1] === 32;\n};\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\n\n\nScript.prototype.isWitnessPublicKeyHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 22 && buf[0] === 0 && buf[1] === 20;\n};\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\n\n\nScript.prototype.isWitnessProgram = function (values) {\n  if (!values) {\n    values = {};\n  }\n\n  var buf = this.toBuffer();\n\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n\n  if (buf.length === buf[1] + 2) {\n    values.version = buf[0];\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n\n  return false;\n};\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\n\n\nScript.prototype.isScriptHashIn = function () {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n\n    throw e;\n  }\n\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\n\n\nScript.prototype.isMultisigOut = function () {\n  return this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function (obj) {\n    return obj.buf && BufferUtil.isBuffer(obj.buf);\n  }) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG;\n};\n/**\n * @returns {boolean} if this is a multisig input script\n */\n\n\nScript.prototype.isMultisigIn = function () {\n  return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(function (obj) {\n    return obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf);\n  });\n};\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\n\n\nScript.prototype.isDataOut = function () {\n  return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len);\n};\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\n\n\nScript.prototype.getData = function () {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut()) {\n    if (_.isUndefined(this.chunks[1])) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n\n  throw new Error('Unrecognized script type to get data from');\n};\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\n\n\nScript.prototype.isPushOnly = function () {\n  return _.every(this.chunks, function (chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\nScript.OP_RETURN_STANDARD_SIZE = 80;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classify = function () {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classifyOutput = function () {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\n\nScript.prototype.classifyInput = function () {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n\n  return Script.types.UNKNOWN;\n};\n/**\n * @returns {boolean} if script is one of the known types\n */\n\n\nScript.prototype.isStandard = function () {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n}; // Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\n\n\nScript.prototype.prepend = function (obj) {\n  this._addByType(obj, true);\n\n  return this;\n};\n/**\n * Compares a script with another script\n */\n\n\nScript.prototype.equals = function (script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n\n  var i;\n\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\n\n\nScript.prototype.add = function (obj) {\n  this._addByType(obj, false);\n\n  return this;\n};\n\nScript.prototype._addByType = function (obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function (op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function (opcode, prepend) {\n  var op;\n\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n\n  return this;\n};\n\nScript.prototype._addBuffer = function (buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n\n  return this;\n};\n\nScript.prototype.hasCodeseparators = function () {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nScript.prototype.removeCodeseparators = function () {\n  var chunks = [];\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n\n  this.chunks = chunks;\n  return this;\n}; // high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\n\n\nScript.buildMultisigOut = function (publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length, 'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = _.map(publicKeys, PublicKey);\n  var sorted = publicKeys;\n\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function (publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n\nScript.buildWitnessMultisigOutFromScript = function (script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\n\n\nScript.buildMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n\n  _.each(signatures, function (signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects\n\n    s.add(signature);\n  });\n\n  return s;\n};\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\n\n\nScript.buildP2SHMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n\n  _.each(signatures, function (signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects\n\n    s.add(signature);\n  });\n\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\n\n\nScript.buildPublicKeyHashOut = function (to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n\n  var s = new Script();\n  s.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(to.hashBuffer).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\n\n\nScript.buildWitnessV0Out = function (to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n\n  var s = new Script();\n  s.add(Opcode.OP_0).add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\n\n\nScript.buildPublicKeyOut = function (pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer()).add(Opcode.OP_CHECKSIG);\n  return s;\n};\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\n\n\nScript.buildDataOut = function (data, encoding) {\n  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));\n\n  if (_.isString(data)) {\n    data = Buffer.from(data, encoding);\n  }\n\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n\n  if (!_.isUndefined(data)) {\n    s.add(data);\n  }\n\n  return s;\n};\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\n\n\nScript.buildScriptHashOut = function (script) {\n  $.checkArgument(script instanceof Script || script instanceof Address && script.isPayToScriptHash());\n  var s = new Script();\n  s.add(Opcode.OP_HASH160).add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer())).add(Opcode.OP_EQUAL);\n  s._network = script._network || script.network;\n  return s;\n};\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\n\n\nScript.buildPublicKeyIn = function (signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n\n  var script = new Script();\n  script.add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)]));\n  return script;\n};\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\n\n\nScript.buildPublicKeyHashIn = function (publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n\n  var script = new Script().add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)])).add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n/**\n * @returns {Script} an empty script\n */\n\n\nScript.empty = function () {\n  return new Script();\n};\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\n\n\nScript.prototype.toScriptHashOut = function () {\n  return Script.buildScriptHashOut(this);\n};\n/**\n * @return {Script} an output script built from the address\n */\n\n\nScript.fromAddress = function (address) {\n  address = Address(address);\n\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  }\n\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\n\n\nScript.prototype.getAddressInfo = function (opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n\n    return info;\n  }\n};\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\n\n\nScript.prototype._getOutputAddressInfo = function () {\n  var info = {};\n\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else {\n    return false;\n  }\n\n  return info;\n};\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\n\n\nScript.prototype._getInputAddressInfo = function () {\n  var info = {};\n\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n\n  return info;\n};\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\n\n\nScript.prototype.toAddress = function (network) {\n  var info = this.getAddressInfo();\n\n  if (!info) {\n    return false;\n  }\n\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\n\n\nScript.prototype.findAndDelete = function (script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n\n  return this;\n};\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\n\n\nScript.prototype.checkMinimalPush = function (i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n\n  if (!buf) {\n    return true;\n  }\n\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n\n  return true;\n};\n/**\n * Comes from bitcoind's script DecodeOP_N function\n * @param {number} opcode\n * @returns {number} numeric value in range of 0 to 16\n */\n\n\nScript.prototype._decodeOP_N = function (opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {\n    return opcode - (Opcode.OP_1 - 1);\n  } else {\n    throw new Error('Invalid opcode: ' + JSON.stringify(opcode));\n  }\n};\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\n\n\nScript.prototype.getSignatureOperationsCount = function (accurate) {\n  accurate = _.isUndefined(accurate) ? true : accurate;\n  var self = this;\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n\n  _.each(self.chunks, function getChunk(chunk) {\n    var opcode = chunk.opcodenum;\n\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += self._decodeOP_N(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n\n    lastOpcode = opcode;\n  });\n\n  return n;\n};\n\nmodule.exports = Script;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitcore-lib/lib/script/script.js"],"names":["Address","require","BufferReader","BufferWriter","Hash","Opcode","PublicKey","Signature","Networks","$","_","errors","buffer","BufferUtil","JSUtil","Script","from","chunks","isBuffer","fromBuffer","fromAddress","toBuffer","isString","fromString","isObject","isArray","set","prototype","obj","checkArgument","script","br","finished","opcodenum","readUInt8","len","buf","OP_PUSHDATA1","push","read","OP_PUSHDATA2","readUInt16LE","OP_PUSHDATA4","readUInt32LE","e","RangeError","InvalidBuffer","toString","bw","i","length","chunk","writeUInt8","write","writeUInt16LE","writeUInt32LE","concat","fromASM","str","tokens","split","token","opcode","toNumber","isUndefined","Buffer","parseInt","fromHex","isHexa","slice","Error","JSON","stringify","_chunkToString","type","asm","reverseMap","numstr","toASM","substr","toHex","inspect","isPublicKeyHashOut","OP_DUP","OP_HASH160","OP_EQUALVERIFY","OP_CHECKSIG","isPublicKeyHashIn","signatureBuf","pubkeyBuf","version","getPublicKey","checkState","isPublicKeyOut","getPublicKeyHash","isWitnessPublicKeyHashOut","isVersion","isValid","isPublicKeyIn","isScriptHashOut","OP_EQUAL","isWitnessScriptHashOut","isWitnessProgram","values","OP_0","OP_1","OP_16","program","isScriptHashIn","redeemChunk","redeemBuf","redeemScript","classify","types","UNKNOWN","isMultisigOut","isSmallIntOp","every","OP_CHECKMULTISIG","isMultisigIn","isTxDER","isDataOut","OP_RETURN","OP_RETURN_STANDARD_SIZE","getData","alloc","isPushOnly","PUBKEY_OUT","PUBKEY_IN","PUBKEYHASH_OUT","PUBKEYHASH_IN","SCRIPTHASH_OUT","SCRIPTHASH_IN","MULTISIG_OUT","MULTISIG_IN","DATA_OUT","_isInput","classifyInput","_isOutput","classifyOutput","outputType","outputIdentifiers","bind","inputIdentifiers","isStandard","prepend","_addByType","equals","add","_addOpcode","_addBuffer","_insertAtPosition","op","unshift","Math","pow","hasCodeseparators","OP_CODESEPARATOR","removeCodeseparators","buildMultisigOut","publicKeys","threshold","opts","smallInt","map","sorted","noSorting","sortBy","publicKey","buildWitnessMultisigOutFromScript","s","sha256","TypeError","buildMultisigIn","pubkeys","signatures","isNumber","each","signature","buildP2SHMultisigIn","cachedMultisig","buildPublicKeyHashOut","to","toAddress","hashBuffer","_network","network","buildWitnessV0Out","PayToWitnessPublicKeyHash","buildPublicKeyOut","pubkey","buildDataOut","data","encoding","buildScriptHashOut","isPayToScriptHash","sha256ripemd160","buildPublicKeyIn","sigtype","integerAsSingleByteBuffer","SIGHASH_ALL","buildPublicKeyHashIn","empty","toScriptHashOut","address","isPayToPublicKeyHash","isPayToWitnessPublicKeyHash","isPayToWitnessScriptHash","UnrecognizedAddress","getAddressInfo","_getInputAddressInfo","_getOutputAddressInfo","info","PayToScriptHash","PayToPublicKeyHash","PayToWitnessScriptHash","get","defaultNetwork","findAndDelete","hex","script2","buf2","hex2","splice","checkMinimalPush","OP_1NEGATE","_decodeOP_N","getSignatureOperationsCount","accurate","self","n","lastOpcode","OP_INVALIDOPCODE","getChunk","OP_CHECKSIGVERIFY","OP_CHECKMULTISIGVERIFY","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Address = require('../address');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Opcode = require('../opcode');\nvar PublicKey = require('../publickey');\nvar Signature = require('../crypto/signature');\nvar Networks = require('../networks');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nvar errors = require('../errors');\nvar buffer = require('buffer');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (_.isString(from)) {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && _.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\n\nScript.prototype.set = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(_.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\n\nScript.fromBuffer = function(buffer) {\n  var script = new Script();\n  script.chunks = [];\n\n  var br = new BufferReader(buffer);\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n\n      var len, buf;\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function() {\n  var bw = new BufferWriter();\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      }\n    }\n  }\n\n  return bw.concat();\n};\n\nScript.fromASM = function(str) {\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.fromHex = function(str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function(str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      opcodenum = parseInt(token);\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.prototype._chunkToString = function(chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = (type === 'asm');\n  var str = '';\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if(opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n  return str;\n};\n\nScript.prototype.toASM = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toString = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toHex = function() {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function() {\n  return '<Script: ' + this.toString() + '>';\n};\n\n// script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\nScript.prototype.isPublicKeyHashOut = function() {\n  return !!(this.chunks.length === 5 &&\n    this.chunks[0].opcodenum === Opcode.OP_DUP &&\n    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&\n    this.chunks[2].buf &&\n    this.chunks[2].buf.length === 20 &&\n    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&\n    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\nScript.prototype.isPublicKeyHashIn = function() {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30 &&\n        pubkeyBuf &&\n        pubkeyBuf.length\n       ) {\n      var version = pubkeyBuf[0];\n      if ((version === 0x04 ||\n           version === 0x06 ||\n           version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nScript.prototype.getPublicKey = function() {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function() {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n\n/**\n * @returns {boolean} if this is a public key output script\n */\nScript.prototype.isPublicKeyOut = function() {\n  if (this.chunks.length === 2 &&\n      this.chunks[0].buf &&\n      this.chunks[0].buf.length &&\n      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n    if ((version === 0x04 ||\n         version === 0x06 ||\n         version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\nScript.prototype.isPublicKeyIn = function() {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh output script\n */\nScript.prototype.isScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 23 &&\n    buf[0] === Opcode.OP_HASH160 &&\n    buf[1] === 0x14 &&\n    buf[buf.length - 1] === Opcode.OP_EQUAL);\n};\n\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\nScript.prototype.isWitnessScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === 0 && buf[1] === 32);\n};\n\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessPublicKeyHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 22 && buf[0] === 0 && buf[1] === 20);\n};\n\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessProgram = function(values) {\n  if (!values) {\n    values = {};\n  }\n  var buf = this.toBuffer();\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n\n  if (buf.length === buf[1] + 2) {\n    values.version = buf[0];\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\nScript.prototype.isScriptHashIn = function() {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n    throw e;\n  }\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\nScript.prototype.isMultisigOut = function() {\n  return (this.chunks.length > 3 &&\n    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&\n    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {\n      return obj.buf && BufferUtil.isBuffer(obj.buf);\n    }) &&\n    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&\n    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);\n};\n\n\n/**\n * @returns {boolean} if this is a multisig input script\n */\nScript.prototype.isMultisigIn = function() {\n  return this.chunks.length >= 2 &&\n    this.chunks[0].opcodenum === 0 &&\n    this.chunks.slice(1, this.chunks.length).every(function(obj) {\n      return obj.buf &&\n        BufferUtil.isBuffer(obj.buf) &&\n        Signature.isTxDER(obj.buf);\n    });\n};\n\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\nScript.prototype.isDataOut = function() {\n  return this.chunks.length >= 1 &&\n    this.chunks[0].opcodenum === Opcode.OP_RETURN &&\n    (this.chunks.length === 1 ||\n      (this.chunks.length === 2 &&\n        this.chunks[1].buf &&\n        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&\n        this.chunks[1].length === this.chunks.len));\n};\n\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\nScript.prototype.getData = function() {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut()) {\n    if (_.isUndefined(this.chunks[1])) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n  throw new Error('Unrecognized script type to get data from');\n};\n\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\nScript.prototype.isPushOnly = function() {\n  return _.every(this.chunks, function(chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\n\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\n\nScript.OP_RETURN_STANDARD_SIZE = 80;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classify = function() {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyOutput = function() {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyInput = function() {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\n\n/**\n * @returns {boolean} if script is one of the known types\n */\nScript.prototype.isStandard = function() {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n};\n\n\n// Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\nScript.prototype.prepend = function(obj) {\n  this._addByType(obj, true);\n  return this;\n};\n\n/**\n * Compares a script with another script\n */\nScript.prototype.equals = function(script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n  var i;\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\nScript.prototype.add = function(obj) {\n  this._addByType(obj, false);\n  return this;\n};\n\nScript.prototype._addByType = function(obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function(op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function(opcode, prepend) {\n  var op;\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n  return this;\n};\n\nScript.prototype._addBuffer = function(buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n  return this;\n};\n\nScript.prototype.hasCodeseparators = function() {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n  return false;\n};\n\nScript.prototype.removeCodeseparators = function() {\n  var chunks = [];\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n  this.chunks = chunks;\n  return this;\n};\n\n// high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\nScript.buildMultisigOut = function(publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length,\n    'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = _.map(publicKeys, PublicKey);\n  var sorted = publicKeys;\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function(publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n\nScript.buildWitnessMultisigOutFromScript = function(script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  _.each(signatures, function(signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  });\n  return s;\n};\n\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  _.each(signatures, function(signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  });\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\nScript.buildPublicKeyHashOut = function(to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_DUP)\n    .add(Opcode.OP_HASH160)\n    .add(to.hashBuffer)\n    .add(Opcode.OP_EQUALVERIFY)\n    .add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\nScript.buildWitnessV0Out = function(to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_0)\n    .add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\nScript.buildPublicKeyOut = function(pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer())\n    .add(Opcode.OP_CHECKSIG);\n  return s;\n};\n\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\nScript.buildDataOut = function(data, encoding) {\n  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));\n  if (_.isString(data)) {\n    data = Buffer.from(data, encoding);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n  if (!_.isUndefined(data)) {\n    s.add(data);\n  }\n  return s;\n};\n\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\nScript.buildScriptHashOut = function(script) {\n  $.checkArgument(script instanceof Script ||\n    (script instanceof Address && script.isPayToScriptHash()));\n  var s = new Script();\n  s.add(Opcode.OP_HASH160)\n    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))\n    .add(Opcode.OP_EQUAL);\n\n  s._network = script._network || script.network;\n  return s;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyIn = function(signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script();\n  script.add(BufferUtil.concat([\n    signature,\n    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n  ]));\n  return script;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script()\n    .add(BufferUtil.concat([\n      signature,\n      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n    ]))\n    .add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n\n/**\n * @returns {Script} an empty script\n */\nScript.empty = function() {\n  return new Script();\n};\n\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\nScript.prototype.toScriptHashOut = function() {\n  return Script.buildScriptHashOut(this);\n};\n\n/**\n * @return {Script} an output script built from the address\n */\nScript.fromAddress = function(address) {\n  address = Address(address);\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  }\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\nScript.prototype.getAddressInfo = function(opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n    return info;\n  }\n};\n\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getOutputAddressInfo = function() {\n  var info = {};\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getInputAddressInfo = function() {\n  var info = {};\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\nScript.prototype.toAddress = function(network) {\n  var info = this.getAddressInfo();\n  if (!info) {\n    return false;\n  }\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\nScript.prototype.findAndDelete = function(script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n  return this;\n};\n\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\nScript.prototype.checkMinimalPush = function(i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n  if (!buf) {\n    return true;\n  }\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n  return true;\n};\n\n/**\n * Comes from bitcoind's script DecodeOP_N function\n * @param {number} opcode\n * @returns {number} numeric value in range of 0 to 16\n */\nScript.prototype._decodeOP_N = function(opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {\n    return opcode - (Opcode.OP_1 - 1);\n  } else {\n    throw new Error('Invalid opcode: ' + JSON.stringify(opcode));\n  }\n};\n\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\nScript.prototype.getSignatureOperationsCount = function(accurate) {\n  accurate = (_.isUndefined(accurate) ? true : accurate);\n  var self = this;\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  _.each(self.chunks, function getChunk(chunk) {\n    var opcode = chunk.opcodenum;\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += self._decodeOP_N(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n    lastOpcode = opcode;\n  });\n  return n;\n};\n\nmodule.exports = Script;\n"]},"metadata":{},"sourceType":"script"}