{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar HDPrivateKey = require('./hdprivatekey');\n\nvar Network = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\n\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\n\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\n\nvar BufferUtil = require('./util/buffer');\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\n\n\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey;\n\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function (path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\n\n\nHDPublicKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n\n  return null;\n};\n\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey, 'hex') : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\n\n\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network: network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\n\n\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\n\n\nHDPublicKey.prototype.inspect = function () {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\n\n\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\n\n\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\n\n\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nmodule.exports = HDPublicKey;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib/lib/hdpublickey.js"],"names":["_","require","$","BN","Base58","Base58Check","Hash","HDPrivateKey","Network","Point","PublicKey","bitcoreErrors","errors","hdErrors","HDPublicKey","assert","JSUtil","BufferUtil","arg","isString","isBuffer","error","getSerializedError","_buildFromSerialized","toString","ArgumentIsPrivateExtended","hdPublicKey","isObject","_buildFromPrivate","_buildFromObject","UnrecognizedArgument","MustSupplyArgument","isValidPath","indexes","_getDerivationIndexes","every","isNumber","Hardened","prototype","derive","hardened","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","index","InvalidIndexCantDeriveHardened","InvalidPath","indexBuffer","integerAsBuffer","data","concat","publicKey","toBuffer","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","slice","size","fromPoint","getG","mul","add","point","e","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","path","includes","reduce","prev","isValidSerialized","isNull","validCharacters","InvalidB58Char","decode","InvalidB58Checksum","length","DataSize","InvalidLength","isUndefined","_validateNetwork","version","integerFromBuffer","livenet","xprivkey","testnet","networkArg","get","InvalidNetworkArgument","VersionStart","VersionEnd","xpubkey","InvalidNetwork","args","clone","privateKey","pointToCompressed","undefined","checksum","_buildFromBuffers","buffers","integerAsSingleByteBuffer","Buffer","from","decoded","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PublicKeyStart","PublicKeyEnd","ChecksumStart","ChecksumEnd","_validateBufferArguments","defineImmutable","sequence","encode","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PublicKeySize","CheckSumSize","fromString","checkArgument","fromObject","inspect","toObject","toJSON","bufferToHex","copy","RootElementAlias","SerializedByteSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar HDPrivateKey = require('./hdprivatekey');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\nvar BufferUtil = require('./util/buffer');\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n"]},"metadata":{},"sourceType":"script"}