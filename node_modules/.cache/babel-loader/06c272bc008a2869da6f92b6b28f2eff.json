{"ast":null,"code":"\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n} // Compare two buffers in constant time to prevent timing attacks.\n\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  var res = 0;\n\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\n\n\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function (resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function (iv, key, data) {\n    return new Promise(function (resolve) {\n      if (subtle) {\n        var importAlgorithm = {\n          name: \"AES-CBC\"\n        };\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function (cryptoKey) {\n          var encAlgorithm = {\n            name: \"AES-CBC\",\n            iv: iv\n          };\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function (result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          cipher.update(data);\n          resolve(cipher.final());\n        } else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          decipher.update(data);\n          resolve(decipher.final());\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function (resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function (resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\n\n\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\"); // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n/**\n * Get compressed version of public key.\n */\n\n\nvar getPublicCompressed = exports.getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\"); // See https://github.com/wanderer/secp256k1-node/issues/46\n\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n}; // NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\n\n\nexports.sign = function (privateKey, msg) {\n  return new Promise(function (resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {\n      canonical: true\n    }).toDER()));\n  });\n};\n\nexports.verify = function (publicKey, msg, sig) {\n  return new Promise(function (resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n\n    if (publicKey.length === 65) {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n\n    if (publicKey.length === 33) {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function (privateKeyA, publicKeyB) {\n  return new Promise(function (resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n\n    if (publicKeyB.length === 65) {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n\n    if (publicKeyB.length === 33) {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic()); // BN instance\n\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function (publicKeyTo, msg, opts) {\n  opts = opts || {}; // Tmp variables to save context from flat promises;\n\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function (resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32); // There is a very unlikely possibility that it is not a valid key\n\n    while (!isValidPrivateKey(ephemPrivateKey)) {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function (Px) {\n    return sha512(Px);\n  }).then(function (hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function (data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function (mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac\n    };\n  });\n};\n\nexports.decrypt = function (privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function (Px) {\n    return sha512(Px);\n  }).then(function (hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function (macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function (msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/@myetherwallet/mewconnect-web-client/node_modules/eccrypto/browser.js"],"names":["EC","require","ec","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isScalar","x","isBuffer","length","isValidPrivateKey","privateKey","compare","equalConstTime","b1","b2","res","i","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","hash","createHash","result","update","digest","getAes","op","iv","key","data","importAlgorithm","name","keyp","importKey","then","cryptoKey","encAlgorithm","cipher","createCipheriv","final","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","hmacSha256Sign","hmac","createHmac","hmacSha256Verify","sig","expectedSig","exports","generatePrivate","getPublic","keyFromPrivate","getPublicCompressed","compressed","sign","canonical","toDER","verify","publicKey","reject","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","encrypt","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","encryptionKey","slice","dataToMac","concat","mac","decrypt","macGood"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          cipher.update(data);\n          resolve(cipher.final());\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          decipher.update(data);\n          resolve(decipher.final());\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n"]},"metadata":{},"sourceType":"script"}