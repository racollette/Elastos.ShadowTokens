{"ast":null,"code":"import * as Sentry from \"@sentry/react\";\nimport Web3 from \"web3\";\nimport GatewayJS from \"@renproject/gateway\"; // import Box from '3box'\n\nimport Web3Modal from \"web3modal\";\nimport firebase from \"firebase\";\nimport MEWconnect from \"@myetherwallet/mewconnect-web-client\";\nimport ELA from \"../assets/renBCH.svg\";\nimport ETH from \"../assets/eth.png\";\nimport { getStore } from \"../services/storeService\";\nimport { recoverTrades } from \"./txUtils\";\nimport { RENELA_MAIN, RENELA_TEST } from \"./web3Utils\"; // used for montoring balances\n\nlet walletDataInterval = null;\nexport const ASSETS = [\"BTC\", \"WBTC\"];\nexport const NAME_MAP = {\n  ela: \"Elastos\",\n  eth: \"Ethereum\",\n  weth: \"Wrapped Ethereum\"\n};\nexport const SYMBOL_MAP = {\n  ela: \"ELA\",\n  eth: \"ETH\",\n  weth: \"WETH\"\n};\nexport const NETWORK_MAP = {\n  ela: \"elastos\",\n  eth: \"ethereum\",\n  weth: \"elastos\"\n};\nexport const MINI_ICON_MAP = {\n  ela: ELA,\n  eth: ETH,\n  weth: ETH\n};\nexport const abbreviateAddress = function (walletAddress) {\n  if (!walletAddress || typeof walletAddress !== \"string\") {\n    return \"\";\n  } else {\n    return walletAddress.slice(0, 5) + \"...\" + walletAddress.slice(walletAddress.length - 5);\n  }\n};\n/**\n * Get External Data for Fees, Balances, etc.\n */\n\nexport const updateFees = async function () {\n  const store = getStore();\n\n  try {\n    const fees = await fetch(\"https://lightnode-mainnet.herokuapp.com\", {\n      method: \"POST\",\n      // or 'PUT'\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        id: 67,\n        jsonrpc: \"2.0\",\n        method: \"ren_queryFees\",\n        params: {}\n      })\n    });\n    const data = (await fees.json()).result;\n    store.set(\"fees\", data);\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"updating fees\");\n      Sentry.captureException(e);\n    });\n  }\n};\nexport const updateMarketData = async function () {\n  const store = getStore();\n\n  try {\n    const btc = await fetch(`https://api.coincap.io/v2/assets/bitcoin`, {\n      method: \"GET\"\n    });\n    store.set(\"btcusd\", (await btc.json()).data.priceUsd);\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"updating market data\");\n      Sentry.captureException(e);\n    });\n  }\n};\nexport const updateBalance = async function () {\n  const store = getStore();\n  const web3 = store.get(\"localWeb3\");\n  const walletAddress = store.get(\"localWeb3Address\");\n\n  if (!web3 || !walletAddress) {\n    return;\n  } // const renBTC = new web3.eth.Contract(erc20ABI, renBTCAddress);\n  // const renBTCBalance = await renBTC.methods.balanceOf(walletAddress).call();\n\n\n  const ethBal = await web3.eth.getBalance(walletAddress);\n  store.set(\"ethBalance\", Number(web3.utils.fromWei(ethBal)).toFixed(8)); // store.set(\n  //     \"renBTCBalance\",\n  //     Number(parseInt(renBTCBalance.toString()) / 10 ** 8).toFixed(8)\n  // );\n\n  store.set(\"loadingBalances\", false);\n  updateMarketData();\n};\nexport const watchWalletData = async function () {\n  const store = getStore();\n\n  if (walletDataInterval) {\n    clearInterval(walletDataInterval);\n  } // await updateAllowance()\n\n\n  await updateBalance();\n  walletDataInterval = setInterval(async () => {\n    // await updateAllowance()\n    await updateBalance();\n  }, 10 * 1000);\n};\nexport const initDataWeb3 = async function () {\n  const store = getStore();\n  const network = store.get(\"selectedNetwork\");\n  store.set(\"dataWeb3\", new Web3(`https://${network === \"testnet\" ? \"rinkeby\" : \"mainnet\"}.infura.io/v3/bd80ce1ca1f94da48e151bb6868bb150`));\n};\n/**\n * Connecting to Local Web3 Wallet\n */\n\nexport const initLocalWeb3 = async function (type) {\n  const store = getStore();\n  store.set(\"walletConnecting\", true); // already connected\n\n  if (store.get(\"localWeb3Address\")) {\n    return;\n  }\n\n  store.set(\"spaceError\", false);\n  const selectedNetwork = store.get(\"selectedNetwork\");\n  let web3;\n  let currentProvider;\n  let accounts = [];\n  let network = \"\";\n\n  try {\n    if (type === \"injected\" || !type) {\n      const providerOptions = {};\n      const web3Modal = new Web3Modal({\n        network: selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\",\n        cacheProvider: false,\n        providerOptions\n      });\n      const web3Provider = await web3Modal.connect();\n      web3 = new Web3(web3Provider);\n      currentProvider = web3.currentProvider;\n      if (typeof currentProvider === \"string\") return;\n      if (!currentProvider) return;\n      accounts = await web3.eth.getAccounts();\n      const netId = await web3.eth.net.getId();\n\n      if (netId === 1) {\n        network = \"mainnet\";\n      } else if (netId === 4) {\n        network = \"testnet\";\n      }\n    } else if (type === \"mew-connect\") {\n      const chainId = selectedNetwork === \"testnet\" ? 42 : 1;\n      const jsonRpcUrl = `wss://${selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\"}.infura.io/ws/v3/7117ca7a3c7b4b94b24944c1ef0ecec9`;\n      const mewConnect = new MEWconnect.Provider({\n        windowClosedError: true\n      });\n      const web3Provider = mewConnect.makeWeb3Provider(chainId, jsonRpcUrl, true);\n      web3 = new Web3(web3Provider);\n      currentProvider = web3.currentProvider;\n      if (typeof currentProvider === \"string\") return;\n      if (!currentProvider) return;\n      accounts = await web3Provider.enable();\n      network = selectedNetwork;\n    } else {\n      console.error(\"Invalid wallet type.\");\n      store.set(\"spaceError\", true);\n      store.set(\"spaceRequesting\", false);\n      store.set(\"walletConnecting\", false);\n      return;\n    }\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"web3 init\");\n      Sentry.captureException(e);\n    });\n    store.set(\"spaceError\", true);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n    return;\n  }\n\n  const address = accounts[0];\n  const addressLowerCase = address.toLowerCase();\n  const db = store.get(\"db\");\n  const fns = store.get(\"fns\");\n\n  if (selectedNetwork !== network) {\n    store.set(\"showNetworkModal\", true);\n    store.set(\"spaceError\", true);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n    return;\n  }\n\n  try {\n    ///////////////////////////////////////////////////////\n    // Firebase Sign In or Sign Up\n    //////////////////////////////////////////////////////\n    let signature = \"\";\n    let rawSig = \"\"; // get from local storage if user has signed in already\n\n    const localSigMap = localStorage.getItem(\"sigMap\");\n    const localRawSigMap = JSON.parse(localStorage.getItem(\"rawSigMap\") || \"{}\");\n    const localSigMapData = localSigMap ? JSON.parse(localSigMap) : {};\n\n    if (localSigMapData[addressLowerCase] && localRawSigMap[addressLowerCase]) {\n      signature = localSigMapData[addressLowerCase];\n      rawSig = localRawSigMap[addressLowerCase];\n    } else {\n      // get unique wallet signature for firebase backup\n      // @ts-ignore\n      rawSig = await web3.eth.personal.sign(web3.utils.utf8ToHex(\"Signing in to RenBridge\"), addressLowerCase);\n      signature = web3.utils.sha3(rawSig);\n      localSigMapData[addressLowerCase] = signature;\n      localStorage.setItem(\"sigMap\", JSON.stringify(localSigMapData));\n      localRawSigMap[addressLowerCase] = rawSig;\n      localStorage.setItem(\"rawSigMap\", JSON.stringify(localRawSigMap));\n    }\n\n    store.set(\"fsSignature\", signature);\n    let token = null;\n\n    try {\n      const res = await fns.httpsCallable(\"authenticate\")({\n        signed: rawSig,\n        account: addressLowerCase\n      });\n      token = res.data.token;\n\n      if (!token) {\n        throw new Error(\"missing token\");\n      }\n    } catch (e) {\n      console.log(\"No token auth, falling back to email / sig\");\n    } // auth with firestore\n\n\n    const bridgeId = `${addressLowerCase}@renproject.io`;\n    const currentFsUser = firebase.auth().currentUser;\n    let fsUser;\n\n    if (!currentFsUser || currentFsUser.email !== bridgeId) {\n      try {\n        fsUser = token ? (await firebase.auth().signInWithCustomToken(token)).user : (await firebase.auth().signInWithEmailAndPassword(bridgeId, signature)).user;\n      } catch (e) {\n        console.error(e); // We can register this user as they do not exist\n\n        if (e.message.includes(\"There is no user record\")) {\n          fsUser = (await firebase.auth().createUserWithEmailAndPassword(bridgeId, signature)).user;\n        } else {\n          console.error(e);\n          Sentry.withScope(function (scope) {\n            scope.setTag(\"error-hint\", \"web3 init\");\n            Sentry.captureException(e);\n          });\n        }\n      }\n    } else {\n      fsUser = currentFsUser;\n    }\n\n    store.set(\"fsUser\", fsUser);\n\n    if (fsUser) {\n      // update user collection\n      const doc = await db.collection(\"users\").doc(fsUser.uid);\n      const docData = await doc.get();\n\n      if (docData.exists) {\n        const data = docData.data();\n\n        if (data.signatures.indexOf(signature) < 0) {\n          // add a new signature if needed\n          await doc.update({\n            signatures: data.signatures.concat([signature]),\n            updated: firebase.firestore.Timestamp.fromDate(new Date(Date.now()))\n          });\n        }\n      } else {\n        // create user\n        await doc.set({\n          uid: fsUser.uid,\n          updated: firebase.firestore.Timestamp.fromDate(new Date(Date.now())),\n          signatures: [signature]\n        });\n      }\n    }\n\n    store.set(\"fsEnabled\", true); ///////////////////////////////////////////////////////\n    // Recover Transactions\n    //////////////////////////////////////////////////////\n\n    store.set(\"localWeb3\", web3);\n    store.set(\"localWeb3Address\", accounts[0]);\n    store.set(\"localWeb3Network\", network);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n    recoverTrades();\n    updateBalance();\n    if ((!currentProvider).on) return; // FIXME: provide propper provider type\n\n    const listeningProvider = currentProvider;\n\n    if (listeningProvider.on) {\n      // listen for changes\n      listeningProvider.on(\"accountsChanged\", async () => {\n        window.location.reload();\n      });\n      listeningProvider.on(\"chainChanged\", async () => {\n        window.location.reload();\n      });\n      listeningProvider.on(\"networkChanged\", async () => {\n        window.location.reload();\n      });\n      listeningProvider.on(\"disconnected\", async () => {\n        window.location.reload();\n      });\n    }\n  } catch (e) {\n    console.error(e);\n    Sentry.withScope(function (scope) {\n      scope.setTag(\"error-hint\", \"main initialization\");\n      Sentry.captureException(e);\n    });\n    store.set(\"spaceError\", true);\n    store.set(\"spaceRequesting\", false);\n    store.set(\"walletConnecting\", false);\n  }\n\n  return;\n};\nexport const setAddresses = async function () {\n  const store = getStore();\n  const network = store.get(\"selectedNetwork\");\n\n  if (network === \"testnet\") {\n    store.set(\"renELAAddress\", RENELA_TEST);\n  } else {\n    store.set(\"renELAAddress\", RENELA_MAIN);\n  }\n};\nexport const setNetwork = async function (network) {\n  const store = getStore();\n  console.log('NETWORK CONNECTION');\n  console.log({\n    network\n  });\n  store.set(\"selectedNetwork\", network);\n  store.set(\"gjs\", new GatewayJS(network, {// If we want to test against gatewayjs staging, we should change the endpoint\n    // manually in a PR, which does not get merged, and check the preview build\n    // endpoint: \"https://ren-gatewayjs-staging.netlify.app/\",\n  })); // @ts-ignore\n\n  setAddresses.bind(this)();\n};\nexport default {};","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/src/utils/walletUtils.ts"],"names":["Sentry","Web3","GatewayJS","Web3Modal","firebase","MEWconnect","ETH","getStore","recoverTrades","RENELA_MAIN","RENELA_TEST","walletDataInterval","ASSETS","NAME_MAP","ela","eth","weth","SYMBOL_MAP","NETWORK_MAP","MINI_ICON_MAP","ELA","abbreviateAddress","walletAddress","slice","length","updateFees","store","fees","fetch","method","headers","body","JSON","stringify","id","jsonrpc","params","data","json","result","set","e","console","error","withScope","scope","setTag","captureException","updateMarketData","btc","priceUsd","updateBalance","web3","get","ethBal","getBalance","Number","utils","fromWei","toFixed","watchWalletData","clearInterval","setInterval","initDataWeb3","network","initLocalWeb3","type","selectedNetwork","currentProvider","accounts","providerOptions","web3Modal","cacheProvider","web3Provider","connect","getAccounts","netId","net","getId","chainId","jsonRpcUrl","mewConnect","Provider","windowClosedError","makeWeb3Provider","enable","address","addressLowerCase","toLowerCase","db","fns","signature","rawSig","localSigMap","localStorage","getItem","localRawSigMap","parse","localSigMapData","personal","sign","utf8ToHex","sha3","setItem","token","res","httpsCallable","signed","account","Error","log","bridgeId","currentFsUser","auth","currentUser","fsUser","email","signInWithCustomToken","user","signInWithEmailAndPassword","message","includes","createUserWithEmailAndPassword","doc","collection","uid","docData","exists","signatures","indexOf","update","concat","updated","firestore","Timestamp","fromDate","Date","now","on","listeningProvider","window","location","reload","setAddresses","setNetwork","bind"],"mappings":"AAAA,OAAO,KAAKA,MAAZ,MAAwB,eAAxB;AAEA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,SAAP,MAAsB,qBAAtB,C,CACA;;AACA,OAAOC,SAAP,MAAsB,WAAtB;AACA,OAAOC,QAAP,MAAqB,UAArB;AACA,OAAOC,UAAP,MAAuB,sCAAvB;;AAGA,OAAOC,GAAP,MAAgB,mBAAhB;AAEA,SAASC,QAAT,QAAyB,0BAAzB;AAEA,SAASC,aAAT,QAA8B,WAA9B;AACA,SACIC,WADJ,EAEIC,WAFJ,QAGO,aAHP,C,CAKA;;AACA,IAAIC,kBAAuB,GAAG,IAA9B;AAEA,OAAO,MAAMC,MAAM,GAAG,CAAC,KAAD,EAAQ,MAAR,CAAf;AAEP,OAAO,MAAMC,QAAQ,GAAG;AACpBC,EAAAA,GAAG,EAAE,SADe;AAEpBC,EAAAA,GAAG,EAAE,UAFe;AAGpBC,EAAAA,IAAI,EAAE;AAHc,CAAjB;AAMP,OAAO,MAAMC,UAAU,GAAG;AACtBH,EAAAA,GAAG,EAAE,KADiB;AAEtBC,EAAAA,GAAG,EAAE,KAFiB;AAGtBC,EAAAA,IAAI,EAAE;AAHgB,CAAnB;AAMP,OAAO,MAAME,WAAW,GAAG;AACvBJ,EAAAA,GAAG,EAAE,SADkB;AAEvBC,EAAAA,GAAG,EAAE,UAFkB;AAGvBC,EAAAA,IAAI,EAAE;AAHiB,CAApB;AAMP,OAAO,MAAMG,aAA0C,GAAG;AACtDL,EAAAA,GAAG,EAAEM,GADiD;AAEtDL,EAAAA,GAAG,EAAET,GAFiD;AAGtDU,EAAAA,IAAI,EAAEV;AAHgD,CAAnD;AAMP,OAAO,MAAMe,iBAAiB,GAAG,UAASC,aAAT,EAAgC;AAC7D,MAAI,CAACA,aAAD,IAAkB,OAAOA,aAAP,KAAyB,QAA/C,EAAyD;AACrD,WAAO,EAAP;AACH,GAFD,MAEO;AACH,WACIA,aAAa,CAACC,KAAd,CAAoB,CAApB,EAAuB,CAAvB,IACA,KADA,GAEAD,aAAa,CAACC,KAAd,CAAoBD,aAAa,CAACE,MAAd,GAAuB,CAA3C,CAHJ;AAKH;AACJ,CAVM;AAYP;;;;AAGA,OAAO,MAAMC,UAAU,GAAG,kBAAiB;AACvC,QAAMC,KAAK,GAAGnB,QAAQ,EAAtB;;AACA,MAAI;AACA,UAAMoB,IAAI,GAAG,MAAMC,KAAK,CAAC,yCAAD,EAA4C;AAChEC,MAAAA,MAAM,EAAE,MADwD;AAChD;AAChBC,MAAAA,OAAO,EAAE;AACL,wBAAgB;AADX,OAFuD;AAKhEC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AACjBC,QAAAA,EAAE,EAAE,EADa;AAEjBC,QAAAA,OAAO,EAAE,KAFQ;AAGjBN,QAAAA,MAAM,EAAE,eAHS;AAIjBO,QAAAA,MAAM,EAAE;AAJS,OAAf;AAL0D,KAA5C,CAAxB;AAaA,UAAMC,IAAI,GAAG,CAAC,MAAMV,IAAI,CAACW,IAAL,EAAP,EAAoBC,MAAjC;AACAb,IAAAA,KAAK,CAACc,GAAN,CAAU,MAAV,EAAkBH,IAAlB;AACH,GAhBD,CAgBE,OAAOI,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAzC,IAAAA,MAAM,CAAC4C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,eAA3B;AACA9C,MAAAA,MAAM,CAAC+C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIH;AACJ,CAzBM;AA2BP,OAAO,MAAMO,gBAAgB,GAAG,kBAAiB;AAC7C,QAAMtB,KAAK,GAAGnB,QAAQ,EAAtB;;AAEA,MAAI;AACA,UAAM0C,GAAG,GAAG,MAAMrB,KAAK,CAAE,0CAAF,EAA6C;AAChEC,MAAAA,MAAM,EAAE;AADwD,KAA7C,CAAvB;AAIAH,IAAAA,KAAK,CAACc,GAAN,CAAU,QAAV,EAAoB,CAAC,MAAMS,GAAG,CAACX,IAAJ,EAAP,EAAmBD,IAAnB,CAAwBa,QAA5C;AACH,GAND,CAME,OAAOT,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAzC,IAAAA,MAAM,CAAC4C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,sBAA3B;AACA9C,MAAAA,MAAM,CAAC+C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIH;AACJ,CAhBM;AAkBP,OAAO,MAAMU,aAAa,GAAG,kBAAiB;AAC1C,QAAMzB,KAAK,GAAGnB,QAAQ,EAAtB;AAEA,QAAM6C,IAAI,GAAG1B,KAAK,CAAC2B,GAAN,CAAU,WAAV,CAAb;AACA,QAAM/B,aAAa,GAAGI,KAAK,CAAC2B,GAAN,CAAU,kBAAV,CAAtB;;AAEA,MAAI,CAACD,IAAD,IAAS,CAAC9B,aAAd,EAA6B;AACzB;AACH,GARyC,CAU1C;AACA;;;AAEA,QAAMgC,MAAM,GAAG,MAAMF,IAAI,CAACrC,GAAL,CAASwC,UAAT,CAAoBjC,aAApB,CAArB;AAGAI,EAAAA,KAAK,CAACc,GAAN,CAAU,YAAV,EAAwBgB,MAAM,CAACJ,IAAI,CAACK,KAAL,CAAWC,OAAX,CAAmBJ,MAAnB,CAAD,CAAN,CAAmCK,OAAnC,CAA2C,CAA3C,CAAxB,EAhB0C,CAiB1C;AACA;AACA;AACA;;AACAjC,EAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AAEAQ,EAAAA,gBAAgB;AACnB,CAxBM;AA0BP,OAAO,MAAMY,eAAe,GAAG,kBAAiB;AAC5C,QAAMlC,KAAK,GAAGnB,QAAQ,EAAtB;;AACA,MAAII,kBAAJ,EAAwB;AACpBkD,IAAAA,aAAa,CAAClD,kBAAD,CAAb;AACH,GAJ2C,CAK5C;;;AACA,QAAMwC,aAAa,EAAnB;AACAxC,EAAAA,kBAAkB,GAAGmD,WAAW,CAAC,YAAY;AACzC;AACA,UAAMX,aAAa,EAAnB;AACH,GAH+B,EAG7B,KAAK,IAHwB,CAAhC;AAIH,CAXM;AAaP,OAAO,MAAMY,YAAY,GAAG,kBAAiB;AACzC,QAAMrC,KAAK,GAAGnB,QAAQ,EAAtB;AACA,QAAMyD,OAAO,GAAGtC,KAAK,CAAC2B,GAAN,CAAU,iBAAV,CAAhB;AACA3B,EAAAA,KAAK,CAACc,GAAN,CACI,UADJ,EAEI,IAAIvC,IAAJ,CACK,WACD+D,OAAO,KAAK,SAAZ,GAAwB,SAAxB,GAAoC,SACnC,gDAHL,CAFJ;AASH,CAZM;AAcP;;;;AAGA,OAAO,MAAMC,aAAa,GAAG,gBAAeC,IAAf,EAA0B;AACnD,QAAMxC,KAAK,GAAGnB,QAAQ,EAAtB;AACAmB,EAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,IAA9B,EAFmD,CAInD;;AACA,MAAId,KAAK,CAAC2B,GAAN,CAAU,kBAAV,CAAJ,EAAmC;AAC/B;AACH;;AAED3B,EAAAA,KAAK,CAACc,GAAN,CAAU,YAAV,EAAwB,KAAxB;AACA,QAAM2B,eAAe,GAAGzC,KAAK,CAAC2B,GAAN,CAAU,iBAAV,CAAxB;AAEA,MAAID,IAAJ;AACA,MAAIgB,eAAJ;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIL,OAAO,GAAG,EAAd;;AAEA,MAAI;AACA,QAAIE,IAAI,KAAK,UAAT,IAAuB,CAACA,IAA5B,EAAkC;AAC9B,YAAMI,eAAe,GAAG,EAAxB;AACA,YAAMC,SAAS,GAAG,IAAIpE,SAAJ,CAAc;AAC5B6D,QAAAA,OAAO,EAAEG,eAAe,KAAK,SAApB,GAAgC,SAAhC,GAA4C,SADzB;AAE5BK,QAAAA,aAAa,EAAE,KAFa;AAG5BF,QAAAA;AAH4B,OAAd,CAAlB;AAKA,YAAMG,YAAY,GAAG,MAAMF,SAAS,CAACG,OAAV,EAA3B;AAEAtB,MAAAA,IAAI,GAAG,IAAInD,IAAJ,CAASwE,YAAT,CAAP;AACAL,MAAAA,eAAe,GAAGhB,IAAI,CAACgB,eAAvB;AACA,UAAI,OAAOA,eAAP,KAA2B,QAA/B,EAAyC;AACzC,UAAI,CAACA,eAAL,EAAsB;AACtBC,MAAAA,QAAQ,GAAG,MAAMjB,IAAI,CAACrC,GAAL,CAAS4D,WAAT,EAAjB;AACA,YAAMC,KAAK,GAAG,MAAMxB,IAAI,CAACrC,GAAL,CAAS8D,GAAT,CAAaC,KAAb,EAApB;;AACA,UAAIF,KAAK,KAAK,CAAd,EAAiB;AACbZ,QAAAA,OAAO,GAAG,SAAV;AACH,OAFD,MAEO,IAAIY,KAAK,KAAK,CAAd,EAAiB;AACpBZ,QAAAA,OAAO,GAAG,SAAV;AACH;AACJ,KApBD,MAoBO,IAAIE,IAAI,KAAK,aAAb,EAA4B;AAC/B,YAAMa,OAAO,GAAGZ,eAAe,KAAK,SAApB,GAAgC,EAAhC,GAAqC,CAArD;AACA,YAAMa,UAAU,GAAI,SAChBb,eAAe,KAAK,SAApB,GAAgC,SAAhC,GAA4C,SAC3C,mDAFL;AAIA,YAAMc,UAAU,GAAG,IAAI5E,UAAU,CAAC6E,QAAf,CAAwB;AACvCC,QAAAA,iBAAiB,EAAE;AADoB,OAAxB,CAAnB;AAGA,YAAMV,YAAY,GAAGQ,UAAU,CAACG,gBAAX,CACjBL,OADiB,EAEjBC,UAFiB,EAGjB,IAHiB,CAArB;AAMA5B,MAAAA,IAAI,GAAG,IAAInD,IAAJ,CAASwE,YAAT,CAAP;AACAL,MAAAA,eAAe,GAAGhB,IAAI,CAACgB,eAAvB;AAEA,UAAI,OAAOA,eAAP,KAA2B,QAA/B,EAAyC;AACzC,UAAI,CAACA,eAAL,EAAsB;AAEtBC,MAAAA,QAAQ,GAAG,MAAMI,YAAY,CAACY,MAAb,EAAjB;AACArB,MAAAA,OAAO,GAAGG,eAAV;AACH,KAvBM,MAuBA;AACHzB,MAAAA,OAAO,CAACC,KAAR,CAAc,sBAAd;AACAjB,MAAAA,KAAK,CAACc,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAd,MAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAd,MAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACA;AACH;AACJ,GAnDD,CAmDE,OAAOC,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAzC,IAAAA,MAAM,CAAC4C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,WAA3B;AACA9C,MAAAA,MAAM,CAAC+C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIAf,IAAAA,KAAK,CAACc,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACA;AACH;;AAED,QAAM8C,OAAO,GAAGjB,QAAQ,CAAC,CAAD,CAAxB;AACA,QAAMkB,gBAAgB,GAAGD,OAAO,CAACE,WAAR,EAAzB;AACA,QAAMC,EAAE,GAAG/D,KAAK,CAAC2B,GAAN,CAAU,IAAV,CAAX;AACA,QAAMqC,GAAG,GAAGhE,KAAK,CAAC2B,GAAN,CAAU,KAAV,CAAZ;;AAEA,MAAIc,eAAe,KAAKH,OAAxB,EAAiC;AAC7BtC,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,IAA9B;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACA;AACH;;AAED,MAAI;AACA;AACA;AACA;AAEA,QAAImD,SAAS,GAAG,EAAhB;AACA,QAAIC,MAAM,GAAG,EAAb,CANA,CAQA;;AACA,UAAMC,WAAW,GAAGC,YAAY,CAACC,OAAb,CAAqB,QAArB,CAApB;AACA,UAAMC,cAAc,GAAGhE,IAAI,CAACiE,KAAL,CACnBH,YAAY,CAACC,OAAb,CAAqB,WAArB,KAAqC,IADlB,CAAvB;AAGA,UAAMG,eAAe,GAAGL,WAAW,GAAG7D,IAAI,CAACiE,KAAL,CAAWJ,WAAX,CAAH,GAA6B,EAAhE;;AACA,QAAIK,eAAe,CAACX,gBAAD,CAAf,IAAqCS,cAAc,CAACT,gBAAD,CAAvD,EAA2E;AACvEI,MAAAA,SAAS,GAAGO,eAAe,CAACX,gBAAD,CAA3B;AACAK,MAAAA,MAAM,GAAGI,cAAc,CAACT,gBAAD,CAAvB;AACH,KAHD,MAGO;AACH;AACA;AACAK,MAAAA,MAAM,GAAG,MAAMxC,IAAI,CAACrC,GAAL,CAASoF,QAAT,CAAkBC,IAAlB,CACXhD,IAAI,CAACK,KAAL,CAAW4C,SAAX,CAAqB,yBAArB,CADW,EAEXd,gBAFW,CAAf;AAIAI,MAAAA,SAAS,GAAGvC,IAAI,CAACK,KAAL,CAAW6C,IAAX,CAAgBV,MAAhB,CAAZ;AACAM,MAAAA,eAAe,CAACX,gBAAD,CAAf,GAAoCI,SAApC;AACAG,MAAAA,YAAY,CAACS,OAAb,CAAqB,QAArB,EAA+BvE,IAAI,CAACC,SAAL,CAAeiE,eAAf,CAA/B;AAEAF,MAAAA,cAAc,CAACT,gBAAD,CAAd,GAAmCK,MAAnC;AACAE,MAAAA,YAAY,CAACS,OAAb,CAAqB,WAArB,EAAkCvE,IAAI,CAACC,SAAL,CAAe+D,cAAf,CAAlC;AACH;;AAEDtE,IAAAA,KAAK,CAACc,GAAN,CAAU,aAAV,EAAyBmD,SAAzB;AAEA,QAAIa,KAAoB,GAAG,IAA3B;;AACA,QAAI;AACA,YAAMC,GAAG,GAAG,MAAMf,GAAG,CAACgB,aAAJ,CAAkB,cAAlB,EAAkC;AAChDC,QAAAA,MAAM,EAAEf,MADwC;AAEhDgB,QAAAA,OAAO,EAAErB;AAFuC,OAAlC,CAAlB;AAKAiB,MAAAA,KAAK,GAAGC,GAAG,CAACpE,IAAJ,CAASmE,KAAjB;;AACA,UAAI,CAACA,KAAL,EAAY;AACR,cAAM,IAAIK,KAAJ,CAAU,eAAV,CAAN;AACH;AACJ,KAVD,CAUE,OAAOpE,CAAP,EAAU;AACRC,MAAAA,OAAO,CAACoE,GAAR,CAAY,4CAAZ;AACH,KA/CD,CAiDA;;;AACA,UAAMC,QAAQ,GAAI,GAAExB,gBAAiB,gBAArC;AACA,UAAMyB,aAAa,GAAG5G,QAAQ,CAAC6G,IAAT,GAAgBC,WAAtC;AACA,QAAIC,MAAJ;;AAEA,QAAI,CAACH,aAAD,IAAkBA,aAAa,CAACI,KAAd,KAAwBL,QAA9C,EAAwD;AACpD,UAAI;AACAI,QAAAA,MAAM,GAAGX,KAAK,GACR,CAAC,MAAMpG,QAAQ,CAAC6G,IAAT,GAAgBI,qBAAhB,CAAsCb,KAAtC,CAAP,EAAqDc,IAD7C,GAER,CACE,MAAMlH,QAAQ,CACT6G,IADC,GAEDM,0BAFC,CAE0BR,QAF1B,EAEoCpB,SAFpC,CADR,EAIA2B,IANN;AAOH,OARD,CAQE,OAAO7E,CAAP,EAAU;AACRC,QAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd,EADQ,CAER;;AACA,YAAIA,CAAC,CAAC+E,OAAF,CAAUC,QAAV,CAAmB,yBAAnB,CAAJ,EAAmD;AAC/CN,UAAAA,MAAM,GAAG,CACL,MAAM/G,QAAQ,CACT6G,IADC,GAEDS,8BAFC,CAE8BX,QAF9B,EAEwCpB,SAFxC,CADD,EAIP2B,IAJF;AAKH,SAND,MAMO;AACH5E,UAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAzC,UAAAA,MAAM,CAAC4C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,YAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,WAA3B;AACA9C,YAAAA,MAAM,CAAC+C,gBAAP,CAAwBN,CAAxB;AACH,WAHD;AAIH;AACJ;AACJ,KA1BD,MA0BO;AACH0E,MAAAA,MAAM,GAAGH,aAAT;AACH;;AAEDtF,IAAAA,KAAK,CAACc,GAAN,CAAU,QAAV,EAAoB2E,MAApB;;AAEA,QAAIA,MAAJ,EAAY;AACR;AACA,YAAMQ,GAAG,GAAG,MAAMlC,EAAE,CAACmC,UAAH,CAAc,OAAd,EAAuBD,GAAvB,CAA2BR,MAAM,CAACU,GAAlC,CAAlB;AACA,YAAMC,OAAO,GAAG,MAAMH,GAAG,CAACtE,GAAJ,EAAtB;;AAEA,UAAIyE,OAAO,CAACC,MAAZ,EAAoB;AAChB,cAAM1F,IAAI,GAAGyF,OAAO,CAACzF,IAAR,EAAb;;AACA,YAAIA,IAAI,CAAC2F,UAAL,CAAgBC,OAAhB,CAAwBtC,SAAxB,IAAqC,CAAzC,EAA4C;AACxC;AACA,gBAAMgC,GAAG,CAACO,MAAJ,CAAW;AACbF,YAAAA,UAAU,EAAE3F,IAAI,CAAC2F,UAAL,CAAgBG,MAAhB,CAAuB,CAACxC,SAAD,CAAvB,CADC;AAEbyC,YAAAA,OAAO,EAAEhI,QAAQ,CAACiI,SAAT,CAAmBC,SAAnB,CAA6BC,QAA7B,CACL,IAAIC,IAAJ,CAASA,IAAI,CAACC,GAAL,EAAT,CADK;AAFI,WAAX,CAAN;AAMH;AACJ,OAXD,MAWO;AACH;AACA,cAAMd,GAAG,CAACnF,GAAJ,CAAQ;AACVqF,UAAAA,GAAG,EAAEV,MAAM,CAACU,GADF;AAEVO,UAAAA,OAAO,EAAEhI,QAAQ,CAACiI,SAAT,CAAmBC,SAAnB,CAA6BC,QAA7B,CAAsC,IAAIC,IAAJ,CAASA,IAAI,CAACC,GAAL,EAAT,CAAtC,CAFC;AAGVT,UAAAA,UAAU,EAAE,CAACrC,SAAD;AAHF,SAAR,CAAN;AAKH;AACJ;;AAEDjE,IAAAA,KAAK,CAACc,GAAN,CAAU,WAAV,EAAuB,IAAvB,EAhHA,CAkHA;AACA;AACA;;AAEAd,IAAAA,KAAK,CAACc,GAAN,CAAU,WAAV,EAAuBY,IAAvB;AACA1B,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B6B,QAAQ,CAAC,CAAD,CAAtC;AACA3C,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8BwB,OAA9B;AACAtC,IAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AAEAhC,IAAAA,aAAa;AACb2C,IAAAA,aAAa;AAEb,QAAI,CAAC,CAACiB,eAAF,EAA0BsE,EAA9B,EAAkC,OA/HlC,CAgIA;;AACA,UAAMC,iBAAsB,GAAGvE,eAA/B;;AACA,QAAIuE,iBAAiB,CAACD,EAAtB,EAA0B;AACtB;AACAC,MAAAA,iBAAiB,CAACD,EAAlB,CAAqB,iBAArB,EAAwC,YAAY;AAChDE,QAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,OAFD;AAIAH,MAAAA,iBAAiB,CAACD,EAAlB,CAAqB,cAArB,EAAqC,YAAY;AAC7CE,QAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,OAFD;AAIAH,MAAAA,iBAAiB,CAACD,EAAlB,CAAqB,gBAArB,EAAuC,YAAY;AAC/CE,QAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,OAFD;AAIAH,MAAAA,iBAAiB,CAACD,EAAlB,CAAqB,cAArB,EAAqC,YAAY;AAC7CE,QAAAA,MAAM,CAACC,QAAP,CAAgBC,MAAhB;AACH,OAFD;AAGH;AACJ,GApJD,CAoJE,OAAOrG,CAAP,EAAU;AACRC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAzC,IAAAA,MAAM,CAAC4C,SAAP,CAAiB,UAASC,KAAT,EAAgB;AAC7BA,MAAAA,KAAK,CAACC,MAAN,CAAa,YAAb,EAA2B,qBAA3B;AACA9C,MAAAA,MAAM,CAAC+C,gBAAP,CAAwBN,CAAxB;AACH,KAHD;AAIAf,IAAAA,KAAK,CAACc,GAAN,CAAU,YAAV,EAAwB,IAAxB;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6B,KAA7B;AACAd,IAAAA,KAAK,CAACc,GAAN,CAAU,kBAAV,EAA8B,KAA9B;AACH;;AAED;AACH,CA7PM;AA+PP,OAAO,MAAMuG,YAAY,GAAG,kBAAiB;AACzC,QAAMrH,KAAK,GAAGnB,QAAQ,EAAtB;AACA,QAAMyD,OAAO,GAAGtC,KAAK,CAAC2B,GAAN,CAAU,iBAAV,CAAhB;;AACA,MAAIW,OAAO,KAAK,SAAhB,EAA2B;AACvBtC,IAAAA,KAAK,CAACc,GAAN,CAAU,eAAV,EAA2B9B,WAA3B;AACH,GAFD,MAEO;AACHgB,IAAAA,KAAK,CAACc,GAAN,CAAU,eAAV,EAA2B/B,WAA3B;AACH;AACJ,CARM;AAUP,OAAO,MAAMuI,UAAU,GAAG,gBAAehF,OAAf,EAA6B;AACnD,QAAMtC,KAAK,GAAGnB,QAAQ,EAAtB;AACAmC,EAAAA,OAAO,CAACoE,GAAR,CAAY,oBAAZ;AACApE,EAAAA,OAAO,CAACoE,GAAR,CAAY;AAAE9C,IAAAA;AAAF,GAAZ;AACAtC,EAAAA,KAAK,CAACc,GAAN,CAAU,iBAAV,EAA6BwB,OAA7B;AACAtC,EAAAA,KAAK,CAACc,GAAN,CACI,KADJ,EAEI,IAAItC,SAAJ,CAAc8D,OAAd,EAAuB,CACnB;AACA;AACA;AAHmB,GAAvB,CAFJ,EALmD,CAanD;;AACA+E,EAAAA,YAAY,CAACE,IAAb,CAAkB,IAAlB;AACH,CAfM;AAiBP,eAAe,EAAf","sourcesContent":["import * as Sentry from \"@sentry/react\";\n\nimport Web3 from \"web3\";\nimport GatewayJS from \"@renproject/gateway\";\n// import Box from '3box'\nimport Web3Modal from \"web3modal\";\nimport firebase from \"firebase\";\nimport MEWconnect from \"@myetherwallet/mewconnect-web-client\";\n\nimport ELA from \"../assets/renBCH.svg\"\nimport ETH from \"../assets/eth.png\";\n\nimport { getStore } from \"../services/storeService\";\nimport erc20ABI from \"./erc20ABI.json\";\nimport { recoverTrades } from \"./txUtils\";\nimport {\n    RENELA_MAIN,\n    RENELA_TEST,\n} from \"./web3Utils\";\n\n// used for montoring balances\nlet walletDataInterval: any = null;\n\nexport const ASSETS = [\"BTC\", \"WBTC\"];\n\nexport const NAME_MAP = {\n    ela: \"Elastos\",\n    eth: \"Ethereum\",\n    weth: \"Wrapped Ethereum\",\n};\n\nexport const SYMBOL_MAP = {\n    ela: \"ELA\",\n    eth: \"ETH\",\n    weth: \"WETH\",\n};\n\nexport const NETWORK_MAP = {\n    ela: \"elastos\",\n    eth: \"ethereum\",\n    weth: \"elastos\",\n};\n\nexport const MINI_ICON_MAP: { [key in string]: string } = {\n    ela: ELA,\n    eth: ETH,\n    weth: ETH,\n};\n\nexport const abbreviateAddress = function(walletAddress: string) {\n    if (!walletAddress || typeof walletAddress !== \"string\") {\n        return \"\";\n    } else {\n        return (\n            walletAddress.slice(0, 5) +\n            \"...\" +\n            walletAddress.slice(walletAddress.length - 5)\n        );\n    }\n};\n\n/**\n * Get External Data for Fees, Balances, etc.\n */\nexport const updateFees = async function() {\n    const store = getStore();\n    try {\n        const fees = await fetch(\"https://lightnode-mainnet.herokuapp.com\", {\n            method: \"POST\", // or 'PUT'\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                id: 67,\n                jsonrpc: \"2.0\",\n                method: \"ren_queryFees\",\n                params: {},\n            }),\n        });\n\n        const data = (await fees.json()).result;\n        store.set(\"fees\", data);\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"updating fees\");\n            Sentry.captureException(e);\n        });\n    }\n};\n\nexport const updateMarketData = async function() {\n    const store = getStore();\n\n    try {\n        const btc = await fetch(`https://api.coincap.io/v2/assets/bitcoin`, {\n            method: \"GET\",\n        });\n\n        store.set(\"btcusd\", (await btc.json()).data.priceUsd);\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"updating market data\");\n            Sentry.captureException(e);\n        });\n    }\n};\n\nexport const updateBalance = async function() {\n    const store = getStore();\n\n    const web3 = store.get(\"localWeb3\");\n    const walletAddress = store.get(\"localWeb3Address\");\n\n    if (!web3 || !walletAddress) {\n        return;\n    }\n\n    // const renBTC = new web3.eth.Contract(erc20ABI, renBTCAddress);\n    // const renBTCBalance = await renBTC.methods.balanceOf(walletAddress).call();\n\n    const ethBal = await web3.eth.getBalance(walletAddress);\n\n\n    store.set(\"ethBalance\", Number(web3.utils.fromWei(ethBal)).toFixed(8));\n    // store.set(\n    //     \"renBTCBalance\",\n    //     Number(parseInt(renBTCBalance.toString()) / 10 ** 8).toFixed(8)\n    // );\n    store.set(\"loadingBalances\", false);\n\n    updateMarketData();\n};\n\nexport const watchWalletData = async function() {\n    const store = getStore();\n    if (walletDataInterval) {\n        clearInterval(walletDataInterval);\n    }\n    // await updateAllowance()\n    await updateBalance();\n    walletDataInterval = setInterval(async () => {\n        // await updateAllowance()\n        await updateBalance();\n    }, 10 * 1000);\n};\n\nexport const initDataWeb3 = async function() {\n    const store = getStore();\n    const network = store.get(\"selectedNetwork\");\n    store.set(\n        \"dataWeb3\",\n        new Web3(\n            `https://${\n            network === \"testnet\" ? \"rinkeby\" : \"mainnet\"\n            }.infura.io/v3/bd80ce1ca1f94da48e151bb6868bb150`\n        )\n    );\n\n};\n\n/**\n * Connecting to Local Web3 Wallet\n */\nexport const initLocalWeb3 = async function(type: any) {\n    const store = getStore();\n    store.set(\"walletConnecting\", true);\n\n    // already connected\n    if (store.get(\"localWeb3Address\")) {\n        return;\n    }\n\n    store.set(\"spaceError\", false);\n    const selectedNetwork = store.get(\"selectedNetwork\");\n\n    let web3;\n    let currentProvider;\n    let accounts = [];\n    let network = \"\";\n\n    try {\n        if (type === \"injected\" || !type) {\n            const providerOptions = {};\n            const web3Modal = new Web3Modal({\n                network: selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\",\n                cacheProvider: false,\n                providerOptions,\n            });\n            const web3Provider = await web3Modal.connect();\n\n            web3 = new Web3(web3Provider);\n            currentProvider = web3.currentProvider;\n            if (typeof currentProvider === \"string\") return;\n            if (!currentProvider) return;\n            accounts = await web3.eth.getAccounts();\n            const netId = await web3.eth.net.getId();\n            if (netId === 1) {\n                network = \"mainnet\";\n            } else if (netId === 4) {\n                network = \"testnet\";\n            }\n        } else if (type === \"mew-connect\") {\n            const chainId = selectedNetwork === \"testnet\" ? 42 : 1;\n            const jsonRpcUrl = `wss://${\n                selectedNetwork === \"testnet\" ? \"rinkeby\" : \"mainnet\"\n                }.infura.io/ws/v3/7117ca7a3c7b4b94b24944c1ef0ecec9`;\n\n            const mewConnect = new MEWconnect.Provider({\n                windowClosedError: true,\n            });\n            const web3Provider = mewConnect.makeWeb3Provider(\n                chainId,\n                jsonRpcUrl,\n                true\n            );\n\n            web3 = new Web3(web3Provider);\n            currentProvider = web3.currentProvider;\n\n            if (typeof currentProvider === \"string\") return;\n            if (!currentProvider) return;\n\n            accounts = await web3Provider.enable();\n            network = selectedNetwork;\n        } else {\n            console.error(\"Invalid wallet type.\");\n            store.set(\"spaceError\", true);\n            store.set(\"spaceRequesting\", false);\n            store.set(\"walletConnecting\", false);\n            return;\n        }\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"web3 init\");\n            Sentry.captureException(e);\n        });\n        store.set(\"spaceError\", true);\n        store.set(\"spaceRequesting\", false);\n        store.set(\"walletConnecting\", false);\n        return;\n    }\n\n    const address = accounts[0];\n    const addressLowerCase = address.toLowerCase();\n    const db = store.get(\"db\");\n    const fns = store.get(\"fns\");\n\n    if (selectedNetwork !== network) {\n        store.set(\"showNetworkModal\", true);\n        store.set(\"spaceError\", true);\n        store.set(\"spaceRequesting\", false);\n        store.set(\"walletConnecting\", false);\n        return;\n    }\n\n    try {\n        ///////////////////////////////////////////////////////\n        // Firebase Sign In or Sign Up\n        //////////////////////////////////////////////////////\n\n        let signature = \"\";\n        let rawSig = \"\";\n\n        // get from local storage if user has signed in already\n        const localSigMap = localStorage.getItem(\"sigMap\");\n        const localRawSigMap = JSON.parse(\n            localStorage.getItem(\"rawSigMap\") || \"{}\"\n        );\n        const localSigMapData = localSigMap ? JSON.parse(localSigMap) : {};\n        if (localSigMapData[addressLowerCase] && localRawSigMap[addressLowerCase]) {\n            signature = localSigMapData[addressLowerCase];\n            rawSig = localRawSigMap[addressLowerCase];\n        } else {\n            // get unique wallet signature for firebase backup\n            // @ts-ignore\n            rawSig = await web3.eth.personal.sign(\n                web3.utils.utf8ToHex(\"Signing in to RenBridge\"),\n                addressLowerCase\n            );\n            signature = web3.utils.sha3(rawSig)!;\n            localSigMapData[addressLowerCase] = signature;\n            localStorage.setItem(\"sigMap\", JSON.stringify(localSigMapData));\n\n            localRawSigMap[addressLowerCase] = rawSig;\n            localStorage.setItem(\"rawSigMap\", JSON.stringify(localRawSigMap));\n        }\n\n        store.set(\"fsSignature\", signature);\n\n        let token: string | null = null;\n        try {\n            const res = await fns.httpsCallable(\"authenticate\")({\n                signed: rawSig,\n                account: addressLowerCase,\n            });\n\n            token = res.data.token;\n            if (!token) {\n                throw new Error(\"missing token\");\n            }\n        } catch (e) {\n            console.log(\"No token auth, falling back to email / sig\");\n        }\n\n        // auth with firestore\n        const bridgeId = `${addressLowerCase}@renproject.io`;\n        const currentFsUser = firebase.auth().currentUser;\n        let fsUser;\n\n        if (!currentFsUser || currentFsUser.email !== bridgeId) {\n            try {\n                fsUser = token\n                    ? (await firebase.auth().signInWithCustomToken(token)).user\n                    : (\n                        await firebase\n                            .auth()\n                            .signInWithEmailAndPassword(bridgeId, signature)\n                    ).user;\n            } catch (e) {\n                console.error(e);\n                // We can register this user as they do not exist\n                if (e.message.includes(\"There is no user record\")) {\n                    fsUser = (\n                        await firebase\n                            .auth()\n                            .createUserWithEmailAndPassword(bridgeId, signature)\n                    ).user;\n                } else {\n                    console.error(e);\n                    Sentry.withScope(function(scope) {\n                        scope.setTag(\"error-hint\", \"web3 init\");\n                        Sentry.captureException(e);\n                    });\n                }\n            }\n        } else {\n            fsUser = currentFsUser;\n        }\n\n        store.set(\"fsUser\", fsUser);\n\n        if (fsUser) {\n            // update user collection\n            const doc = await db.collection(\"users\").doc(fsUser.uid);\n            const docData = await doc.get();\n\n            if (docData.exists) {\n                const data = docData.data();\n                if (data.signatures.indexOf(signature) < 0) {\n                    // add a new signature if needed\n                    await doc.update({\n                        signatures: data.signatures.concat([signature]),\n                        updated: firebase.firestore.Timestamp.fromDate(\n                            new Date(Date.now())\n                        ),\n                    });\n                }\n            } else {\n                // create user\n                await doc.set({\n                    uid: fsUser.uid,\n                    updated: firebase.firestore.Timestamp.fromDate(new Date(Date.now())),\n                    signatures: [signature],\n                });\n            }\n        }\n\n        store.set(\"fsEnabled\", true);\n\n        ///////////////////////////////////////////////////////\n        // Recover Transactions\n        //////////////////////////////////////////////////////\n\n        store.set(\"localWeb3\", web3);\n        store.set(\"localWeb3Address\", accounts[0]);\n        store.set(\"localWeb3Network\", network);\n        store.set(\"spaceRequesting\", false);\n        store.set(\"walletConnecting\", false);\n\n        recoverTrades();\n        updateBalance();\n\n        if ((!currentProvider as any).on) return;\n        // FIXME: provide propper provider type\n        const listeningProvider: any = currentProvider;\n        if (listeningProvider.on) {\n            // listen for changes\n            listeningProvider.on(\"accountsChanged\", async () => {\n                window.location.reload();\n            });\n\n            listeningProvider.on(\"chainChanged\", async () => {\n                window.location.reload();\n            });\n\n            listeningProvider.on(\"networkChanged\", async () => {\n                window.location.reload();\n            });\n\n            listeningProvider.on(\"disconnected\", async () => {\n                window.location.reload();\n            });\n        }\n    } catch (e) {\n        console.error(e);\n        Sentry.withScope(function(scope) {\n            scope.setTag(\"error-hint\", \"main initialization\");\n            Sentry.captureException(e);\n        });\n        store.set(\"spaceError\", true);\n        store.set(\"spaceRequesting\", false);\n        store.set(\"walletConnecting\", false);\n    }\n\n    return;\n};\n\nexport const setAddresses = async function() {\n    const store = getStore();\n    const network = store.get(\"selectedNetwork\");\n    if (network === \"testnet\") {\n        store.set(\"renELAAddress\", RENELA_TEST);\n    } else {\n        store.set(\"renELAAddress\", RENELA_MAIN);\n    }\n};\n\nexport const setNetwork = async function(network: any) {\n    const store = getStore();\n    console.log('NETWORK CONNECTION')\n    console.log({ network })\n    store.set(\"selectedNetwork\", network);\n    store.set(\n        \"gjs\",\n        new GatewayJS(network, {\n            // If we want to test against gatewayjs staging, we should change the endpoint\n            // manually in a PR, which does not get merged, and check the preview build\n            // endpoint: \"https://ren-gatewayjs-staging.netlify.app/\",\n        })\n    );\n    // @ts-ignore\n    setAddresses.bind(this)();\n};\n\nexport default {};\n"]},"metadata":{},"sourceType":"module"}