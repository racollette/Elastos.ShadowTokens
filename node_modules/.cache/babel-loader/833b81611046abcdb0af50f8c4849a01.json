{"ast":null,"code":"import { Networks, Opcode, Script } from \"bitcore-lib\";\nimport { encode } from \"bs58\";\nimport { getConfirmations, getUTXO, getUTXOs } from \"send-crypto/build/main/handlers/BTC/BTCHandler\";\nimport { validate } from \"wallet-address-validator\";\nimport { createAddress } from \"./common\";\nimport { Ox, strip0x } from \"./hex\";\nexport const createBTCAddress = createAddress(Networks, Opcode, Script);\nexport const getBitcoinUTXOs = ({\n  isTestnet\n}) => {\n  return async (address, confirmations) => {\n    return getUTXOs(isTestnet, {\n      address,\n      confirmations\n    });\n  };\n};\nexport const getBitcoinConfirmations = ({\n  isTestnet\n}) => {\n  return async txHash => {\n    return getConfirmations(isTestnet, txHash);\n  };\n};\nexport const getBitcoinUTXO = ({\n  isTestnet\n}) => {\n  return async (txHash, vOut) => {\n    return getUTXO(isTestnet, txHash, vOut);\n  };\n}; // export const btcAddressToHex = (address: string) => {\n//     const addressBuffer = new Address(address).toBuffer();\n//     // Concatenate checksum\n//     return Ox(Buffer.concat([addressBuffer, Base58Check.checksum(addressBuffer)]));\n// };\n// export const btcAddressFrom = (address: string, encoding: \"hex\" | \"base64\") => {\n//     // tslint:disable-next-line: no-any\n//     return (Address as any)\n//         .fromBuffer(Buffer.from(encoding === \"hex\" ? strip0x(address) : address, encoding).slice(0, -4))\n//         .toString();\n// };\n\nexport const btcAddressToHex = address => Ox(Buffer.from(address));\n\nconst isBTCAddress = address => validate(address, \"btc\", \"testnet\") || validate(address, \"btc\", \"prod\");\n\nconst btcTactics = {\n  decoders: [address => Buffer.from(address), address => Buffer.from(address, \"base64\"), address => Buffer.from(strip0x(address), \"hex\")],\n  encoders: [buffer => encode(buffer), buffer => buffer.toString()]\n};\nexport const anyAddressFrom = (isAnyAddress, {\n  encoders,\n  decoders\n}) => address => {\n  for (const encoder of encoders) {\n    for (const decoder of decoders) {\n      try {\n        const encoded = encoder(decoder(address));\n\n        if (isAnyAddress(encoded)) {\n          return encoded;\n        }\n      } catch (error) {// Ignore errors\n      }\n    }\n  }\n\n  return address;\n};\nexport const btcAddressFrom = anyAddressFrom(isBTCAddress, btcTactics);","map":{"version":3,"sources":["../../src/btc.ts"],"names":[],"mappings":"AAAA,SAAS,QAAT,EAAmB,MAAnB,EAA2B,MAA3B,QAAyC,aAAzC;AACA,SAAS,MAAT,QAAuB,MAAvB;AACA,SACI,gBADJ,EAEI,OAFJ,EAGI,QAHJ,QAIO,gDAJP;AAKA,SAAS,QAAT,QAAyB,0BAAzB;AAEA,SAAS,aAAT,QAA8B,UAA9B;AACA,SAAS,EAAT,EAAa,OAAb,QAA4B,OAA5B;AAEA,OAAO,MAAM,gBAAgB,GAAG,aAAa,CAAC,QAAD,EAAW,MAAX,EAAmB,MAAnB,CAAtC;AAEP,OAAO,MAAM,eAAe,GAAG,CAAC;AAAE,EAAA;AAAF,CAAD,KAA0C;AACrE,SAAO,OAAO,OAAP,EAAwB,aAAxB,KAAiD;AACpD,WAAO,QAAQ,CAAC,SAAD,EAAY;AAAE,MAAA,OAAF;AAAW,MAAA;AAAX,KAAZ,CAAf;AACH,GAFD;AAGH,CAJM;AAMP,OAAO,MAAM,uBAAuB,GAAG,CAAC;AACpC,EAAA;AADoC,CAAD,KAIlC;AACD,SAAO,MAAO,MAAP,IAAyB;AAC5B,WAAO,gBAAgB,CAAC,SAAD,EAAY,MAAZ,CAAvB;AACH,GAFD;AAGH,CARM;AAUP,OAAO,MAAM,cAAc,GAAG,CAAC;AAAE,EAAA;AAAF,CAAD,KAA0C;AACpE,SAAO,OAAO,MAAP,EAAuB,IAAvB,KAAuC;AAC1C,WAAO,OAAO,CAAC,SAAD,EAAY,MAAZ,EAAoB,IAApB,CAAd;AACH,GAFD;AAGH,CAJM,C,CAMP;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAM,eAAe,GAAI,OAAD,IAAqB,EAAE,CAAC,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAD,CAA/C;;AAEP,MAAM,YAAY,GAAI,OAAD,IACjB,QAAQ,CAAC,OAAD,EAAU,KAAV,EAAiB,SAAjB,CAAR,IAAuC,QAAQ,CAAC,OAAD,EAAU,KAAV,EAAiB,MAAjB,CADnD;;AAQA,MAAM,UAAU,GAAY;AACxB,EAAA,QAAQ,EAAE,CACL,OAAD,IAAqB,MAAM,CAAC,IAAP,CAAY,OAAZ,CADf,EAEL,OAAD,IAAqB,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,QAArB,CAFf,EAGL,OAAD,IAAqB,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,OAAD,CAAnB,EAA8B,KAA9B,CAHf,CADc;AAMxB,EAAA,QAAQ,EAAE,CACL,MAAD,IAAoB,MAAM,CAAC,MAAD,CADpB,EAEL,MAAD,IAAoB,MAAM,CAAC,QAAP,EAFd;AANc,CAA5B;AAYA,OAAO,MAAM,cAAc,GAAG,CAC1B,YAD0B,EAE1B;AAAE,EAAA,QAAF;AAAY,EAAA;AAAZ,CAF0B,KAGxB,OAAD,IAAoB;AACrB,OAAK,MAAM,OAAX,IAAsB,QAAtB,EAAgC;AAC5B,SAAK,MAAM,OAAX,IAAsB,QAAtB,EAAgC;AAC5B,UAAI;AACA,cAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,OAAD,CAAR,CAAvB;;AACA,YAAI,YAAY,CAAC,OAAD,CAAhB,EAA2B;AACvB,iBAAO,OAAP;AACH;AACJ,OALD,CAKE,OAAO,KAAP,EAAc,CACZ;AACH;AACJ;AACJ;;AACD,SAAO,OAAP;AACH,CAjBM;AAmBP,OAAO,MAAM,cAAc,GAAG,cAAc,CAAC,YAAD,EAAe,UAAf,CAArC","sourceRoot":"","sourcesContent":["import { Networks, Opcode, Script } from \"bitcore-lib\";\nimport { encode } from \"bs58\";\nimport { getConfirmations, getUTXO, getUTXOs, } from \"send-crypto/build/main/handlers/BTC/BTCHandler\";\nimport { validate } from \"wallet-address-validator\";\nimport { createAddress } from \"./common\";\nimport { Ox, strip0x } from \"./hex\";\nexport const createBTCAddress = createAddress(Networks, Opcode, Script);\nexport const getBitcoinUTXOs = ({ isTestnet }) => {\n    return async (address, confirmations) => {\n        return getUTXOs(isTestnet, { address, confirmations });\n    };\n};\nexport const getBitcoinConfirmations = ({ isTestnet, }) => {\n    return async (txHash) => {\n        return getConfirmations(isTestnet, txHash);\n    };\n};\nexport const getBitcoinUTXO = ({ isTestnet }) => {\n    return async (txHash, vOut) => {\n        return getUTXO(isTestnet, txHash, vOut);\n    };\n};\n// export const btcAddressToHex = (address: string) => {\n//     const addressBuffer = new Address(address).toBuffer();\n//     // Concatenate checksum\n//     return Ox(Buffer.concat([addressBuffer, Base58Check.checksum(addressBuffer)]));\n// };\n// export const btcAddressFrom = (address: string, encoding: \"hex\" | \"base64\") => {\n//     // tslint:disable-next-line: no-any\n//     return (Address as any)\n//         .fromBuffer(Buffer.from(encoding === \"hex\" ? strip0x(address) : address, encoding).slice(0, -4))\n//         .toString();\n// };\nexport const btcAddressToHex = (address) => Ox(Buffer.from(address));\nconst isBTCAddress = (address) => validate(address, \"btc\", \"testnet\") || validate(address, \"btc\", \"prod\");\nconst btcTactics = {\n    decoders: [\n        (address) => Buffer.from(address),\n        (address) => Buffer.from(address, \"base64\"),\n        (address) => Buffer.from(strip0x(address), \"hex\"),\n    ],\n    encoders: [\n        (buffer) => encode(buffer),\n        (buffer) => buffer.toString(),\n    ],\n};\nexport const anyAddressFrom = (isAnyAddress, { encoders, decoders }) => (address) => {\n    for (const encoder of encoders) {\n        for (const decoder of decoders) {\n            try {\n                const encoded = encoder(decoder(address));\n                if (isAnyAddress(encoded)) {\n                    return encoded;\n                }\n            }\n            catch (error) {\n                // Ignore errors\n            }\n        }\n    }\n    return address;\n};\nexport const btcAddressFrom = anyAddressFrom(isBTCAddress, btcTactics);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnRjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2J0Yy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDdkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM5QixPQUFPLEVBQ0gsZ0JBQWdCLEVBQ2hCLE9BQU8sRUFDUCxRQUFRLEdBQ1gsTUFBTSxnREFBZ0QsQ0FBQztBQUN4RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFcEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUN6QyxPQUFPLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLE9BQU8sQ0FBQztBQUVwQyxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztBQUV4RSxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxFQUFFLFNBQVMsRUFBMEIsRUFBRSxFQUFFO0lBQ3JFLE9BQU8sS0FBSyxFQUFFLE9BQWUsRUFBRSxhQUFxQixFQUFFLEVBQUU7UUFDcEQsT0FBTyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7SUFDM0QsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxFQUNwQyxTQUFTLEdBR1osRUFBRSxFQUFFO0lBQ0QsT0FBTyxLQUFLLEVBQUUsTUFBYyxFQUFFLEVBQUU7UUFDNUIsT0FBTyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDL0MsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQUMsRUFBRSxTQUFTLEVBQTBCLEVBQUUsRUFBRTtJQUNwRSxPQUFPLEtBQUssRUFBRSxNQUFjLEVBQUUsSUFBWSxFQUFFLEVBQUU7UUFDMUMsT0FBTyxPQUFPLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUM7QUFFRix3REFBd0Q7QUFDeEQsNkRBQTZEO0FBQzdELDhCQUE4QjtBQUM5QixzRkFBc0Y7QUFDdEYsS0FBSztBQUVMLG1GQUFtRjtBQUNuRiwwQ0FBMEM7QUFDMUMsOEJBQThCO0FBQzlCLDJHQUEyRztBQUMzRyx1QkFBdUI7QUFDdkIsS0FBSztBQUVMLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUFDLE9BQWUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUU3RSxNQUFNLFlBQVksR0FBRyxDQUFDLE9BQWUsRUFBRSxFQUFFLENBQ3JDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBTzVFLE1BQU0sVUFBVSxHQUFZO0lBQ3hCLFFBQVEsRUFBRTtRQUNOLENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN6QyxDQUFDLE9BQWUsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDO1FBQ25ELENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUM7S0FDNUQ7SUFDRCxRQUFRLEVBQUU7UUFDTixDQUFDLE1BQWMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNsQyxDQUFDLE1BQWMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtLQUN4QztDQUNKLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsQ0FDMUIsWUFBMEMsRUFDMUMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFXLEVBQ2pDLEVBQUUsQ0FBQyxDQUFDLE9BQWUsRUFBRSxFQUFFO0lBQ3JCLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFO1FBQzVCLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFO1lBQzVCLElBQUk7Z0JBQ0EsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUMxQyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDdkIsT0FBTyxPQUFPLENBQUM7aUJBQ2xCO2FBQ0o7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixnQkFBZ0I7YUFDbkI7U0FDSjtLQUNKO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUMifQ=="]},"metadata":{},"sourceType":"module"}