{"ast":null,"code":"'use strict';\n\nvar BN = require('bn.js');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n\nvar reversebuf = function (buf) {\n  var buf2 = Buffer.alloc(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function (n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function (str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\n\n\nBN.fromSM = function (buf, opts) {\n  var ret;\n\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n\n  if (opts) {\n    endian = opts.endian;\n  }\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n\n  return ret;\n};\n\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function (opts) {\n  var buf, hex;\n\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\n\n\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\n\n\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function (buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n\n  return rbuf;\n};\n\nmodule.exports = BN;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib/lib/crypto/bn.js"],"names":["BN","require","$","_","reversebuf","buf","buf2","Buffer","alloc","length","i","Zero","One","Minus1","fromNumber","n","checkArgument","isNumber","fromString","str","base","isString","fromBuffer","opts","endian","hex","toString","bn","fromSM","ret","from","neg","copy","prototype","toNumber","parseInt","toBuffer","size","natlen","trim","pad","toSMBigEndian","cmp","concat","toSM","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","Error","toScriptNumBuffer","slice","rbuf","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar reversebuf = function(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n"]},"metadata":{},"sourceType":"script"}