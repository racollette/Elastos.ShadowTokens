{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar Hash = require('../../crypto/hash');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar Sighash = require('../sighash');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar TransactionSignature = require('../signature');\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\n\n\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\n\ninherits(PublicKeyHashInput, Input);\n/* jshint maxparams: 5 */\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - the signing method used to sign tx \"ecdsa\" or \"schnorr\"\n * @return {Array} of objects that can be\n */\n\nPublicKeyHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n\n  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN, undefined, signingMethod),\n      sigtype: sigtype\n    })];\n  }\n\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod \"ecdsa\" or \"schnorr\"\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyHashInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyHashIn(signature.publicKey, signature.signature.toDER(signingMethod), signature.sigtype));\n  return this;\n};\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyHashInput.prototype.clearSignatures = function () {\n  this.setScript(Script.empty());\n  return this;\n};\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\n\n\nPublicKeyHashInput.prototype.isFullySigned = function () {\n  return this.script.isPublicKeyHashIn();\n};\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.prototype._estimateSize = function () {\n  return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyHashInput;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken2/node_modules/bitcore-lib-cash/lib/transaction/input/publickeyhash.js"],"names":["inherits","require","$","BufferUtil","Hash","Input","Output","Sighash","Script","Signature","TransactionSignature","PublicKeyHashInput","apply","arguments","prototype","getSignatures","transaction","privateKey","index","sigtype","hashData","signingMethod","checkState","output","sha256ripemd160","publicKey","toBuffer","SIGHASH_ALL","SIGHASH_FORKID","equals","script","getPublicKeyHash","prevTxId","outputIndex","inputIndex","signature","sign","satoshisBN","undefined","addSignature","isValidSignature","setScript","buildPublicKeyHashIn","toDER","clearSignatures","empty","isFullySigned","isPublicKeyHashIn","SCRIPT_MAX_SIZE","_estimateSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Hash = require('../../crypto/hash');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\n/* jshint maxparams: 5 */\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - the signing method used to sign tx \"ecdsa\" or \"schnorr\"\n * @return {Array} of objects that can be\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || (Signature.SIGHASH_ALL |  Signature.SIGHASH_FORKID);\n\n  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN, undefined, signingMethod),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod \"ecdsa\" or \"schnorr\"\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n\n  this.setScript(Script.buildPublicKeyHashIn(\n    signature.publicKey,\n    signature.signature.toDER(signingMethod),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn();\n};\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyHashInput;\n"]},"metadata":{},"sourceType":"script"}