{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Transaction = require('../transaction');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar Sighash = require('../sighash');\n\nvar PublicKey = require('../../publickey');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar TransactionSignature = require('../signature');\n/**\n * @constructor\n */\n\n\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else {\n    this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script), 'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n\n  this.threshold = threshold; // Empty array of signatures\n\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\n\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n  var self = this;\n  var results = [];\n\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, self.output.satoshisBN, undefined, signingMethod),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n  this._updateScript(signingMethod);\n\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function (signingMethod) {\n  this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures(signingMethod)));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function (signingMethod) {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(signingMethod), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\n\nMultiSigInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN, undefined, signingMethod);\n};\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\n\n\nMultiSigInput.normalizeSignatures = function (transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script, undefined, signingMethod);\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function () {\n  return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;","map":{"version":3,"sources":["/home/ryan/dev/defi/shadowtoken/node_modules/bitcore-lib-cash/lib/transaction/input/multisig.js"],"names":["_","require","inherits","Transaction","Input","Output","$","Script","Signature","Sighash","PublicKey","BufferUtil","TransactionSignature","MultiSigInput","input","pubkeys","threshold","signatures","opts","apply","arguments","self","publicKeys","noSorting","sortBy","publicKey","toString","checkState","buildMultisigOut","equals","output","script","publicKeyIndex","each","index","_deserializeSignatures","Array","length","prototype","toObject","obj","map","_serializeSignatures","signature","undefined","getSignatures","transaction","privateKey","sigtype","hashData","signingMethod","SIGHASH_ALL","SIGHASH_FORKID","results","push","prevTxId","outputIndex","inputIndex","sign","satoshisBN","addSignature","isFullySigned","checkArgument","isUndefined","isValidSignature","_updateScript","setScript","buildMultisigIn","_createSignatures","filter","concat","toDER","integerAsSingleByteBuffer","clearSignatures","countSignatures","countMissingSignatures","reduce","sum","publicKeysWithoutSignature","nhashtype","verify","normalizeSignatures","pubKey","signatureMatch","signatureBuffer","fromTxFormat","isMatch","OPCODES_SIZE","SIGNATURE_SIZE","_estimateSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Transaction = require('../transaction');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar PublicKey = require('../../publickey');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || (Signature.SIGHASH_ALL |  Signature.SIGHASH_FORKID);\n\n  var self = this;\n  var results = [];\n  _.each(this.publicKeys, function(publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, self.output.satoshisBN, undefined, signingMethod),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript(signingMethod);\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function(signingMethod) {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures(signingMethod)\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function(signingMethod) {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(signingMethod),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script,\n    this.output.satoshisBN,\n    undefined,\n    signingMethod\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script,\n          undefined,\n          signingMethod\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n"]},"metadata":{},"sourceType":"script"}