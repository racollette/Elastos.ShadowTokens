{"ast":null,"code":"/* eslint-disable */\nimport createLogger from 'logging';\nimport debugLogger from 'debug';\nimport { isBrowser } from 'browser-or-node';\nimport uuid from 'uuid/v4';\nimport WebSocket from '../websocketWrapper';\nimport wrtc from 'wrtc';\nimport MewConnectCommon from '../MewConnectCommon';\nimport MewConnectCrypto from '../MewConnectCrypto';\nimport WebRtcCommunication from '../WebRtcCommunication';\nconst debug = debugLogger('MEWconnect:initiator-V2');\nconst debugTurn = debugLogger('MEWconnect:turn-V2');\nconst debugPeer = debugLogger('MEWconnectVerbose:peer-instances-V2');\nconst debugStages = debugLogger('MEWconnect:initiator-stages-V2');\nconst logger = createLogger('MewConnectInitiator-V2');\nexport default class MewConnectInitiatorV2 extends MewConnectCommon {\n  constructor(options = {}) {\n    super('V2');\n\n    try {\n      this.uiCommunicator = options.uiCommunicator;\n      this.supportedBrowser = MewConnectCommon.checkBrowser();\n      this.activePeerId = '';\n      this.allPeerIds = [];\n      this.peersCreated = [];\n      this.Url = options.url || 'wss://connect2.mewapi.io/staging';\n      this.active = true;\n      this.turnTest = options.turnTest;\n      this.p = null;\n      this.socketConnected = false;\n      this.socketV1Connected = false;\n      this.connected = false;\n      this.tryingTurn = false;\n      this.turnDisabled = false;\n      this.signalUrl = null;\n      this.iceState = '';\n      this.turnServers = [];\n      this.states = this.setResetStates();\n      this.webRtcCommunication = options.webRtcCommunication;\n      this.socket = new WebSocket();\n      this.signals = this.jsonDetails.signals;\n      this.signals = this.jsonDetails.signalsV2;\n      this.rtcEvents = this.jsonDetails.rtc;\n      this.version = this.jsonDetails.version;\n      this.versions = this.jsonDetails.versions;\n      this.lifeCycle = this.jsonDetails.lifeCycle;\n      this.stunServers = options.stunServers || this.jsonDetails.stunSrvers;\n      this.iceStates = this.jsonDetails.iceConnectionState;\n      this.initiatorId = uuid();\n      this.isActiveInstance = true; // Socket is abandoned.  disconnect.\n\n      this.timer = null; // setTimeout(() => {\n      //   if (this.socket) {\n      //     this.socketDisconnect();\n      //   }\n      // }, 120000);\n    } catch (e) {\n      debug('constructor error:', e);\n    }\n\n    this.webRtcCommunication.on('useFallback', id => {\n      debug('USING TURN FALLBACK');\n\n      if (this.initiatorId === id) {\n        this.useFallback();\n      } else {\n        this.socketDisconnect();\n        this.isActiveInstance = false; // this.webRtcCommunication.off('data', this.onData.bind(this, ''));\n      }\n    });\n  }\n\n  setResetStates() {\n    return {\n      offerSent: false,\n      answerReceived: false\n    };\n  }\n\n  isAlive() {\n    if (this.p !== null) {\n      return this.p.connected && !this.p.destroyed;\n    }\n\n    return false;\n  }\n\n  setWebRtc(webRtcCommunication) {\n    this.webRtcCommunication = webRtcCommunication;\n  }\n\n  static checkBrowser() {\n    return MewConnectCommon.checkBrowser();\n  }\n\n  static checkWebRTCAvailable() {\n    return MewConnectCommon.checkWebRTCAvailable();\n  } // Returns a boolean indicating whether the socket connection exists and is active\n\n\n  getSocketConnectionState() {\n    return this.socketV1Connected || this.socketConnected;\n  } // Returns a boolean indicating whether the WebRTC connection exists and is active\n\n\n  getConnectonState() {\n    return this.connected;\n  } // can be used to listen to specific events, especially those that pass data\n\n\n  uiCommunicator(event, data) {\n    this.emit(event, data);\n    this.emitStatus(event);\n  } // special status emitter to allow simple listening of various statuses in one listener\n\n\n  emitStatus(event) {\n    this.emit('status', event);\n  } // Emit/Provide the details used in creating the QR Code\n\n\n  displayCode(privateKey) {\n    try {\n      if (privateKey instanceof Buffer) {\n        privateKey = privateKey.toString('hex');\n      }\n\n      debug('handshake', privateKey);\n      this.socketKey = privateKey;\n      const separator = this.jsonDetails.connectionCodeSeparator;\n      const qrCodeString = this.version + separator + privateKey + separator + this.connId;\n      debug(qrCodeString);\n      this.uiCommunicator(this.lifeCycle.codeDisplay, qrCodeString);\n      this.uiCommunicator(this.lifeCycle.checkNumber, privateKey);\n      this.uiCommunicator(this.lifeCycle.ConnectionId, this.connId);\n    } catch (e) {\n      debug('displayCode error:', e);\n    }\n  }\n\n  async initiatorStart(url = this.Url, cryptoInstance, details = {}) {\n    this.connId = details.connId;\n    this.signed = details.signed;\n\n    try {\n      debug('initiatorStart V2');\n      this.mewCrypto = cryptoInstance;\n      this.uiCommunicator(this.lifeCycle.signatureCheck);\n      await this.connect(url); // this.socket = this.socketManager.connect();\n\n      this.initiatorConnect();\n    } catch (e) {\n      debug('initiatorStart error:', e);\n    }\n  }\n\n  async connect(websocketURL, options = null) {\n    try {\n      if (typeof jest !== 'undefined' && this.connId === null) {// for tests only\n        // this.generateKeys();\n      }\n\n      const queryOptions = options ? options : {\n        role: this.jsonDetails.stages.initiator,\n        connId: this.connId,\n        signed: this.signed\n      };\n      debug(websocketURL, queryOptions);\n      await this.socket.connect(this.Url, queryOptions);\n    } catch (e) {\n      debug('connect error:', e);\n    }\n  }\n\n  async regenerateCode() {\n    if (this.signalUrl === null) {\n      throw Error('regenerateCode called before initial code generation');\n    }\n\n    this.socketDisconnect();\n    this.initiatorStart(this.signalUrl);\n  }\n\n  async useFallback() {\n    this.socketEmit(this.signals.tryTurn, {\n      connId: this.connId\n    });\n  }\n\n  socketEmit(signal, data) {\n    try {\n      if (this.socket) this.socket.send(signal, data);\n    } catch (e) {\n      debug('socketEmit error:', e);\n    }\n  }\n\n  socketDisconnect() {\n    debug(`Socket already disconnected: ${this.active}`);\n    this.active = false;\n    if (this.socket) this.socket.disconnect().catch(err => {\n      debug('socketDisconnect', err);\n    });\n    debug('webSocket Disconnected');\n    this.socket = null;\n    this.socketConnected = false;\n  }\n\n  socketOn(signal, func) {\n    try {\n      this.socket.on(signal, func);\n    } catch (e) {\n      debug('socketOn error:', e);\n    }\n  }\n\n  initiatorConnect() {\n    try {\n      debugStages('INITIATOR CONNECT');\n      this.uiCommunicator(this.lifeCycle.SocketConnectedEvent);\n      this.socket.on(this.signals.connect, () => {\n        debugStages('SOCKET CONNECTED');\n        this.socketConnected = true;\n      });\n      this.socketOn(this.signals.initiated, this.initiated.bind(this)); // response\n\n      this.socketOn(this.signals.confirmation, this.beginRtcSequence.bind(this, '')); // response\n      // this.signals.answer\n\n      this.socketOn('answer', this.recieveAnswer.bind(this));\n      this.socketOn(this.signals.confirmationFailedBusy, this.busyFailure.bind(this));\n      this.socketOn(this.signals.confirmationFailed, this.confirmationFailure.bind(this));\n      this.socketOn(this.signals.invalidConnection, this.invalidFailure.bind(this));\n      this.socketOn(this.signals.disconnect, this.socketDisconnectHandler.bind(this));\n      this.socketOn(this.signals.attemptingTurn, this.willAttemptTurn.bind(this));\n      this.socketOn(this.signals.turnToken, this.beginTurn.bind(this));\n    } catch (e) {\n      debug('initiatorConnect error:', e);\n    }\n  } // Handle Socket Disconnect Event\n\n\n  socketDisconnectHandler(reason) {\n    debug(reason);\n    this.socketConnected = false;\n  } // ----- Failure Handlers\n  // Handle Socket Attempting Turn informative signal\n  // Provide Notice that initial WebRTC connection failed and the fallback method will be used\n\n\n  willAttemptTurn() {\n    this.tryingTurn = true;\n    debugTurn('TRY TURN CONNECTION');\n    this.uiCommunicator(this.lifeCycle.UsingFallback);\n  } // Handle Socket event to initiate turn connection\n  // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN\n\n\n  beginTurn(data) {\n    this.tryingTurn = true;\n    this.webRtcCommunication.turnReset(this.activePeerId);\n    this.retryViaTurn(data);\n  } // Handle Failure due to an attempt to join a connection with two existing endpoints\n\n\n  busyFailure() {\n    this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.confirmationFailedBusyEvent);\n    debug('confirmation Failed: Busy');\n  } // Handle Failure due to no opposing peer existing\n\n\n  invalidFailure() {\n    this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.invalidConnectionEvent);\n    debug('confirmation Failed: no opposite peer found');\n  } // Handle Failure due to the handshake/ verify details being invalid for the connection ID\n\n\n  confirmationFailure() {\n    this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.confirmationFailedEvent);\n    debug('confirmation Failed: invalid confirmation');\n  }\n\n  initiated(data) {\n    this.uiCommunicator(this.signals.initiated, data);\n    debug('initiator', this.signals.initiated, data);\n  }\n\n  beginRtcSequence(data) {\n    this.emit('socketPaired');\n    this.emit('beginRtcSequence', 'V2');\n\n    try {\n      debug('beginRtcSequence ');\n      debug('sendOffer', data);\n      this.iceServers = null;\n      const options = {\n        servers: this.stunServers,\n        webRtcConfig: {\n          initiator: true,\n          trickle: false,\n          iceTransportPolicy: 'relay',\n          config: {\n            iceServers: this.stunServers\n          },\n          wrtc: wrtc\n        }\n      };\n      this.initiatorStartRTC(options);\n    } catch (e) {\n      debug('beginRtcSequence error:', e);\n    }\n  }\n\n  async sendOffer(data) {\n    if (!this.isActiveInstance) return;\n    debug('sendOffer');\n\n    try {\n      this.emit('sendingOffer');\n      debug('SIGNAL', JSON.stringify(data));\n      const encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(data));\n      this.uiCommunicator(this.lifeCycle.sendOffer);\n      this.states.offer = true;\n      this.socketEmit(this.signals.offerSignal, {\n        data: encryptedSend,\n        connId: this.connId\n      });\n    } catch (e) {\n      logger.error(e);\n      debug('sendOffer error:', e);\n    }\n  } // Handle the WebRTC ANSWER from the opposite (mobile) peer\n\n\n  async recieveAnswer(data) {\n    if (!this.isActiveInstance) return;\n    debug('received answer');\n\n    try {\n      const plainTextOffer = await this.mewCrypto.decrypt(data.data);\n      this.uiCommunicator(this.lifeCycle.answerReceived);\n      debug(plainTextOffer);\n      this.webRtcCommunication.receiveAnswer(JSON.parse(plainTextOffer), this.activePeerId);\n      debug('answer relayed to webRTC instance');\n    } catch (e) {\n      logger.error(e);\n      debug('recieveAnswer error:', e);\n    }\n  }\n\n  setActivePeerId(peerId) {\n    this.activePeerId = peerId; // this.allPeerIds.push(this.activePeerId);\n  }\n\n  getActivePeerId() {\n    const split = this.activePeerId.split('-');\n    return split.join('-');\n  }\n\n  initiatorStartRTC(options) {\n    try {\n      debug('initiatorStartRTC');\n      const webRtcConfig = options.webRtcConfig || {};\n      const webRtcServers = webRtcConfig.servers || this.stunServers;\n      this.iceServers = null;\n      const defaultOptions = {\n        initiator: true,\n        trickle: false,\n        iceTransportPolicy: 'relay',\n        config: {\n          iceServers: webRtcServers\n        },\n        wrtc: wrtc\n      }; //\n\n      const simpleOptions = { ...defaultOptions,\n        ...webRtcConfig\n      };\n      this.webRtcCommunication.setConnectionVersion('V2');\n      this.webRtcCommunication.start(simpleOptions);\n      debug(`initiatorStartRTC - options: ${simpleOptions}`);\n      this.uiCommunicator(this.lifeCycle.RtcInitiatedEvent); // this.p = new this.Peer(simpleOptions);\n\n      const peerID = this.webRtcCommunication.getActivePeerId();\n      this.setActivePeerId(peerID);\n      this.webRtcCommunication.once('connect', this.onConnect.bind(this, peerID));\n      this.webRtcCommunication.once('signal', this.sendOffer.bind(this));\n      this.webRtcCommunication.once('data', this.onData.bind(this, peerID));\n    } catch (e) {\n      debug('initiatorStartRTC error:', e);\n    }\n  }\n\n  onConnect(peerID) {\n    if (!this.isActiveInstance) return;\n\n    try {\n      debugStages('RTC CONNECT', 'ok');\n      debug('peerID', peerID);\n      this.connected = true;\n      this.turnDisabled = true;\n      this.webRtcCommunication.on('data', this.onData.bind(this, peerID));\n      this.socketEmit(this.signals.rtcConnected, this.socketKey);\n      this.socketDisconnect();\n      this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);\n    } catch (e) {\n      debug('onConnect error:', e);\n    }\n  }\n\n  async decryptIncomming(data) {\n    if (this.isJSON(data)) {\n      const parsedJson = JSON.parse(data);\n\n      if (parsedJson.type && parsedJson.data) {\n        return parsedJson;\n      }\n\n      return await this.mewCrypto.decrypt(JSON.parse(data));\n    } else {\n      if (data.type && data.data) {\n        return data;\n      }\n\n      return await this.mewCrypto.decrypt(JSON.parse(JSON.stringify(data)));\n    }\n  }\n\n  async onData(peerID, data) {\n    debug(data); // todo remove dev item\n\n    debug('DATA RECEIVED', data.toString());\n    debug('peerID', peerID);\n\n    try {\n      let decryptedData = await this.decryptIncomming(data);\n\n      if (this.isJSON(decryptedData)) {\n        const parsed = JSON.parse(decryptedData);\n        debug('DECRYPTED DATA RECEIVED 1', parsed);\n        this.emit(parsed.type, parsed.data);\n      } else {\n        debug('DECRYPTED DATA RECEIVED 2', decryptedData);\n        this.emit(decryptedData.type, decryptedData.data);\n      }\n    } catch (e) {\n      logger.error(e);\n      debug('onData ERROR: data=', data);\n      debug('onData ERROR: data.toString()=', data.toString());\n    }\n  }\n\n  onClose(peerID, data) {\n    debugStages('WRTC MAYBE CLOSE');\n    debug('peerID', peerID);\n\n    if (!this.isAlive()) {\n      debugStages('WRTC CLOSE', data);\n\n      if (this.connected) {\n        // this.uiCommunicator(this.lifeCycle.RtcClosedEvent);\n        this.connected = false;\n      } else {\n        this.connected = false;\n      }\n    }\n  }\n\n  onError(peerID, err) {\n    debugStages('WRTC ERROR');\n    debug('peerID', peerID);\n    debug(err.code);\n    debug('error', err);\n\n    if (!this.connected && !this.tryingTurn && !this.turnDisabled) {\n      this.useFallback();\n    } else {\n      if (!this.isAlive()) {\n        this.uiCommunicator(this.lifeCycle.RtcErrorEvent);\n      }\n    }\n  } // ----- WebRTC Communication Methods\n\n\n  sendRtcMessageClosure(type, msg) {\n    return () => {\n      debug(`[SEND RTC MESSAGE Closure] type:  ${type},  message:  ${msg}`);\n      this.rtcSend(JSON.stringify({\n        type,\n        data: msg\n      }));\n    };\n  }\n\n  sendRtcMessage(type, msg) {\n    debug(`[SEND RTC MESSAGE] type:  ${type},  message:  ${msg}`);\n    this.rtcSend(JSON.stringify({\n      type,\n      data: msg\n    }));\n  }\n\n  async rtcSend(arg) {\n    if (this.isAlive()) {\n      let encryptedSend;\n\n      if (typeof arg === 'string') {\n        encryptedSend = await this.mewCrypto.encrypt(arg);\n      } else {\n        encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(arg));\n      }\n\n      debug('SENDING RTC');\n      this.p.send(JSON.stringify(encryptedSend));\n    } else {\n      // eslint-disable-next-line\n      this.uiCommunicator(this.lifeCycle.attemptedDisconnectedSend);\n      return false;\n    }\n  }\n\n  rtcDestroy() {\n    if (this.active) {\n      this.webRtcCommunication.rtcDestroy();\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);\n    }\n  }\n\n  disconnectRTCClosure() {\n    return () => {\n      debugStages('DISCONNECT RTC Closure');\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n      this.rtcDestroy();\n      this.instance = null;\n    };\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.rtcDestroy();\n    this.instance = null;\n  }\n\n  retryViaTurn(data) {\n    try {\n      this.emit('retryingViaTurn');\n      this.states = this.setResetStates();\n      debugTurn('Retrying via TURN v2');\n      this.iceServers = null;\n      const options = {\n        servers: data.iceServers.map(obj => {\n          const newObject = {};\n          delete Object.assign(newObject, obj, {\n            ['urls']: obj['url']\n          })['url'];\n          return newObject;\n        }),\n        webRtcConfig: {\n          initiator: true,\n          trickle: false,\n          iceTransportPolicy: 'relay',\n          config: {\n            iceServers: data.iceServers.map(obj => {\n              const newObject = {};\n              delete Object.assign(newObject, obj, {\n                ['urls']: obj['url']\n              })['url'];\n              return newObject;\n            })\n          },\n          wrtc: wrtc\n        }\n      };\n      debug('turn info arrived and begin turn'); // todo remove dev item\n\n      this.initiatorStartRTC(options);\n    } catch (e) {\n      debugTurn('retryViaTurn error:', e);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/ryan/dev/defi/bridge/node_modules/@myetherwallet/mewconnect-web-client/src/connectClient/initiator/MewConnectInitiatorV2.js"],"names":["createLogger","debugLogger","isBrowser","uuid","WebSocket","wrtc","MewConnectCommon","MewConnectCrypto","WebRtcCommunication","debug","debugTurn","debugPeer","debugStages","logger","MewConnectInitiatorV2","constructor","options","uiCommunicator","supportedBrowser","checkBrowser","activePeerId","allPeerIds","peersCreated","Url","url","active","turnTest","p","socketConnected","socketV1Connected","connected","tryingTurn","turnDisabled","signalUrl","iceState","turnServers","states","setResetStates","webRtcCommunication","socket","signals","jsonDetails","signalsV2","rtcEvents","rtc","version","versions","lifeCycle","stunServers","stunSrvers","iceStates","iceConnectionState","initiatorId","isActiveInstance","timer","e","on","id","useFallback","socketDisconnect","offerSent","answerReceived","isAlive","destroyed","setWebRtc","checkWebRTCAvailable","getSocketConnectionState","getConnectonState","event","data","emit","emitStatus","displayCode","privateKey","Buffer","toString","socketKey","separator","connectionCodeSeparator","qrCodeString","connId","codeDisplay","checkNumber","ConnectionId","initiatorStart","cryptoInstance","details","signed","mewCrypto","signatureCheck","connect","initiatorConnect","websocketURL","jest","queryOptions","role","stages","initiator","regenerateCode","Error","socketEmit","tryTurn","signal","send","disconnect","catch","err","socketOn","func","SocketConnectedEvent","initiated","bind","confirmation","beginRtcSequence","recieveAnswer","confirmationFailedBusy","busyFailure","confirmationFailed","confirmationFailure","invalidConnection","invalidFailure","socketDisconnectHandler","attemptingTurn","willAttemptTurn","turnToken","beginTurn","reason","UsingFallback","turnReset","retryViaTurn","Failed","confirmationFailedBusyEvent","invalidConnectionEvent","confirmationFailedEvent","iceServers","servers","webRtcConfig","trickle","iceTransportPolicy","config","initiatorStartRTC","sendOffer","JSON","stringify","encryptedSend","encrypt","offer","offerSignal","error","plainTextOffer","decrypt","receiveAnswer","parse","setActivePeerId","peerId","getActivePeerId","split","join","webRtcServers","defaultOptions","simpleOptions","setConnectionVersion","start","RtcInitiatedEvent","peerID","once","onConnect","onData","rtcConnected","RtcConnectedEvent","decryptIncomming","isJSON","parsedJson","type","decryptedData","parsed","onClose","onError","code","RtcErrorEvent","sendRtcMessageClosure","msg","rtcSend","sendRtcMessage","arg","attemptedDisconnectedSend","rtcDestroy","RtcDestroyedEvent","disconnectRTCClosure","RtcDisconnectEvent","instance","disconnectRTC","map","obj","newObject","Object","assign"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport createLogger from 'logging';\nimport debugLogger from 'debug';\nimport { isBrowser } from 'browser-or-node';\nimport uuid from 'uuid/v4';\nimport WebSocket from '../websocketWrapper';\nimport wrtc from 'wrtc';\nimport MewConnectCommon from '../MewConnectCommon';\nimport MewConnectCrypto from '../MewConnectCrypto';\nimport WebRtcCommunication from '../WebRtcCommunication';\n\nconst debug = debugLogger('MEWconnect:initiator-V2');\nconst debugTurn = debugLogger('MEWconnect:turn-V2');\nconst debugPeer = debugLogger('MEWconnectVerbose:peer-instances-V2');\nconst debugStages = debugLogger('MEWconnect:initiator-stages-V2');\nconst logger = createLogger('MewConnectInitiator-V2');\n\nexport default class MewConnectInitiatorV2 extends MewConnectCommon {\n  constructor(options = {}) {\n    super('V2');\n    try {\n      this.uiCommunicator = options.uiCommunicator;\n      this.supportedBrowser = MewConnectCommon.checkBrowser();\n\n      this.activePeerId = '';\n      this.allPeerIds = [];\n      this.peersCreated = [];\n      this.Url = options.url || 'wss://connect2.mewapi.io/staging';\n      this.active = true;\n      this.turnTest = options.turnTest;\n\n      this.p = null;\n      this.socketConnected = false;\n      this.socketV1Connected = false;\n      this.connected = false;\n      this.tryingTurn = false;\n      this.turnDisabled = false;\n      this.signalUrl = null;\n      this.iceState = '';\n      this.turnServers = [];\n      this.states = this.setResetStates();\n\n      this.webRtcCommunication = options.webRtcCommunication;\n\n      this.socket = new WebSocket();\n\n      this.signals = this.jsonDetails.signals;\n      this.signals = this.jsonDetails.signalsV2;\n      this.rtcEvents = this.jsonDetails.rtc;\n      this.version = this.jsonDetails.version;\n      this.versions = this.jsonDetails.versions;\n      this.lifeCycle = this.jsonDetails.lifeCycle;\n      this.stunServers = options.stunServers || this.jsonDetails.stunSrvers;\n      this.iceStates = this.jsonDetails.iceConnectionState;\n      this.initiatorId = uuid();\n      this.isActiveInstance = true;\n      // Socket is abandoned.  disconnect.\n      this.timer = null;\n      // setTimeout(() => {\n      //   if (this.socket) {\n      //     this.socketDisconnect();\n      //   }\n      // }, 120000);\n    } catch (e) {\n      debug('constructor error:', e);\n    }\n\n    this.webRtcCommunication.on('useFallback', (id) => {\n      debug('USING TURN FALLBACK');\n      if(this.initiatorId === id){\n        this.useFallback();\n      } else {\n        this.socketDisconnect();\n        this.isActiveInstance = false;\n        // this.webRtcCommunication.off('data', this.onData.bind(this, ''));\n      }\n    });\n  }\n\n  setResetStates() {\n    return {\n      offerSent: false,\n      answerReceived: false\n    };\n  }\n\n  isAlive() {\n    if (this.p !== null) {\n      return this.p.connected && !this.p.destroyed;\n    }\n    return false;\n  }\n\n  setWebRtc(webRtcCommunication) {\n    this.webRtcCommunication = webRtcCommunication;\n  }\n\n  static checkBrowser() {\n    return MewConnectCommon.checkBrowser();\n  }\n\n  static checkWebRTCAvailable() {\n    return MewConnectCommon.checkWebRTCAvailable();\n  }\n\n  // Returns a boolean indicating whether the socket connection exists and is active\n  getSocketConnectionState() {\n    return this.socketV1Connected || this.socketConnected;\n  }\n\n  // Returns a boolean indicating whether the WebRTC connection exists and is active\n  getConnectonState() {\n    return this.connected;\n  }\n\n  // can be used to listen to specific events, especially those that pass data\n  uiCommunicator(event, data) {\n    this.emit(event, data);\n    this.emitStatus(event);\n  }\n\n  // special status emitter to allow simple listening of various statuses in one listener\n  emitStatus(event) {\n    this.emit('status', event);\n  }\n\n  // Emit/Provide the details used in creating the QR Code\n  displayCode(privateKey) {\n    try {\n      if (privateKey instanceof Buffer) {\n        privateKey = privateKey.toString('hex');\n      }\n      debug('handshake', privateKey);\n      this.socketKey = privateKey;\n      const separator = this.jsonDetails.connectionCodeSeparator;\n      const qrCodeString =\n        this.version + separator + privateKey + separator + this.connId;\n\n      debug(qrCodeString);\n\n      this.uiCommunicator(this.lifeCycle.codeDisplay, qrCodeString);\n      this.uiCommunicator(this.lifeCycle.checkNumber, privateKey);\n      this.uiCommunicator(this.lifeCycle.ConnectionId, this.connId);\n    } catch (e) {\n      debug('displayCode error:', e);\n    }\n  }\n\n  async initiatorStart(url = this.Url, cryptoInstance, details = {}) {\n    this.connId = details.connId;\n    this.signed = details.signed;\n    try {\n      debug('initiatorStart V2');\n      this.mewCrypto = cryptoInstance;\n      this.uiCommunicator(this.lifeCycle.signatureCheck);\n      await this.connect(url);\n      // this.socket = this.socketManager.connect();\n      this.initiatorConnect();\n    } catch (e) {\n      debug('initiatorStart error:', e);\n    }\n  }\n  async connect(websocketURL, options = null) {\n    try {\n      if (typeof jest !== 'undefined' && this.connId === null) {\n        // for tests only\n        // this.generateKeys();\n      }\n      const queryOptions = options\n        ? options\n        : {\n            role: this.jsonDetails.stages.initiator,\n            connId: this.connId,\n            signed: this.signed\n          };\n\n      debug(websocketURL, queryOptions);\n      await this.socket.connect(this.Url, queryOptions);\n    } catch (e) {\n      debug('connect error:', e);\n    }\n  }\n\n  async regenerateCode() {\n    if (this.signalUrl === null) {\n      throw Error('regenerateCode called before initial code generation');\n    }\n    this.socketDisconnect();\n    this.initiatorStart(this.signalUrl);\n  }\n\n  async useFallback() {\n    this.socketEmit(this.signals.tryTurn, { connId: this.connId });\n  }\n\n  socketEmit(signal, data) {\n    try {\n      if (this.socket) this.socket.send(signal, data);\n    } catch (e) {\n      debug('socketEmit error:', e);\n    }\n  }\n\n  socketDisconnect() {\n    debug(`Socket already disconnected: ${this.active}`);\n    this.active = false;\n    if (this.socket)\n      this.socket.disconnect().catch(err => {\n        debug('socketDisconnect', err);\n      });\n    debug('webSocket Disconnected');\n    this.socket = null;\n    this.socketConnected = false;\n  }\n\n  socketOn(signal, func) {\n    try {\n      this.socket.on(signal, func);\n    } catch (e) {\n      debug('socketOn error:', e);\n    }\n  }\n\n  initiatorConnect() {\n    try {\n      debugStages('INITIATOR CONNECT');\n      this.uiCommunicator(this.lifeCycle.SocketConnectedEvent);\n\n      this.socket.on(this.signals.connect, () => {\n        debugStages('SOCKET CONNECTED');\n        this.socketConnected = true;\n      });\n\n      this.socketOn(this.signals.initiated, this.initiated.bind(this)); // response\n      this.socketOn(\n        this.signals.confirmation,\n        this.beginRtcSequence.bind(this, '')\n      ); // response\n      // this.signals.answer\n      this.socketOn('answer', this.recieveAnswer.bind(this));\n      this.socketOn(\n        this.signals.confirmationFailedBusy,\n        this.busyFailure.bind(this)\n      );\n      this.socketOn(\n        this.signals.confirmationFailed,\n        this.confirmationFailure.bind(this)\n      );\n      this.socketOn(\n        this.signals.invalidConnection,\n        this.invalidFailure.bind(this)\n      );\n      this.socketOn(\n        this.signals.disconnect,\n        this.socketDisconnectHandler.bind(this)\n      );\n      this.socketOn(\n        this.signals.attemptingTurn,\n        this.willAttemptTurn.bind(this)\n      );\n      this.socketOn(this.signals.turnToken, this.beginTurn.bind(this));\n    } catch (e) {\n      debug('initiatorConnect error:', e);\n    }\n  }\n\n  // Handle Socket Disconnect Event\n  socketDisconnectHandler(reason) {\n    debug(reason);\n    this.socketConnected = false;\n  }\n\n  // ----- Failure Handlers\n  // Handle Socket Attempting Turn informative signal\n  // Provide Notice that initial WebRTC connection failed and the fallback method will be used\n  willAttemptTurn() {\n    this.tryingTurn = true;\n    debugTurn('TRY TURN CONNECTION');\n    this.uiCommunicator(this.lifeCycle.UsingFallback);\n  }\n\n  // Handle Socket event to initiate turn connection\n  // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN\n  beginTurn(data) {\n    this.tryingTurn = true;\n    this.webRtcCommunication.turnReset(this.activePeerId);\n    this.retryViaTurn(data);\n  }\n\n  // Handle Failure due to an attempt to join a connection with two existing endpoints\n  busyFailure() {\n    this.uiCommunicator(\n      this.lifeCycle.Failed,\n      this.lifeCycle.confirmationFailedBusyEvent\n    );\n    debug('confirmation Failed: Busy');\n  }\n\n  // Handle Failure due to no opposing peer existing\n  invalidFailure() {\n    this.uiCommunicator(\n      this.lifeCycle.Failed,\n      this.lifeCycle.invalidConnectionEvent\n    );\n    debug('confirmation Failed: no opposite peer found');\n  }\n\n  // Handle Failure due to the handshake/ verify details being invalid for the connection ID\n  confirmationFailure() {\n    this.uiCommunicator(\n      this.lifeCycle.Failed,\n      this.lifeCycle.confirmationFailedEvent\n    );\n    debug('confirmation Failed: invalid confirmation');\n  }\n\n  initiated(data) {\n    this.uiCommunicator(this.signals.initiated, data);\n    debug('initiator', this.signals.initiated, data);\n  }\n\n  beginRtcSequence(data) {\n    this.emit('socketPaired');\n    this.emit('beginRtcSequence', 'V2');\n    try {\n      debug('beginRtcSequence ');\n      debug('sendOffer', data);\n      this.iceServers = null;\n      const options = {\n        servers: this.stunServers,\n        webRtcConfig: {\n          initiator: true,\n          trickle: false,\n          iceTransportPolicy: 'relay',\n          config: {\n            iceServers: this.stunServers\n          },\n          wrtc: wrtc\n        }\n      };\n\n      this.initiatorStartRTC(options);\n    } catch (e) {\n      debug('beginRtcSequence error:', e);\n    }\n  }\n\n  async sendOffer(data) {\n    if(!this.isActiveInstance) return;\n    debug('sendOffer');\n    try {\n      this.emit('sendingOffer');\n      debug('SIGNAL', JSON.stringify(data));\n      const encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(data));\n      this.uiCommunicator(this.lifeCycle.sendOffer);\n      this.states.offer = true;\n      this.socketEmit(this.signals.offerSignal, {\n        data: encryptedSend,\n        connId: this.connId\n      });\n    } catch (e) {\n      logger.error(e);\n      debug('sendOffer error:', e);\n    }\n  }\n\n  // Handle the WebRTC ANSWER from the opposite (mobile) peer\n  async recieveAnswer(data) {\n    if(!this.isActiveInstance) return;\n    debug('received answer');\n    try {\n      const plainTextOffer = await this.mewCrypto.decrypt(data.data);\n      this.uiCommunicator(this.lifeCycle.answerReceived);\n      debug(plainTextOffer);\n      this.webRtcCommunication.receiveAnswer(\n        JSON.parse(plainTextOffer),\n        this.activePeerId\n      );\n      debug('answer relayed to webRTC instance');\n    } catch (e) {\n      logger.error(e);\n      debug('recieveAnswer error:', e);\n    }\n  }\n\n  setActivePeerId(peerId) {\n    this.activePeerId = peerId;\n    // this.allPeerIds.push(this.activePeerId);\n  }\n\n  getActivePeerId() {\n    const split = this.activePeerId.split('-');\n    return split.join('-');\n  }\n\n  initiatorStartRTC(options) {\n    try {\n      debug('initiatorStartRTC');\n      const webRtcConfig = options.webRtcConfig || {};\n      const webRtcServers = webRtcConfig.servers || this.stunServers;\n\n      this.iceServers = null;\n      const defaultOptions = {\n        initiator: true,\n        trickle: false,\n        iceTransportPolicy: 'relay',\n        config: {\n          iceServers: webRtcServers\n        },\n        wrtc: wrtc\n      };\n\n      //\n      const simpleOptions = {\n        ...defaultOptions,\n        ...webRtcConfig\n      };\n\n      this.webRtcCommunication.setConnectionVersion('V2');\n      this.webRtcCommunication.start(simpleOptions);\n\n      debug(`initiatorStartRTC - options: ${simpleOptions}`);\n      this.uiCommunicator(this.lifeCycle.RtcInitiatedEvent);\n      // this.p = new this.Peer(simpleOptions);\n      const peerID = this.webRtcCommunication.getActivePeerId();\n      this.setActivePeerId(peerID);\n      this.webRtcCommunication.once('connect', this.onConnect.bind(this, peerID));\n      this.webRtcCommunication.once('signal', this.sendOffer.bind(this));\n      this.webRtcCommunication.once('data', this.onData.bind(this, peerID));\n    } catch (e) {\n      debug('initiatorStartRTC error:', e);\n    }\n  }\n\n  onConnect(peerID) {\n    if(!this.isActiveInstance) return;\n    try {\n      debugStages('RTC CONNECT', 'ok');\n      debug('peerID', peerID);\n      this.connected = true;\n      this.turnDisabled = true;\n      this.webRtcCommunication.on('data', this.onData.bind(this, peerID));\n      this.socketEmit(this.signals.rtcConnected, this.socketKey);\n      this.socketDisconnect();\n      this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);\n    } catch (e) {\n      debug('onConnect error:', e);\n    }\n  }\n\n  async decryptIncomming(data) {\n    if (this.isJSON(data)) {\n      const parsedJson = JSON.parse(data);\n      if (parsedJson.type && parsedJson.data) {\n        return parsedJson;\n      }\n      return await this.mewCrypto.decrypt(JSON.parse(data));\n    } else {\n      if (data.type && data.data) {\n        return data;\n      }\n      return await this.mewCrypto.decrypt(JSON.parse(JSON.stringify(data)));\n    }\n  }\n\n  async onData(peerID, data) {\n    debug(data); // todo remove dev item\n    debug('DATA RECEIVED', data.toString());\n    debug('peerID', peerID);\n    try {\n      let decryptedData = await this.decryptIncomming(data);\n\n      if (this.isJSON(decryptedData)) {\n        const parsed = JSON.parse(decryptedData);\n        debug('DECRYPTED DATA RECEIVED 1', parsed);\n        this.emit(parsed.type, parsed.data);\n      } else {\n        debug('DECRYPTED DATA RECEIVED 2', decryptedData);\n        this.emit(decryptedData.type, decryptedData.data);\n      }\n    } catch (e) {\n      logger.error(e);\n      debug('onData ERROR: data=', data);\n      debug('onData ERROR: data.toString()=', data.toString());\n    }\n  }\n\n  onClose(peerID, data) {\n    debugStages('WRTC MAYBE CLOSE');\n    debug('peerID', peerID);\n    if (!this.isAlive()) {\n      debugStages('WRTC CLOSE', data);\n      if (this.connected) {\n        // this.uiCommunicator(this.lifeCycle.RtcClosedEvent);\n        this.connected = false;\n      } else {\n        this.connected = false;\n      }\n    }\n  }\n\n  onError(peerID, err) {\n    debugStages('WRTC ERROR');\n    debug('peerID', peerID);\n    debug(err.code);\n    debug('error', err);\n    if (!this.connected && !this.tryingTurn && !this.turnDisabled) {\n      this.useFallback();\n    } else {\n      if (!this.isAlive()) {\n        this.uiCommunicator(this.lifeCycle.RtcErrorEvent);\n      }\n    }\n  }\n\n  // ----- WebRTC Communication Methods\n\n  sendRtcMessageClosure(type, msg) {\n    return () => {\n      debug(`[SEND RTC MESSAGE Closure] type:  ${type},  message:  ${msg}`);\n      this.rtcSend(JSON.stringify({ type, data: msg }));\n    };\n  }\n\n  sendRtcMessage(type, msg) {\n    debug(`[SEND RTC MESSAGE] type:  ${type},  message:  ${msg}`);\n    this.rtcSend(JSON.stringify({ type, data: msg }));\n  }\n\n  async rtcSend(arg) {\n    if (this.isAlive()) {\n      let encryptedSend;\n      if (typeof arg === 'string') {\n        encryptedSend = await this.mewCrypto.encrypt(arg);\n      } else {\n        encryptedSend = await this.mewCrypto.encrypt(JSON.stringify(arg));\n      }\n      debug('SENDING RTC');\n      this.p.send(JSON.stringify(encryptedSend));\n    } else {\n      // eslint-disable-next-line\n      this.uiCommunicator(this.lifeCycle.attemptedDisconnectedSend);\n      return false;\n    }\n  }\n\n  rtcDestroy() {\n    if (this.active) {\n      this.webRtcCommunication.rtcDestroy();\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);\n    }\n  }\n\n  disconnectRTCClosure() {\n    return () => {\n      debugStages('DISCONNECT RTC Closure');\n      this.connected = false;\n      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n      this.rtcDestroy();\n      this.instance = null;\n    };\n  }\n\n  disconnectRTC() {\n    debugStages('DISCONNECT RTC');\n    this.connected = false;\n    this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);\n    this.rtcDestroy();\n    this.instance = null;\n  }\n\n  retryViaTurn(data) {\n    try {\n      this.emit('retryingViaTurn');\n      this.states = this.setResetStates();\n      debugTurn('Retrying via TURN v2');\n      this.iceServers = null;\n      const options = {\n        servers: data.iceServers.map(obj => {\n          const newObject = {};\n          delete Object.assign(newObject, obj, { ['urls']: obj['url'] })['url'];\n          return newObject;\n        }),\n        webRtcConfig: {\n          initiator: true,\n          trickle: false,\n          iceTransportPolicy: 'relay',\n          config: {\n            iceServers: data.iceServers.map(obj => {\n              const newObject = {};\n              delete Object.assign(newObject, obj, { ['urls']: obj['url'] })[\n                'url'\n              ];\n              return newObject;\n            })\n          },\n          wrtc: wrtc\n        }\n      };\n      debug('turn info arrived and begin turn'); // todo remove dev item\n      this.initiatorStartRTC(options);\n    } catch (e) {\n      debugTurn('retryViaTurn error:', e);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}